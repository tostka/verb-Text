# verb-text.psm1


  <#
  .SYNOPSIS
  verb-Text - Generic text-related functions
  .NOTES
  Version     : 6.3.1.0
  Author      : Todd Kadrie
  Website     :	https://www.toddomation.com
  Twitter     :	@tostka
  CreatedDate : 4/8/2020
  FileName    : verb-Text.psm1
  License     : MIT
  Copyright   : (c) 4/8/2020 Todd Kadrie
  Github      : https://github.com/tostka
  REVISIONS
  * 4/8/2020 - 1.0.0.0 modularized
  # 11:15 AM 4/3/2020 initial version: added: Remove-StringDiacritic, Remove-StringLatinCharacters
  .DESCRIPTION
  verb-Text - Generic text-related functions
  .LINK
  https://github.com/tostka/verb-Text
  #>


    $script:ModuleRoot = $PSScriptRoot ;
    $script:ModuleVersion = (Import-PowerShellDataFile -Path (get-childitem $script:moduleroot\*.psd1).fullname).moduleversion ;
    $runningInVsCode = $env:TERM_PROGRAM -eq 'vscode' ;

#*======v FUNCTIONS v======




#*------v compare-CodeRevision.ps1 v------
function compare-CodeRevision {
    <#
    .SYNOPSIS
    compare-CodeRevision - Wrapper for Compare-Object to compare two revisions of a given text block of code. Defaults to appending Line numbers to the comparison output (suppress with -nolinenumbers).
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2022-01-10
    FileName    : compare-CodeRevision.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-text
    Tags        : Powershell,Development,ChangeTracking
    AddedCredit : PaulChavez
    AddedWebsite:	https://groups.google.com/g/microsoft.public.windows.powershell/c/0zoV5ekugXY
    AddedTwitter:	URL
    REVISIONS
    * 8:04 AM 1/11/2022 minor CBH update
    * 12:36 PM 1/10/2022 compare-CodeRevision:init
    .DESCRIPTION
    compare-CodeRevision - Wrapper for Compare-Object to compare two revisions of a given text block of code. Defaults to appending Line numbers to the comparison output (suppress with -nolinenumbers).
    
    Yea, [Git's](https://git-scm.com/) a *much* better choice for revision tracking - *if* you've been doing all editing in your *project directory*. But if you're doing debugging on a remote admin box, fixing the odd bug *on the fly*, by editing-and-'ipmo -force'ing the live installed module .psm1 copy, sometimes you just want to diff the *revised*/newly-functional *local* copy, across the network against your last commited source copy, to see how many changes you actually added (and which functions need to be duped back to your source, for git tracking/build). 
    .PARAMETER  Reference
    Code block reference for comparison[-Reference (gc c:\path-to\mod.psm1)]
    .PARAMETER  Difference
    Code block to be compared to the reference code[-Revision (gc c:\path-to\modv2.psm1)]
    .PARAMETER  NoLineNumbers
    Switch to suppress default line-number addition (in Reference & Difference code blocks)[-NoLineNumbers]
    .EXAMPLE
    $mod = 'verb-exo' ; 
    $ref = (gc "\\tsclient\c\sc\$mod\$mod\$mod.psm1")  ;
    $rev = (gc (gmo $mod).path)  ;
    $diff = Compare-CodeRevision $ref $rev ; 
    Compare local (updated) module code agaisnt reference dev source (via automatic RDP client pathing)
    .LINK
    https://gist.github.com/chillitom/8335042
    .LINK
    https://github.com/tostka/verb-text
    #>
    [CmdletBinding()]
    PARAM(
        [Parameter(Position=0,Mandatory=$True,HelpMessage="Code block reference for comparison[-Reference (gc c:\path-to\mod.psm1)]")]
        [ValidateNotNullOrEmpty()]
        $Reference,
        [Parameter(Position=1,Mandatory=$True,HelpMessage="Code block to be compared to the reference code[-Revision (gc c:\path-to\modv2.psm1)]")]
        [ValidateNotNullOrEmpty()]
        $Difference,
        [Parameter(Mandatory=$false,HelpMessage="Switch to suppress default line-number addition (in Reference & Difference code blocks)[-NoLineNumbers]")]
        [switch]$NoLineNumbers
    ) ;
    if(-not $NoLineNumbers){
        $smsg = "(adding line#'s...)" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$($smsg)" } ;
        $Reference = $Reference | %{$i = 1} { new-object psobject -prop @{LineNum=$i;Text=$_}; $i++} ;
        $Difference = $Difference | %{$i = 1} { new-object psobject -prop @{LineNum=$i;Text=$_}; $i++} ;
        $pltCO=[ordered]@{Reference = $Reference ;Difference = $Difference ;Property = 'Text' ;PassThru = $true ;} ;
    } else {
        $pltCO=[ordered]@{Reference = $Reference ;Difference = $Difference ; PassThru = $true ;} ;
    } ;  
     
    $smsg = "Compare-Object w`n$(($pltCO|out-string).trim())" ; 
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    else{ write-verbose "$($smsg)" } ;
    $diff = Compare-Object @pltCO ; 
    $diff | write-output ; 
}

#*------^ compare-CodeRevision.ps1 ^------


#*------v convert-CaesarCipher.ps1 v------
function convert-CaesarCipher {
    <#
    .SYNOPSIS
    convert-CaesarCipher - Converts passed string to/from Caesar cipher, using a passed integer Key [1-25]
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-06-18
    FileName    : convert-CaesarCipher.ps1
    License     : (none asserted)
    Copyright   : (none asserted)
    Github      : https://github.com/tostka/verb-text
    AddedCredit : M. McNabb
    AddedWebsite:	https://rosettacode.org/wiki/Caesar_cipher#PowerShell
    AddedTwitter:	URL
    REVISIONS
    * 2:13 PM 11/22/2021 made Key & string mandetory params; added range validation on Key
    * 6:22 PM 6/18/2021 convert-CaesarCipher:init
    .DESCRIPTION
    convert-CaesarCipher - Converts passed string to/from RotNN where NN is the '-Key' offset of the alphabet
    This cipher rotates (either towards left or right) the letters of the alphabet (A to Z).
The encoding replaces each letter with the 1st to `$Key-th letter in the alphabet (wrapping Z to A).
So key 2 encrypts "HI" to "JK", but key 20 encrypts "HI" to "BC".
This simple "mono-alphabetic substitution cipher" provides almost no security, because an attacker who has the encoded message can either use frequency analysis to guess the key, or just try all 25 keys.
Caesar cipher is identical to Vigenère cipher with a Key of length 1.
Also, Rot-13 is identical to Caesar cipher with Key 13. 
    .PARAMETER  path
    String to be converted[-string 'SAMPLEINPUT']
    .PARAMETER  key
Integer 'key' [1-25] to be used to encode[-key 2]
    .EXAMPLE
    convert-CaesarCipher -string 'YOU can convert a string to title case (every word start with a capital letter).' -key 13 ; 
    Encode a string.
    .EXAMPLE
    convert-CaesarCipher -string 'LBH pna pbaireg n fgevat gb gvgyr pnfr (rirel jbeq fgneg jvgu n pncvgny yrggre).' -decode -key 13
    Decode a string (actually, as we're using a 13 key, decrypting Rot13)
    .LINK
    https://github.com/tostka/verb-text
    .LINK
    https://rosettacode.org/wiki/Caesar_cipher#PowerShell    
    #>
    ##[Alias('convertTo-ProperCase')]
    [CmdletBinding()]
    PARAM(
        [Parameter(Position=0,Mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="String to be converted[-string 'SAMPLEINPUT']")]
        [String]$string,
        [Parameter(Position=1,Mandatory=$true,HelpMessage="Integer 'key' [1-25] to be used to encode[-key 2]")]
        [ValidateRange(1,25)]
        [String]$key,
        [Parameter(Position=1,Mandatory=$false,HelpMessage="Switch to trigger decode function (vs default encode)[-decode]")]
        [switch]$Decode
    ) ;
    
    BEGIN {
        $LowerAlpha = [char]'a'..[char]'z'
        $UpperAlpha = [char]'A'..[char]'Z'
    }
    PROCESS {
        $Chars = $string.ToCharArray() ; 
        
        #*------v Function _encode v------
        function _encode{
            param(
              $Char,
              $Alpha = [char]'a'..[char]'z'
            ) ; 
            $Index = $Alpha.IndexOf([int]$Char) ; 
            $NewIndex = ($Index + $Key) - $Alpha.Length ; 
            $Alpha[$NewIndex] ; 
        } ; #*------^ END Function _encode ^------
        #*------v Function _decode v------
        function _decode {
            param(
              $Char,
              $Alpha = [char]'a'..[char]'z'
            ) 
            $Index = $Alpha.IndexOf([int]$Char) ;
            $int = $Index - $Key ; 
            if ($int -lt 0) {$NewIndex = $int + $Alpha.Length}
            else {$NewIndex = $int} ; 
            $Alpha[$NewIndex] ; 
        } ; #*------^ END Function _decode ^------
        
        foreach ($Char in $Chars){
            if ([int]$Char -in $LowerAlpha){
                if ($decode) {$Char = _decode $Char}
                else {$Char = _encode $Char} ; 
            } elseif ([int]$Char -in $UpperAlpha){ ; 
                if ($Decode) {$Char = _decode $Char $UpperAlpha}
                else {$Char = _encode $Char $UpperAlpha}
            } ; 
            $Char = [char]$Char ; 
            [string]$OutText += $Char ; 
        } ; 
        $OutText | write-output ; 
        $OutText = $null ; 
    } # if-E-PROCESS
}

#*------^ convert-CaesarCipher.ps1 ^------


#*------v Convert-CodePointToPSSyntaxTDO.ps1 v------
function Convert-CodePointToPSSyntaxTDO {
    <#
    .SYNOPSIS
    Convert-CodePointToPSSyntaxTDO -  Converts a given Unicode CodePoint into the matching PSSyntax ([char]0xnnnn), [char]::ConvertFromUtf32(0xnnnnn)), returned as a Customobject summarizing the input CodePoint, the rendered Character it represents, and PSSyntax necessary to render the codepoint in Powershell
    .NOTES
    Version     : 0.0.5
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2024-09-12
    FileName    : Convert-CodePointToPSSyntaxTDO.ps1
    License     : MIT License
    Copyright   : (c) 2024 Todd Kadrie
    Github      : https://github.com/tostka/verb-text
    Tags        : Powershell,Host,Console,Output,Formatting
    AddedCredit : 
    AddedWebsite: 
    AddedTwitter: URL
    REVISIONS
    * 10:10 AM 9/16/2024 corrected github link/module assoc (vio -> vtxt)
    * 2:52 PM 9/12/2024 added CodePoint validator regex for PSCodePoint format (0xnnnn) ;  init

    .DESCRIPTION

    Convert-CodePointToPSSyntaxTDO -  Converts a given Unicode CodePoint into the matching PSSyntax ([char]0xnnnn), [char]::ConvertFromUtf32(0xnnnnn)), returned as a Customobject summarizing the input CodePoint, the rendered Character it represents, and PSSyntax necessary to render the codepoint in Powershell

    .PARAMETER CodePoint
    Unicode Codepoint (U+1F4AC|\u2717) to be converted into equivelent Powershell Syntax[-CodePoint 'U+1F4AC']
    .INPUT
    System.String[]
    .OUTPUT
    PSCustomObject summary of Codepoint, Character, and PSSyntax example to render the specified character
    .EXAMPLE
    PS> $Returned = Convert-CodePointToPSSyntaxTDO -CodePoint 'U+2620' -verbose
    PS> $Returned ; 

        CodePoint Character PSSyntax                        
        --------- --------- --------                        
        U+2620    ☠         [char]::ConvertFromUtf32(0x2620)

    PS> $Returned.PsSyntax ;

        [char]::ConvertFromUtf32(0x2620)

    Demo conversion of the codepoint for 'Skull & Crossbones' into PS Syntax
    .EXAMPLE
    PS> $codes = "U+2620 U+2623" ;     
    PS> $PSSyntax = ($item.CodePoint.split(' ') | Convert-CodePointToPSSyntaxTDO -Verbose:($PSBoundParameters['Verbose'] -eq $true) | select -expand PSSyntax ) -join ' ' ;         
    demo splitting a space-delimited set of CodePoints, looping them through Convert-CodePointToPSSyntaxTDO, and then space-joining them on return
    .LINK
    https://emojipedia.org/
    .LINK
    https://github.com/tostka/verb-text
    #>
    [CmdletBinding()]
    PARAM(
        [Parameter(Mandatory = $true, ValueFromPipeline=$true, HelpMessage = "Unicode Codepoint (U+1F4AC|\u2717) to be converted into equivelent Powershell Syntax[-CodePoint 'U+1F4AC']")]
        # \u2717 | U+1F600
        #[ValidatePattern("U\+[0-9a-fA-F]+|\\u[0-9a-fA-F]+")]
        [ValidatePattern("U\+[0-9a-fA-F]+|\\u[0-9a-fA-F]+|0x[0-9a-fA-F]+")] # updated rgx passes pre-converted PSCodePoint format
        [string[]]$CodePoint
    ) ;
    BEGIN {
        #region CONSTANTS-AND-ENVIRO #*======v CONSTANTS-AND-ENVIRO v======
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        if(($PSBoundParameters.keys).count -ne 0){
            $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
            write-verbose "$($CmdletName): `$PSBoundParameters:`n$(($PSBoundParameters|out-string).trim())" ;
        } ;
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        #endregion CONSTANTS-AND-ENVIRO #*======^ END CONSTANTS-AND-ENVIRO ^======
    } ;  # BEG-E
    PROCESS {
        foreach($point in $CodePoint){
            if($point -match "0x[0-9a-fA-F]+"){
                write-verbose "`$CodePoint $($point) is already in PSCodePoint format" ; 
                $psCodePoint = $point ; 
            }else{
                $psCodePoint = $point.replace('U+','0x').replace('\u','0x') ; 
            } ; 
            $PSSyntax = try{
                [char]$psCodePoint | out-null ;
                "[char]$($psCodePoint)"| write-output ;
            } catch {
                try{
                    [char]::ConvertFromUtf32($psCodePoint) | out-null;
                    "[char]::ConvertFromUtf32($($psCodePoint))" | write-output 
                }catch{throw "Unable to resolve Codepoint $(codepoint) to a working [char] string"}
            } ; 
            if($PSSyntax){
              write-verbose "Character: $($PSSyntax | invoke-expression)`n`PSSyntax:$($PSSyntax)" ; 
              [pscustomobject]([ordered]@{
                  CodePoint = $point ; 
                  Character = $($PSSyntax | iex) ; 
                  PSSyntax = $PSSyntax ; 
              }) | write-output ; 
              #$PSSyntax | write-output ; 
            } ;    
        } # loop-E  
    } 
    END {} ; 
}

#*------^ Convert-CodePointToPSSyntaxTDO.ps1 ^------


#*------v convertFrom-Base64String.ps1 v------
function convertFrom-Base64String {
    <#
    .SYNOPSIS
    convertFrom-Base64String - Convert Base64 encoded string back to original text, and return to pipeline
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-04-30
    FileName    : convertFrom-Base64String.ps1
    License     : MIT License
    Copyright   : (c) 2019 Todd Kadrie
    Github      : https://github.com/tostka
    AddedCredit : REFERENCE
    AddedWebsite:	URL
    AddedTwitter:	URL
    REVISIONS
    * 11:02 AM 9/5/2023 updated catch: wasn't echo'ing anything, just throw everything out. Considered putting in PROC loop, but w mix of string & path intputs, that'd be too hard to arbitrate between processing an inbound loop.
    * 3:58 PM 4/20/2022 Work in progress, was adding file 'sourcefile/targetfile' support, untested, I believe I had issues with the conversion, b64 wouldn't convert cleanly back to original (as part of the encoding for the invoke-soundcue bundled ping updates).
    * 10:38 AM 9/16/2021 removed spurious DefaultParameterSet matl and file/path test material (from convertto-b64...), added pipeline example to CBH, fixed CBH params (had convertfrom params spec'd); added email address conversion example
    * 8:26 AM 12/13/2019 convertFrom-Base64String:init
    .DESCRIPTION
    convertFrom-Base64String - Convert specified string from Base64 encoded string back to text and return to pipeline
    .PARAMETER string
    String to be decoded from Base64 [-string 'bXkgKnZlcnkqIG1pbmltYWxseSBvYmZ1c2NhdGVkIGluZm8']
    .PARAMETER SourceFile
    Optional param that designates path from which to read a file containing Base64 encoded content, to be decoded[-SourceFile 'c:\path-to\base64.txt']
    .PARAMETER TargetFile
    Optional param that designates path into which to write the decoded Base64 content [-TargetPath 'c:\path-to\file.png']
    .EXAMPLE
    PS> convertFrom-Base64String -string 'bXkgKnZlcnkqIG1pbmltYWxseSBvYmZ1c2NhdGVkIGluZm8=' ; 
    Convert Base64 encoded string back to original unencoded text
    .EXAMPLE
    PS> $EmailAddress = 'YWRkcmVzc0Bkb21haW4uY29t' | convertFrom-Base64String
    Pipeline conversion of encoded EmailAddress back to string.
    .EXAMPLE
    PS> convertTo-Base64String -path c:\path-to\file.png >> base64.txt ; 
    PS> $Media = ''UklGRmysA...TRIMMED...QD8/97/y/+8/7P/' ;
    PS> convertfrom-Base64String -string $media -TargetPath c:\path-to\file.png ; 
    Demo conversion of encoded wav file (using 
    .LINK
    #>
    [CmdletBinding()]
    [Alias('cfB64')]
    PARAM(
        [Parameter(Position=0,ValueFromPipeline=$true,HelpMessage="string to be decoded from Base64 [-string 'bXkgKnZlcnkqIG1pbmltYWxseSBvYmZ1c2NhdGVkIGluZm8']")]
            [String]$string,
        [Parameter(HelpMessage="Optional param that designates path from which to read a file containing Base64 encoded content, to be decoded[-SourceFile 'c:\path-to\base64.txt']")]
            [string]$SourceFile,
        [Parameter(HelpMessage="Optional param that designates path into which to write the decoded Base64 content [-TargetPath 'c:\path-to\file.png']")]
            [string]$TargetFile
    ) ;
    if($string -AND $SourceFile){
        throw "Please use either -String or -SourceFile, but not both!"
        break ; 
    } ; 
    
    $error.clear() ;
    TRY {
        if(-not($string) -AND $SourceFile){
            $string = Get-Content $SourceFile #-Encoding Byte ; 
        } elseif (-not($string)){
            throw "Please specify either -String '[base64-encoded string]', or -SourceFile c:\path-to\base64.txt" ; 
        } ; 
        
        if(-not $TargetFile){
            $String = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($string)) ;  
            write-verbose "returning output to pipeline" ;
            #[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($string))| write-output ;     
            $String | write-output ;     
        } else {
            write-verbose "writing output to specified:$($TargetFile)..." ; 
            <# 
            # Get-Content without -raw splits the file into an array of lines thus destroying the code
            # Text.Encoding interprets the binary code as text thus destroying the code
            # Out-File is for text data, not binary code
            #>
            #$Content = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($string)) ;  
            #$Content = [System.Convert]::FromBase64String($string)
            $folder = Split-Path $TargetFile ; 
            if(-not(Test-Path $folder)){
                New-Item $folder -ItemType Directory | Out-Null ; 
            } ; 
            #Set-Content -Path $TargetFile -Value $Content #-Encoding Byte ;
            [IO.File]::WriteAllBytes($TargetFile, [Convert]::FromBase64String($string))
        }; 
    } CATCH {
        $ErrTrapd=$Error[0] ;
        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    } ; 
}

#*------^ convertFrom-Base64String.ps1 ^------


#*------v convert-HtmlCodeToTextTDO.ps1 v------
function convert-HtmlCodeToTextTDO {
    <#
    .SYNOPSIS
    convert-HtmlCodeToTextTDO - Convert specified text html code to plain text (replace html tags & entities, configure whitespace) and return to pipeline
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-05-14
    FileName    : convert-HtmlCodeToTextTDO.ps1
    License     : (non-asserted)
    Copyright   : 
    Github      : https://github.com/tostka
    AddedCredit : Winston Fassett
    AddedWebsite:	http://winstonfassett.com/blog/author/Winston/
    REVISIONS
    * 8:34 AM 11/8/2023 name-clash with importExcel mod leverage of ConvertFrom-Html(): ren convertFrom-Html -> convert-HtmlCodeToTextTDO (alias:     convertFrom-HtmlTDO ; don't alias to old name, do alias to tagged variant: This doesn't convert web pages, it replaces common html entities, strips tags & configures raw text whitespace
    * 3:11 PM 5/14/2021 convertFrom-Html:init, added $file spec
    .DESCRIPTION
    convert-HtmlCodeToTextTDO - Convert specified text html to plain text (replace html tags & entities) and return to pipeline
    Minimal port of Winston Fassett's html-ToText()
    .PARAMETER  string
    File to be Base64 encoded (image, text, whatever)[-string path-to-file]
    .EXAMPLE
    convert-HtmlCodeToTextTDO.ps1 -string 'xxxxx' ; 
    .LINK
    http://winstonfassett.com/blog/2010/09/21/html-to-text-conversion-in-powershell/
    .LINK
    https://github.com/tostka/verb-text
    #>
    <# #-=-=-=MUTUALLY EXCLUSIVE PARAMS OPTIONS:-=-=-=-=-=
# designate a default paramset, up in cmdletbinding line
[CmdletBinding(DefaultParameterSetName='SETNAME')]
  # * set blank, if none of the sets are to be forced (eg optional mut-excl params)
  # * force exclusion by setting ParameterSetName to a diff value per exclusive param

# example:single $Computername param with *multiple* ParameterSetName's, and varying Mandatory status per set
    [Parameter(ParameterSetName='LocalOnly', Mandatory=$false)]
    $LocalAction,
    [Parameter(ParameterSetName='Credential', Mandatory=$true)]
    [Parameter(ParameterSetName='NonCredential', Mandatory=$false)]
    $ComputerName,
    # $Credential as tied exclusive parameter
    [Parameter(ParameterSetName='Credential', Mandatory=$false)]
    $Credential ;    
    # effect: 
    -computername is mandetory when credential is in use
    -when $localAction param (w localOnly set) is in use, neither $Computername or $Credential is permitted
    write-verbose -verbose:$verbose "ParameterSetName:$($PSCmdlet.ParameterSetName)"
#-=-=-=-=-=-=-=-=
#>
    [CmdletBinding(DefaultParameterSetName='fromstring')]
    [Alias('convertFrom-HtmlTDO')]
    PARAM(
        [Parameter(ParameterSetName='fromstring',Position=0,Mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="String to be converted from html to plain text[-string '<b>text</b>']")]
        [System.String]$string,
        [Parameter(ParameterSetName='fromfile',HelpMessage="File to be converted from HTML to Text (and returned to pipeline)[-PARAM SAMPLEINPUT]")]
        [ValidateScript({Test-Path $_})]
        [string]$File
    ) ;
    if($File){
        $String = (get-content $file -encoding byte) ; 
    } ;
    
    # remove line breaks, replace with spaces
    $string = $string -replace "(`r|`n|`t)", " "
    # write-verbose "removed line breaks: `n`n$string`n"

    # remove invisible content
    @('head', 'style', 'script', 'object', 'embed', 'applet', 'noframes', 'noscript', 'noembed') | % {
    $string = $string -replace "<$_[^>]*?>.*?</$_>", ""
    }
    write-verbose "removed invisible blocks: `n`n$string`n"

    # Condense extra whitespace
    $string = $string -replace "( )+", " "
    write-verbose "condensed whitespace: `n`n$string`n"

    # Add line breaks
    @('div','p','blockquote','h[1-9]') | % { $string = $string -replace "</?$_[^>]*?>.*?</$_>", ("`n" + '$0' )} 
    # Add line breaks for self-closing tags
    @('div','p','blockquote','h[1-9]','br') | % { $string = $string -replace "<$_[^>]*?/>", ('$0' + "`n")} 
    write-verbose "added line breaks: `n`n$string`n"

    #strip tags 
    $string = $string -replace "<[^>]*?>", ""
    write-verbose "removed tags: `n`n$string`n"

    # replace common entities
    @( 
    @("&amp;bull;", " * "),
    @("&amp;lsaquo;", "<"),
    @("&amp;rsaquo;", ">"),
    @("&amp;(rsquo|lsquo);", "'"),
    @("&amp;(quot|ldquo|rdquo);", '"'),
    @("&amp;trade;", "(tm)"),
    @("&amp;frasl;", "/"),
    @("&amp;(quot|#34|#034|#x22);", '"'),
    @('&amp;(amp|#38|#038|#x26);', "&amp;"),
    @("&amp;(lt|#60|#060|#x3c);", "<"),
    @("&amp;(gt|#62|#062|#x3e);", ">"),
    @('&amp;(copy|#169);', "(c)"),
    @("&amp;(reg|#174);", "(r)"),
    @("&amp;nbsp;", " "),
    @("&amp;(.{2,6});", "")
    ) | foreach-object { $string = $string -replace $_[0], $_[1] }
    write-verbose "replaced entities: `n`n$string`n"

    $string | write-output ;     
}

#*------^ convert-HtmlCodeToTextTDO.ps1 ^------


#*------v Convert-invertCase.ps1 v------
function Convert-invertCase {
    <#
    .SYNOPSIS
    Convert-invertCase - Convert passed string to Invert Case (UPPER->lower ; lower->UPPER) and return to pipeline
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-06-18
    FileName    : Convert-invertCase.ps1
    License     : MIT License
    Copyright   : (c) 2019 Todd Kadrie
    Github      : https://github.com/tostka
    AddedCredit : 
    AddedWebsite:	
    AddedTwitter:	
    REVISIONS
    * 6:22 PM 6/18/2021 Convert-invertCase:init
    .DESCRIPTION
    Convert-invertCase - Convert passed string to Invert Case (upper->lower ; lower -> upper) and return to pipeline
    .PARAMETER  string
    String to be converted[-string 'SAMPLEINPUT']
    .EXAMPLE
    Convert-invertCase.ps1 -string 'xxxxx' ; 
    .LINK
    https://github.com/tostka/verb-text
    #>
    [CmdletBinding()]
    PARAM(
        [Parameter(Position=0,Mandatory=$false,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="String to be converted[-string 'SAMPLEINPUT']")]
        [String]$string
    ) ;
    [array]$chars = $String -split "" ; 
    $output = $null ; 
    foreach($c in $chars){
        switch -regex -CaseSensitive ($c){
            '([A-Z])'{$output += $c.tolower() }
            '([a-z])'{$output += $c.toUpper() }
            default {$output += $c }
        }
    } ;
    $output | write-output ; 
}

#*------^ Convert-invertCase.ps1 ^------


#*------v convert-Rot13.ps1 v------
function convert-Rot13 {
    <#
    .SYNOPSIS
    convert-Rot13 - Converts passed string to/from Rot13 
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-06-18
    FileName    : convert-Rot13.ps1
    License     : MIT License
    Copyright   : (c) 2019 Todd Kadrie
    Github      : https://github.com/tostka
    AddedCredit : rosettacode.org
    AddedWebsite:	https://rosettacode.org/wiki/Rot-13#PowerShell
    AddedTwitter:	URL
    REVISIONS
    * 2:35 PM 11/22/2021 update CBH, this is invertable, so cmdlet name should be convert-Rot13, not to/from. 
    * 6:22 PM 6/18/2021 convert-Rot13:init
    .DESCRIPTION
    convert-Rot13 - Converts passed string to/from Rot13. Run encoded text back through and the origen text is returned
    Replace every letter of the ASCII alphabet with the letter which is "rotated" 13 characters "around" the 26 letter alphabet from its normal cardinal position   (wrapping around from   z   to   a   as necessary). 
    Rot13 is an invertible algorithm: applying the same algorithm to the input twice will return the origin text. 
    .PARAMETER  string
    String to be converted[-string 'SAMPLEINPUT']
    .EXAMPLE
    convert-Rot13 -string 'YOU can convert a string to title case (every word start with a capital letter).' ; 
    .LINK
    https://github.com/tostka/verb-text
    .LINK
    https://rosettacode.org/wiki/Rot-13#PowerShell
    #>
    [CmdletBinding()]
    PARAM(
        [Parameter(Position=0,Mandatory=$false,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="String to be converted[-string 'SAMPLEINPUT']")]
        [String]$string
    ) ;
    [char[]](0..64+78..90+65..77+91..96+110..122+97..109+123..255)[[char[]]$string] -join "" | write-output ; 
}

#*------^ convert-Rot13.ps1 ^------


#*------v convert-Rot47.ps1 v------
function convert-Rot47 {
    <#
    .SYNOPSIS
    convert-Rot47 - Converts passed string to/from Rot47. Run encoded text back through and the origen text is returned
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-06-18
    FileName    : convert-Rot47.ps1
    License     : (none asserted)
    Copyright   : (none asserted)
    Github      : https://github.com/tostka/verb-text
    AddedCredit : ChilliTom
    AddedWebsite:	https://gist.github.com/chillitom/8335042
    AddedTwitter:	URL
    REVISIONS
    * 2:35 PM 11/22/2021 update CBH, this is invertable, so cmdlet name should be convert-Rot13, not to/from. 
    * 6:22 PM 6/18/2021 convert-Rot47:init
    .DESCRIPTION
    convert-Rot47 - Converts passed string to/from Rot47 
    Replaces a character within the ASCII range [33, 126] with the character 47 character after it (rotation) in the ASCII table.
    Rot47 is an invertible algorithm: applying the same algorithm to the input twice will return the origin text. 
    .PARAMETER  path
    String to be converted[-string 'SAMPLEINPUT']
    .EXAMPLE
    convert-Rot47 -string 'YOU can convert a string to title case (every word start with a capital letter).' ; 
    .LINK
    https://github.com/tostka/verb-text
    .LINK
    https://gist.github.com/chillitom/8335042
    #>
    [CmdletBinding()]
    PARAM(
        [Parameter(Position=0,Mandatory=$false,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="String to be converted[-string 'SAMPLEINPUT']")]
        [Alias('in')]
        [String]$string
    ) ;
    $table = @{} ; 
    for ($i = 0; $i -lt 94; $i++) {
        $table.Add(
            "!`"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_``abcdefghijklmnopqrstuvwxyz{|}~"[$i],
            "PQRSTUVWXYZ[\]^_``abcdefghijklmnopqrstuvwxyz{|}~!`"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNO"[$i]) ; 
    } ; 
    $out = New-Object System.Text.StringBuilder ;
    $string.ToCharArray() | %{
        $char = if ($table.ContainsKey($_)) {$table[$_]} else {$_} ; 
        $out.Append($char) | Out-Null ; 
    } ; 
    $out.ToString() | write-output ; 
}

#*------^ convert-Rot47.ps1 ^------


#*------v convertto-AcronymFromCaps.ps1 v------
Function convertto-AcronymFromCaps {
    <#
    .SYNOPSIS
    convertto-AcronymFromCaps - Creates an Acroynm From string specified, by extracting only the Capital letters from the string
    .NOTES
    Author: Todd Kadrie
    Website:	http://tinstoys.blogspot.com
    Twitter:	http://twitter.com/tostka
    REVISIONS   :
    * 9:47 AM 8/31/2023 bad verb: ren create-AcronymFromCaps -> convertto-AcronymFromCaps, alias orig name; CBH, updated examples to have output demo
    * 9:34 AM 3/12/2021 added -doEXOSubstitution to auto-tag 'exo' cmds in generated acronym (part of autoaliasing hybrid cmds across both onprem & EXO); added -verbose support
    12:14 PM 2/16/2016 - working
    8:58 AM 2/16/2016 - initial version
    .DESCRIPTION
    convertto-AcronymFromCaps - Creates an Acroynm From string specified, by extracting only the Capital letters from the string
    Note:-doEXOSubstitution covers both 'exo' and 'xo' as String substrings because MS's newer ExchangeOnline v2 module arbitrarily blocks/reserves 'exo' prefix _for it's own_ new commandlets, necessitating users to retroactrively shift prior use of -commandprefix 'exo', in existing code, to another variant. In my case I routinely shift to 'xo' as prefix. 
    .PARAMETER  String
    String to be convered to a 'Capital Acrynym'[-String 'get-exoMailboxPermission]'
    .PARAMETER doEXOSubstitution
    switch to add an 'x' in output position _2_, when `$String, has 'exo' or 'xo' as a substring (used for tagging hybrid Exchange o365 cmdlets with a commandprefix)[-doEXOSubstitution]
    .INPUTS
    None
    .OUTPUTS
    System.String
    .EXAMPLE
    PS> convertto-AcronymFromCaps "get-AdGroupMembersRecurseManual" ;
    
        AGMRM
        
    Create a Capital-letter Acroynm for the specified string
    .EXAMPLE
    PS> $fn=".\$(convertto-AcronymFromCaps $scriptNameNoExt)-$(get-date -uformat '%Y%m%d-%H%M').csv" ;
    Create a filename based off of an Acronym from the capital letters in the ScriptNameNoExt.
    .EXAMPLE
    PS> $tCmdlet = 'Get-xoMailboxFolderStatistics' ; 
    PS> write-verbose 'get-command resolves to standardized name capitalization (regardless of input string case)'
    PS> $tCmdlet = (gcm $tCmdlet).Name ; 
    PS> set-alias -name "$(convertto-AcronymFromCaps -string $tCmdlet -doEXOSubstitution)" -value $tCmdlet ; 
    
        GxMFS
        
    Create an alias 'GxMFS' for the Exchange Online Get-xoMailboxFolderStatistics cmdlet (which in this case reflects an 'xo' commandprefix'd) . Example also pre-resolves the specified cmdlet name, to the default cmdlet Name capitalization scheme (for consistency; ensure it always produces the same acronym for a given cmdlet)
    .LINK
    https://github.com/tostka/verb-text
    #>
    [CmdletBinding()]
    [Alias('create-AcronymFromCaps')]
    Param(
        [Parameter(Position = 0, Mandatory = $True, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "String to be convered to a 'Capital Acrynym'[-String 'get-exoMailboxPermission]'")][ValidateNotNullOrEmpty()]
        [string]$String,
        [Parameter(HelpMessage="switch to add an 'x' in output position _2_, when `$String, has 'exo' or 'xo' as a substring (used for tagging hybrid Exchange o365 cmdlets with a commandprefix)[-doEXOSubstitution]")]
        [switch] $doEXOSubstitution
    ) ;
    $Verbose = ($VerbosePreference -eq 'Continue') ; 
    if($doEXOSubstitution){
        if($String -cmatch '((E)*)XO'){
            write-verbose "-doEXOSubstitution: Ucase 'EXO|XO' detected in `$String: .toLower()'ing the matched string, so that it only appears in output acronym as single lcase 'x', rather than full all caps '(E)XO'" 
            $String = $tcmdlet.replace($matches[0],$matches[0].tolower()) ; 
        } ; 
    } ;
    $AcroCap = $String -split "" -cmatch '([A-Z])' -join ""  ;
    if($doEXOSubstitution){
        if($String -match '((e)*)xo'){
            write-verbose "-doEXOSubstitution specified, and 'exo|xo' substring detected: adding 'x' into 2nd position of output" ; 
            $AcroCap = "$($AcroCap.substring(0,1))x$($AcroCap.substring(1,$AcroCap.length-1))" ; 
        } ; 
    } ; 
    write-verbose "output:$($AcroCap)" ; 
    write-output $AcroCap ;
}

#*------^ convertto-AcronymFromCaps.ps1 ^------


#*------v convertTo-Base64String.ps1 v------
function convertTo-Base64String {
    <#
    .SYNOPSIS
    convertTo-Base64String - Convert specified string or Path-to-file to Base64 encoded string and return to pipeline. If -String resolves to a path, it will be treated as a -SourceFile parameter (file content converted to Base64 encoded string). 
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2019-12-13
    FileName    : convertTo-Base64String.ps1
    License     : MIT License
    Copyright   : (c) 2019 Todd Kadrie
    Github      : https://github.com/tostka
    AddedCredit : REFERENCE
    AddedWebsite:	URL
    AddedTwitter:	URL
    REVISIONS
    * 10:12 AM 5/23/2024 add: -ForceString param, to permit encoding paths to b64 (insted of attempting to convert the file contents to b64).
    * 11:02 AM 9/5/2023 updated catch: wasn't echo'ing anything, just throw everything out.
    * 3:58 PM 4/20/2022 Work in progress, was adding file 'sourcefile/targetfile' support, untested, I believe I had issues with the conversion, b64 wouldn't convert cleanly back to original (as part of the encoding for the invoke-soundcue bundled ping updates).
    * 10:27 AM 9/16/2021 updated CBH, set -string as position 0, flipped pipeline to string from path, removed typo $file test, pre-resolve-path any string, and if it resolves to a file, load the file for conversion. Shift path validation into the body. 
    * 8:26 AM 12/13/2019 convertTo-Base64String:init
    .DESCRIPTION
    convertTo-Base64String - Convert specified string or Path-to-file to Base64 encoded string and return to pipeline. If String resolves to a path, it will be treated as a -path parameter (file content converted to Base64 encoded string). 
    .PARAMETER string
    String to be decoded from Base64 [-string 'bXkgKnZlcnkqIG1pbmltYWxseSBvYmZ1c2NhdGVkIGluZm8']
    .PARAMETER SourceFile
    Optional param that designates path from which to read a file containing Base64 encoded content, to be decoded[-SourceFile 'c:\path-to\base64.txt']
    .PARAMETER TargetFile
    Optional param that designates path into which to write the decoded Base64 content [-TargetPath 'c:\path-to\file.png']
    .PARAMETER ForceString
    Optional param that forces treament of -String as a string (vs file; avoids mis-recognition of string as a path to a file to be converted)
    .EXAMPLE
    PS> convertTo-Base64String -SourceFile C:\Path\To\Image.png > base64.txt ; 
    Example converting a png file to base64 and outputing result to text using redirection
    .EXAMPLE
    PS> convertto-base64string -sourcefile 'c:\path-to\some.jpg' -targetfile c:\tmp\b64.txt -verbose
    Example converting a jpg file to a base64-encoded text file leveraging the -targetfile parameter, and with verbose output 
    .EXAMPLE
    PS> convertTo-Base64String -string "my *very* minimally obfuscated info"
    .EXAMPLE
    PS> "address@domain.com" | convertTo-Base64String
    Pipeline conversion of an email address to b64
    .LINK
    #>
    [CmdletBinding(DefaultParameterSetName='File')]
    [Alias('CtB64')]
    PARAM(
        [Parameter(Position=0,ValueFromPipeline=$true,HelpMessage="string to be decoded from Base64 [-string 'bXkgKnZlcnkqIG1pbmltYWxseSBvYmZ1c2NhdGVkIGluZm8']")]
            [String]$string,
        [Parameter(HelpMessage="Optional param that designates path from which to read a file to be Base64 encoded[-SourceFile 'c:\path-to\base64.txt']")]
            [string]$SourceFile,
        [Parameter(HelpMessage="Optional param that designates path into which to write the encoded Base64 content [-TargetPath 'c:\path-to\file.png']")]
            [string]$TargetFile,
        [Parameter(HelpMessage="Optional param that forces treament of -String as a string (vs file; avoids mis-recognition of string as a path to a file to be converted)")]
            [switch]$ForceString
    ) ;
    $error.clear() ;
    TRY {
        if($SourceFile -OR ( -not $ForceString -AND ($SourceFile = $string| Resolve-Path -ea 0) ) ){
            if(test-path $SourceFile){
                write-verbose "(loading specified/resolved SourceFile:$($SourceFile))" ; 
                <# Get-Content without -raw splits the file into an array of lines thus destroying the code
                # Text.Encoding interprets the binary code as text thus destroying the code
                # Out-File is for text data, not binary code
                #>
                #$String = (get-content $SourceFile -encoding byte) ; 
                #$String = [Convert]::ToBase64String([IO.File]::ReadAllBytes($SourceFile))
                # direct convert 1-liner bin2b64
                if(-not $TargetFile){
                    write-verbose "returning output to pipeline" ;
                    $base64string = [Convert]::ToBase64String([IO.File]::ReadAllBytes($SourceFile))
                    $base64string | write-output ; 
                } else {
                    write-verbose "writing output to specified:$($TargetFile)..." ; 
                        $folder = Split-Path $TargetFile ; 
                        if(-not(Test-Path $folder)){
                            New-Item $folder -ItemType Directory | Out-Null ; 
                        } ; 
                        #Set-Content -Path $TargetFile -Value $Content #-Encoding Byte ;
                        #[IO.File]::WriteAllBytes($TargetFile, [Convert]::FromBase64String($String ))
                        [IO.File]::WriteAllBytes($TargetFile,[char[]][Convert]::ToBase64String([IO.File]::ReadAllBytes($SourceFile))) ; ; 
                }; 
                
            } else { throw "Unable to load specified -SourceFile:`n$($SourceFile))" } ; 
        } else { 
            $String = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($String)) ;
        } ; 
        if(-not $TargetFile){
            write-verbose "returning output to pipeline" ;
            $String | write-output ; 
        } else {
            write-verbose "writing output to specified:$($TargetFile)..." ; 
                $folder = Split-Path $TargetFile ; 
                if(-not(Test-Path $folder)){
                    New-Item $folder -ItemType Directory | Out-Null ; 
                } ; 
                Set-Content -Path $TargetFile -Value $Content #-Encoding Byte ;
                #[IO.File]::WriteAllBytes($TargetFile, [Convert]::FromBase64String($String ))
        }; 
    } CATCH {
        $ErrTrapd=$Error[0] ;
        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    } ; 
}

#*------^ convertTo-Base64String.ps1 ^------


#*------v convertto-Base64StringCommaQuoted.ps1 v------
function convertto-Base64StringCommaQuoted{
    <#
    .SYNOPSIS
    convertto-Base64StringCommaQuoted - Converts an array of Base64 strings, then into a comma-quoted delimited string, and outputs the result to the clipboard
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2022-11-18
    FileName    : convertto-Base64StringCommaQuoted
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-text
    Tags        : Powershell,Text,csv
    REVISIONS
    * 10:29 AM 9/26/2023 fix trailing ] typo on #33; added -outObject, and set verbose to dump the ouptut to pipeline (verifying it works if cb access issues); add: 'string' as param alias for str
    * 11:02 AM 9/5/2023 added proc-loop try-catch: wasn't echo'ing anything, just throw everything out.
    * 5:27 PM 11/18/2022 init
    .DESCRIPTION
    convertto-Base64StringCommaQuoted - Converts an array of strings Base64 string, then into a comma-quoted delimited string, and outputs the result to the clipboard
    .PARAMETER String
    Array of strings to be converted
    .PARAMETER outObject
    Switch that returns results to pipeline
    .LINK
    https://github.com/tostka/verb-text
    #>
    [CmdletBinding()] 
    PARAM(
		[Parameter(ValueFromPipeline=$true, HelpMessage='Array of strings to be converted')]
			[Alias('String')]
			[string[]]$str,
		[Parameter(HelpMessage='Switch that returns results to pipeline')]
			[switch]$outObject
	) ;
    BEGIN{$outs = @()}
    PROCESS{
		[array]$outs += $str | foreach-object{
			TRY{
				[Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($_)) ; 
			} CATCH {
				$ErrTrapd=$Error[0] ;
				$smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
				if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
				else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
				CONTINUE
			} ; 
        } ; 
    } ; 
    END {
		$ret = '"' + $(($outs) -join '","') + '"' | out-string  ; 
		if($ret){
			$ret | set-clipboard 
			if($outObject -OR ($VerbosePreference -eq "Continue")){$ret | write-output} 
		} else {
			write-verbose "No output" ; 
			if($outObject -OR ($VerbosePreference -eq "Continue")){$false | write-output} 
		} ;  ; 
	} ; 
}

#*------^ convertto-Base64StringCommaQuoted.ps1 ^------


#*------v ConvertTo-CamelCase.ps1 v------
function ConvertTo-CamelCase {
    <#
    .SYNOPSIS
    ConvertTo-CamelCase - Convert passed string to StudlyCaps\CrazyCaps etc (randomize uppper & lowercase) and return to pipeline
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-06-18
    FileName    : ConvertTo-CamelCase.ps1
    License     : MIT License
    Copyright   : (c) 2019 Todd Kadrie
    Github      : https://github.com/tostka
    AddedCredit : 
    AddedWebsite:	
    AddedTwitter:	
    REVISIONS
    * 6:22 PM 6/18/2021 ConvertTo-CamelCase:init
    .DESCRIPTION
    ConvertTo-CamelCase - Convert passed string to Invert Case (upper->lower ; lower -> upper) and return to pipeline
    CamelCase: Words are written without spaces, and the first letter of each word is capitalized. Also called Upper Camel Case or Pascal Casing.
    .PARAMETER  string
    String to be converted[-string 'SAMPLEINPUT']
    .EXAMPLE
    PS> ConvertTo-CamelCase.ps1 -string 'In PowerShell, the command used for string matching is of course Select-String' ; 
    .EXAMPLE
    PS> convertto-camelcase -string $string -AlphaNumeric $false 
    Converting a string, with Alphanumeric overridden (passes puncuation, high ascii chars, and other non-Alphanumeric characters).
    .LINK
    https://github.com/tostka/verb-text
    #>
    [Alias('convertTo-PascalCase','convertTo-UpperCamelCase')]
    [CmdletBinding()]
    PARAM(
        [Parameter(Position=0,Mandatory=$false,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="String to be converted[-string 'SAMPLEINPUT']")]
        [String]$string,
        [Parameter(Position=0,Mandatory=$false,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="boolean (defaults `$true) that strips all non-alphanumerics from the string[-string 'SAMPLEINPUT']")]
        [boolean]$AlphaNumeric=$true 
    ) ;
    # TitleCase, and strip spaces
    $txtInfo=(get-culture).TextInfo ;
    $string = "$($txtInfo.ToTitleCase($string.toLower()))".replace(' ','') 
    if($AlphaNumeric){
        $string = ($string -split "" |?{$_ -match '[a-zA-Z0-9]'}) -join '' ;
    }
    $string | write-output ; 
}

#*------^ ConvertTo-CamelCase.ps1 ^------


#*------v ConvertTo-CleanString.ps1 v------
function ConvertTo-CleanString {
    <#
    .SYNOPSIS
    ConvertTo-CleanString() - Wrapper function for verb-text\Remove-StringDiacritic() & verb-text\Remove-StringLatinCharacters(): Replaces diacritics (accents) characters and Latin (Polish crossed-L) chars with plain text equivs (Pipelines string through both funcs, in series)
    .NOTES
    Version     : 1.0.0
	Author      : Todd Kadrie
	Website     : http://www.toddomation.com
	Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2019-3-22
    FileName    : ConvertTo-CleanString.ps1
License     : MIT License
Copyright   : (c) 2024 Todd Kadrie
    Github      : https://github.com/tostka/verb-text
    Tags        : Powershell,Text,String,ForeignLanguage,Language
    REVISIONS
    * 9:06 AM 9/23/2024 init
    .DESCRIPTION
    ConvertTo-CleanString() - Wrapper function for verb-text\Remove-StringDiacritic() & verb-text\Remove-StringLatinCharacters(): Replaces diacritics (accents) characters and Latin (Polish crossed-L) chars with plain text equivs (Pipelines string through both funcs, in series)
    .PARAMETER String ;
    Specifies the String(s) on which the diacritics or latin/characters need to be removed ;
    .EXAMPLE
	PS> $clean = ConvertTo-CleanString -String "Helen Bräuchlę"  ;
	PS> write-host "'$($clean)'" ;

		'Helen Brauchle'
	.EXAMPLE
	write-verbose "Note: Clipboard tends to paste latin cyrillics as western charcters (removes diacritical from 'ę', pastes as 'e'), so pull from clipboard into a variable for processing, to ensure we're converting the raw latin characters with the functions" ;
	PS> $in = get-clipboard ;
	PS> write-host "'$($in)'" ;
	PS> [regex]$rgxAccentedNameChars = "[^a-zA-Z0-9\s\.\(\)\{\}\/\&\$\#\@\,\`"\'\’\:\–_-]" ; 
	PS> if($in -match $rgxAccentedNameChars){
	PS> 	$clean = $in |ConvertTo-CleanString ;
	PS> 	write-host "'$($clean)'" ;
	PS> } else {write-host "already clean raw text:$(in)" } ; 
	Demo pipeline conversion, sourced from clipboard (rather than pasted text string), avoids autoconversion performed on paste to console, by Powershell.
    .LINK
    https://lazywinadmin.com/2015/05/powershell-remove-diacritics-accents.html
    .LINK
    https://github.com/tostka/verb-text
    #>
    [CMdletBinding()]
    PARAM (
      [Parameter(Mandatory = $true,Position = 0,ValueFromPipeline = $true,ValueFromPipelineByPropertyName = $true, HelpMessage = 'Specifies the String(s) on which the diacritics need to be removed')]
		  [ValidateNotNullOrEmpty()][Alias('Text')]
		  [System.String[]]$String
    ) ;
    foreach ($StringValue in $String) {
        Write-Verbose -Message "$StringValue"
        TRY {
            # pipe stringvalue through Remove-StringDiacritic & Remove-StringLatinCharacters (Cyrillic)
            $StringValue |Remove-StringDiacritic -Verbose:($PSBoundParameters['Verbose'] -eq $true) |Remove-StringLatinCharacters -Verbose:($PSBoundParameters['Verbose'] -eq $true)
            #Write-Output $($NewString -as [string]) ;
        } CATCH {
			$ErrTrapd=$Error[0] ;
			$smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
			if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
			else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
		} ; 
    } ;
}

#*------^ ConvertTo-CleanString.ps1 ^------


#*------v ConvertTo-L33t.ps1 v------
function ConvertTo-L33t {
    <#
    .SYNOPSIS
    ConvertTo-L33t - replace vowels with similar shaped numberse, and return string to pipeline
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-06-18
    FileName    : ConvertTo-L33t.ps1
    License     : MIT License
    Copyright   : (c) 2019 Todd Kadrie
    Github      : https://github.com/tostka
    AddedCredit : REFERENCE
    AddedWebsite:	URL
    AddedTwitter:	URL
    REVISIONS
    * 6:22 PM 6/18/2021 ConvertTo-L33t:init
    .DESCRIPTION
    ConvertTo-L33t - replace vowels with similar shaped numberse, and return string to pipeline
    .PARAMETER  string
    String to be converted[-string 'SAMPLEINPUT']
    .EXAMPLE
    PS> convertto-l33t -string 'leet' 
    Convert replacing aeio with numerals, and the letter t with '7'
    .EXAMPLE
    PS> convertto-l33t -string 'leet' -vowelsonly
    Convert replacing aeio with numerals, only (no T->7 replacement)
    .LINK
    https://github.com/tostka/verb-text
    #>
    [CmdletBinding()]
    PARAM(
        [Parameter(Position=0,Mandatory=$false,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="String to be converted[-string 'SAMPLEINPUT']")]
        [String]$string,
        [Parameter(HelpMessage="replace only vowels in target string[-vowelsonly]")]
        [switch]$VowelsOnly
    ) ;
    $string = $string.replace("a", "4").replace("e", "3").replace("i", "1").replace("o", "0") 
    # .replace("u", "(_)") ; 
    if(!$VowelsOnly){
            $string = $string.replace('t','7') 
    } ; 
    $string | write-output ; 
}

#*------^ ConvertTo-L33t.ps1 ^------


#*------v ConvertTo-lowerCamelCase.ps1 v------
function ConvertTo-lowerCamelCase {
    <#
    .SYNOPSIS
    ConvertTo-lowerCamelCase - Convert passed string to StudlyCaps\CrazyCaps etc (randomize uppper & lowercase) and return to pipeline
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-06-18
    FileName    : ConvertTo-lowerCamelCase.ps1
    License     : MIT License
    Copyright   : (c) 2019 Todd Kadrie
    Github      : https://github.com/tostka/verb-text
    AddedCredit : 
    AddedWebsite:	
    AddedTwitter:	
    REVISIONS
    * 6:22 PM 6/18/2021 ConvertTo-lowerCamelCase:init
    .DESCRIPTION
    ConvertTo-lowerCamelCase - Convert passed string to Invert Case (upper->lower ; lower -> upper) and return to pipeline
    lowerCamelCase: Words are written without spaces, and the first letter of each word is capitalized, with the *exception* of the first letter, which is lowercase.
    .PARAMETER  string
    String to be converted[-string 'SAMPLEINPUT']
    .EXAMPLE
    PS> convertto-lowercamelcase -string 'i phone apple'
    .EXAMPLE
    PS> ConvertTo-lowerCamelCase -string $string -AlphaNumeric $false 
    Converting a string, with Alphanumeric overridden (passes puncuation, high ascii chars, and other non-Alphanumeric characters).
    .LINK
    https://github.com/tostka/verb-text
    #>
    [Alias('convertTo-PascalCase','convertTo-UpperCamelCase')]
    [CmdletBinding()]
    PARAM(
        [Parameter(Position=0,Mandatory=$false,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="String to be converted[-string 'SAMPLEINPUT']")]
        [String]$string,
        [Parameter(Position=0,Mandatory=$false,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="boolean (defaults `$true) that strips all non-alphanumerics from the string[-string 'SAMPLEINPUT']")]
        [boolean]$AlphaNumeric=$true 
    ) ;
    # TitleCase, strip spaces, and lcase the first character of the string
    $txtInfo=(get-culture).TextInfo ;
    $string = "$($txtInfo.ToTitleCase($string.toLower()))".replace(' ','') 
    if($AlphaNumeric){
        $string = ($string -split "" |?{$_ -match '[a-zA-Z0-9]'}) -join '' ;
    }
    $string.substring(0,1).tolower()+$string.substring(1) | write-output ; 
}

#*------^ ConvertTo-lowerCamelCase.ps1 ^------


#*------v convertTo-PSHelpExample.ps1 v------
Function convertTo-PSHelpExample {
    <#
    .SYNOPSIS
    convertTo-PSHelpExample - Given a ScriptBlock of unindented sample code, adds leading keyword, prefixes each code line with PS>, and adds empty line for description, for use in a CommentBasedHelp block. If -Scriptblock isn't specified, the current clipboard content is used.
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2022-03-01
    FileName    : convertTo-PSHelpExample.ps1
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-text
    Tags        : Powershell,Text,Code,Development,CommentBasedHelp
    REVISIONS
    * 1:36 PM 4/5/2023 suddenly set-clipboard -value breaks, param now shows as -Text: retooled splits, remove blank lines, coerce array and then coerse to text before writing to set-clipboard -text
    * 11:52 AM 9/8/2022 fix: #106 was writing codeblock with `n EOL, which resulted in [LF], instead of "proper" Win [CR][LF]. Pester complains, so updated to wright `n`r as EOL instead
    * 12:37 PM 6/1 7/2022 updated CBH, moved from vert-text -> verb-dev
    * 1:50 PM 3/1/2022 init
    .DESCRIPTION
    convertTo-PSHelpExample - Given a ScriptBlock of unindented sample code, adds leading keyword, prefixes each code line with PS>, and adds empty line for description, for use in a CommentBasedHelp block. If -Scriptblock isn't specified, the current clipboard content is used.
    To save time, pre-left-justify - move the scriptblock leftmost indent to the left margin, before running this process on the code 
    (e.g. don't have the block pre-indented beyond the minimum 1st level).

    Due to the vageries of parsing & splitting herestrings (e.g. attempting to feed the -ScriptBlock with a herestring), 
    it's generally simplest to let this off of code pre-copied to the clipboard
    (comes through cleanly as an array without further need for testing or conversion).

    .PARAMETER  ScriptBlock
    ScriptBlock of powershell to be wrapped reformatted to CBH code sample 
    .PARAMETER Wrap
    Switch to wrap (suffix semcolons with CrLFs) the specified block of code[-wrap]
    .PARAMETER NoPad
    Switch to suppress addition of extra NewLines in output code (true by default)[-noPad
    .EXAMPLE
    convertTo-PSHelpExample ;
    Default no-parameter behavior: Convert clipboard code content into a CBH help example-formatted block. 
    .EXAMPLE
    $text= "write-host 'yea';`ngci 'c:\somefile.txt' ;`n" | convertTo-PSHelpExample ;
    Pipeline example
    .LINK
    https://github.com/tostka/verb-Text
    #>
    [CmdletBinding()]
    PARAM(
        [Parameter(Position=0,Mandatory=$false,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="ScriptBlock of powershell to be wrapped reformatted to CBH code sample")]
        [Alias('Code')]
        [string[]]$ScriptBlock,
        [Parameter(HelpMessage="Switch to wrap (suffix semcolons with CrLFs) the specified block of code[-wrap]")]
        [switch]$Wrap,
        [Parameter(HelpMessage="Switch to suppress addition of extra NewLines in output code (true by default)[-noPad]")]
        [switch]$NoPad=$true 
    )  ; 
    $sCBHKeyword = '.EXAMPLE' ;
    $sCBHPrompt = 'PS> ' ;
    $fromCB = $false ; 
    if(-not $ScriptBlock){
        $ScriptBlock= (get-clipboard) # .trim().replace("'",'').replace('"','') ;
        if($ScriptBlock){
            write-verbose "No -ScriptBlock specified, detected text on clipboard:`n$($ScriptBlock)" ;
            $fromCB = $true ;
        } else {
            write-warning "No -path specified, nothing suitable found on clipboard. EXITING!" ;
            Break ;
        } ;
    } else {
        write-verbose "ScriptBlock:$($ScriptBlock)" ;
    } ;

    # we need split lines to prefix with PS> (and no blank lines)
    if(($ScriptBlock |  measure).count -eq 1){
        [array]$ScriptBlock = $ScriptBlock.Split([Environment]::NewLine, [StringSplitOptions]::RemoveEmptyEntries) ;
    } ; 

    # issue specific to PS, -replace isn't literal, see's $ as variable etc control char
    # rgx replace to prefix all special chars, to make them literals, before doing any text -replace (graveaccent escape ea)
    #$ScriptBlock = $scriptblock -replace '([$*\~;(%?.:@/]+)','`$1' ;
    # use wrapper function for the above
    $ScriptBlock=convertTo-EscapedPSText -ScriptBlock $ScriptBlock -Verbose:($PSBoundParameters['Verbose'] -eq $true) ; 
    
    if($wrap -OR ($ScriptBlock |  measure).count -eq 1){
        write-verbose "(-wrap: wrapping code at semicolons)" ; 
        #  code that wraps ;-delim'd code to prefixable lines
        # functional AHK: StringReplace clipboard, clipboard, `;, `;`r`n, All
        $splitAt = ";" ; 
        $replaceWith = ";$([Environment]::NewLine)" ; 
        # ";`r`n"  ; 
        $ScriptBlock = $ScriptBlock | Foreach-Object {
                $_ -replace $splitAt, $replaceWith ;
        } ; 
    } ;
    
    # ensure we have an array of separate lines to prefix - no empties
    if($scriptblock -isnot  [array] -OR (($ScriptBlock |  measure).count -eq 1)){
        write-verbose "(`$ScriptBlock non-Array, splitting on NewLines)" ; 
        # split into lines - looks like a wrapped block, but it's one line with crlfs - need each to loop and append prefixes, so split it out
        #[array]$ScriptBlock = $ScriptBlock.Split(@("`r`n", "`r", "`n"),[StringSplitOptions]::None) ;
        # above results in PS> [blank], drop the empties
        [array]$ScriptBlock = $ScriptBlock.Split([Environment]::NewLine, [StringSplitOptions]::RemoveEmptyEntries) ;
    } ; 
    
    # coercing every assign into array, and typing the aggreg
    if($nopad){
        [array]$CBH = @("$($sCBHKeyword)")
    } else {
        [array]$CBH = @("$($sCBHKeyword)`n")
    } ; 
    $ScriptBlock = @(
        $ScriptBlock | Foreach-Object {
            if($nopad){
                @($CBH += "$($sCBHPrompt) $($_)") 
            } else {
                #$CBH += "$($sCBHPrompt) $($_)`n" ;
                # above was creating examples with EOL [LF] vs [CR][LF], use both (Pester no-likey)
                @($CBH += "$($sCBHPrompt) $($_)`r`n" )
            }  
        } ; 
    ) ; 
    $CBH += @("SAMPLEOUTPUT") ; 
    $CBH += @("DESCRIPTION") ; 

    # reverse escapes - have to use dbl-quotes around escaped backtick (dbld), or it doesn't become a literal
    #$ScriptBlock = $scriptblock -replace "``([$*\~;(%?.:@/]+)",'$1'; 
    # wrapper function: 
    $CBH=convertFrom-EscapedPSText -ScriptBlock $CBH -verbose:$($VerbosePreference -eq "Continue") ;  ;  
    if($fromCB){
        write-host "(sending results back to clipboard)" ;
        #$CBH | out-clipboard ; 
        # 4/5/2023: suddenly set-clipboard -value breaks, param now shows as -Text [facepalm]
        <# -Files <FileSystemInfo[]>,-Html <String>,-Image <Image>,-Rtf <String>,-Text <String> #>
        # try default positional # nope, param error
        #set-clipboard $CBH ;
        # coerce system.array to string and use -text
        set-clipboard -text ($cbh | out-string) ; 
    } else { ; 
        # or to pipeline
        write-verbose "(sending results to pipeline)" ;
        $CBH | write-output ; 
    } ; 
}

#*------^ convertTo-PSHelpExample.ps1 ^------


#*------v convertTo-QuotedList.ps1 v------
Function convertTo-QuotedList {
    <#
    .SYNOPSIS
    Quote-List.ps1 - wrap list with quotes
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-04-17
    FileName    : Quote-List.ps1
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka
    Tags        : Powershell,Text
    REVISIONS
    * 10:54 AM 1/17/2023 # psv2 bug: $psitem isn't supported, need to use $_
    * 1:16 PM 11/22/2021 added presplit to lines; upgraded to adv function; ren'd quote-list -> convertTo-QuotedList ; made actually functional (wasn't, was a half-finished copy of quote-text)
    * 8:27 PM 5/23/2014
    .DESCRIPTION
    convertTo-QuotedList.ps1 - wrap list with quotes
    .LINK
    #>
    [CmdletBinding()]
    [Alias('quote-list')]
    PARAM(
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="String to be quote-wrapped[-PARAM SAMPLEINPUT]")]
        [string]$List
    ) ;
    write-verbose "lines:`n$($lines)" ;
    if( ($List.Split(@("`r`n", "`r", "`n"),[StringSplitOptions]::None) | measure).count -gt 1){
        write-verbose "(splitting multi-line block into array of lines)" ;
        $List = $List.Split(@("`r`n", "`r", "`n"),[StringSplitOptions]::None) ;  
    } ; 
    $List |foreach-object {
         "`"$($_)`""  ; 
    } ; 
}

#*------^ convertTo-QuotedList.ps1 ^------


#*------v ConvertTo-SCase.ps1 v------
function ConvertTo-SCase {
    <#
    .SYNOPSIS
    ConvertTo-SCase - Convert passed string to SentanceCase and return to pipeline (simplistic)
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-06-18
    FileName    : ConvertTo-SCase.ps1
    License     : MIT License
    Copyright   : (c) 2019 Todd Kadrie
    Github      : https://github.com/tostka
    AddedCredit : REFERENCE
    AddedWebsite:	URL
    AddedTwitter:	URL
    REVISIONS
    * 6:22 PM 6/18/2021 ConvertTo-SCase:init
    .DESCRIPTION
    ConvertTo-SCase - Convert passed string to SentanceCase and return to pipeline (simplistic)
    .PARAMETER  string
    String to be converted[-string 'SAMPLEINPUT']
    .EXAMPLE
    ConvertTo-SCase.ps1 -string 'xxxxx' ; 
    .LINK
    https://github.com/tostka/verb-text
    #>
    [Alias('convertTo-SentanceCase')]
    [CmdletBinding()]
    PARAM(
        [Parameter(Position=0,Mandatory=$false,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="String to be converted[-string 'SAMPLEINPUT']")]
        [String]$string
    ) ;
    # SentanceCase : capitalize first word, rest lcase (simplistic)
    ($string.substring(0,1).toupper())+($string.substring(1).tolower()) | write-output ; 
}

#*------^ ConvertTo-SCase.ps1 ^------


#*------v ConvertTo-SNAKE_CASE.ps1 v------
function ConvertTo-SNAKE_CASE {
    <#
    .SYNOPSIS
    ConvertTo-SNAKE_CASE - Convert passed string to StudlyCaps\CrazyCaps etc (randomize uppper & lowercase) and return to pipeline
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-06-18
    FileName    : ConvertTo-SNAKE_CASE.ps1
    License     : MIT License
    Copyright   : (c) 2019 Todd Kadrie
    Github      : https://github.com/tostka
    AddedCredit : 
    AddedWebsite:	
    AddedTwitter:	
    REVISIONS
    * 6:22 PM 6/18/2021 ConvertTo-SNAKE_CASE:init
    .DESCRIPTION
    ConvertTo-SNAKE_CASE - Convert passed string to Invert Case (upper->lower ; lower -> upper) and return to pipeline
    lowerCamelCase: Words are written without spaces, and the first letter of each word is capitalized, with the *exception* of the first letter, which is lowercase.
    .PARAMETER  string
    String to be converted[-string 'SAMPLEINPUT']
    .EXAMPLE
    PS> ConvertTo-SNAKE_CASE -string 'i phone apple'
    .EXAMPLE
    PS> ConvertTo-SNAKE_CASE -string $string -AlphaNumeric $false 
    Converting a string, with Alphanumeric overridden (passes puncuation, high ascii chars, and other non-Alphanumeric characters).
    .LINK
    https://github.com/tostka/verb-text
    #>
    [Alias('convertTo-PascalCase','convertTo-UpperCamelCase')]
    [CmdletBinding()]
    PARAM(
        [Parameter(Position=0,Mandatory=$false,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="String to be converted[-string 'SAMPLEINPUT']")]
        [String]$string,
        [Parameter(HelpMessage="boolean (defaults `$true) that strips all non-alphanumerics from the string[-string 'SAMPLEINPUT']")]
        [boolean]$AlphaNumeric=$true, 
        [Parameter(HelpMessage="switch that outputs resulting string in lowercase (vs default UPPER_CASE)[-useLower 'SAMPLEINPUT']")]
        [switch]$useLower
    ) ;
    if($useLower){
        $string = $string.toLower().replace(' ','_')  ; 
    } else { 
        $string = $string.toUpper().replace(' ','_')  ; 
    } ; 
    if($AlphaNumeric){
        $string = ($string -split "" |?{$_ -match '[a-zA-Z0-9_]'}) -join '' ;
    }
    $string | write-output ; 
}

#*------^ ConvertTo-SNAKE_CASE.ps1 ^------


#*------v convertto-StringCommaQuote.ps1 v------
function convertto-StringCommaQuote{
    <#
    .SYNOPSIS
    convertto-StringCommaQuote - Converts an array of strings into a comma-quoted delimited string
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2022-11-18
    FileName    : convertto-StringCommaQuote
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-text
    Tags        : Powershell,Text,csv
    REVISIONS
    * 5:27 PM 11/18/2022 init
    .DESCRIPTION
    convertto-StringCommaQuote - Converts an array of strings into a comma-quoted delimited string
    .PARAMETER String
    Array of strings to be comma-quote delimited
    .LINK
    https://github.com/tostka/verb-text
    #>
    [CmdletBinding()]
    PARAM([Parameter(ValueFromPipeline=$true)][string[]]$String) ;
    BEGIN{$outs = @()} 
    PROCESS{[array]$outs += $String | foreach-object{$_} ; } 
    END {'"' + $(($outs) -join '","') + '"' | out-string } ; 
}

#*------^ convertto-StringCommaQuote.ps1 ^------


#*------v ConvertTo-StringQuoted.ps1 v------
Function ConvertTo-StringQuoted {
    <#
    .SYNOPSIS
    ConvertTo-StringQuoted.ps1 - Wrap argument with quotes
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-04-17
    FileName    : ConvertTo-StringQuoted.ps1
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka
    Tags        : Powershell,Text
    REVISIONS
    * 9:22 AM 11/22/2021 updated to pipeline support, fixed non-func; flipped name quote-string-> ConvertTo-StringQuoted, with quote-string alias; added example to pass pester
    * 8:27 PM 5/23/2014 
    .DESCRIPTION
    ConvertTo-StringQuoted.ps1 - rap argument with quotes
    .EXAMPLE
    Mr. Watson, Come Here! | ConvertTo-StringQuoted
    .LINK
    #>
    [CmdletBinding()]
    [Alias('quote-string')]
    PARAM([Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="String to be quote-wrapped[-PARAM SAMPLEINPUT]")][string]$String
    ) ;
    "`"$($String)`"" | write-output ; 
}

#*------^ ConvertTo-StringQuoted.ps1 ^------


#*------v convertTo-StringReverse.ps1 v------
function convertTo-StringReverse {
    <#
    .SYNOPSIS
    convertTo-StringReverse - Reverse character order of passed string & return to pipeline
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-06-18
    FileName    : convertTo-StringReverse.ps1
    License     : MIT License
    Copyright   : (c) 2019 Todd Kadrie
    Github      : https://github.com/tostka
    AddedCredit : REFERENCE
    AddedWebsite:	URL
    AddedTwitter:	URL
    REVISIONS
    * 11:04 AM 11/19/2021 removed typo Crlf (prevented proper join), pulled strong typing on $string (prevented flipping to [array] for processing)
    * 6:22 PM 6/18/2021 convertTo-StringReverse:init
    .DESCRIPTION
    convertTo-StringReverse - Reverse character order of passed string & return to pipeline
    .PARAMETER  string
    String to be converted[-string 'SAMPLEINPUT']
    .EXAMPLE
    convertTo-StringReverse.ps1 -string 'YOU can convert a string to title case (every word start with a capital letter).' ; 
    .LINK
    https://github.com/tostka/verb-text
    #>
    [CmdletBinding(DefaultParameterSetName='File')]
    PARAM(
        [Parameter(Position=0,Mandatory=$false,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="String to be converted[-string 'SAMPLEINPUT']")]
        $string
    ) ;
    $string = $string.ToCharArray() ; 
    [Array]::Reverse($string) ;
    $string -join '' | write-output ; 
}

#*------^ convertTo-StringReverse.ps1 ^------


#*------v ConvertTo-StudlyCaps.ps1 v------
function convertTo-StUdlycaPs {
    <#
    .SYNOPSIS
    convertTo-StUdlycaPs - Convert passed string to StudlyCaps\CrazyCaps etc (random uppper & lowercase) and return to pipeline
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-06-18
    FileName    : convertTo-StUdlycaPs.ps1
    License     : MIT License
    Copyright   : (c) 2019 Todd Kadrie
    Github      : https://github.com/tostka
    AddedCredit : 
    AddedWebsite:	
    AddedTwitter:	
    REVISIONS
    * 6:22 PM 6/18/2021 convertTo-StUdlycaPs:init
    .DESCRIPTION
    convertTo-StUdlycaPs - Convert passed string to Invert Case (upper->lower ; lower -> upper) and return to pipeline
    .PARAMETER  string
    String to be converted[-string 'SAMPLEINPUT']
    .EXAMPLE
    convertTo-StUdlycaPs.ps1 -string 'xxxxx' ; 
    .LINK
    https://github.com/tostka/verb-text
    #>
    [Alias('convertTo-StUdlycaSe','convertTo-CrAzYCaPS')]
    [CmdletBinding()]
    PARAM(
        [Parameter(Position=0,Mandatory=$false,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="String to be converted[-string 'SAMPLEINPUT']")]
        [String]$string
    ) ;
    [array]$chars = $String -split "" ; 
    [string]$output = $null ; 
    foreach($c in $chars){
        switch (1,2|get-random){
            1 {$output += $c.tolower() }
            2 {$output += $c.toUpper() }
        }
    } ;
    $output | write-output ; 
}

#*------^ ConvertTo-StudlyCaps.ps1 ^------


#*------v convertTo-TitleCase.ps1 v------
function convertTo-TitleCase {
    <#
    .SYNOPSIS
    convertTo-TitleCase - Convert passed string to TitleCase and return to pipeline (simplistic)
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-06-18
    FileName    : convertTo-TitleCase.ps1
    License     : MIT License
    Copyright   : (c) 2019 Todd Kadrie
    Github      : https://github.com/tostka
    AddedCredit : REFERENCE
    AddedWebsite:	URL
    AddedTwitter:	URL
    REVISIONS
    * 6:22 PM 6/18/2021 convertTo-TitleCase:init
    .DESCRIPTION
    convertTo-TitleCase - Convert passed string to TitleCase and return to pipeline (simplistic)
    .PARAMETER  string
    String to be converted[-string 'SAMPLEINPUT']
    .EXAMPLE
    convertTo-TitleCase.ps1 -string 'YOU can convert a string to title case (every word start with a capital letter).' ; 
    .LINK
    https://github.com/tostka/verb-text
    #>
    [Alias('convertTo-ProperCase')]
    [CmdletBinding()]
    PARAM(
        [Parameter(Position=0,Mandatory=$false,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="String to be converted[-string 'SAMPLEINPUT']")]
        [String]$string
    ) ;
    # SentanceCase : capitalize first word, rest lcase (simplistic)
    $txtInfo=(get-culture).TextInfo ;
    # Doesn’t work on all-caps (make lcase first)
    "$($txtInfo.ToTitleCase($string.toLower()))" | write-output ; 
}

#*------^ convertTo-TitleCase.ps1 ^------


#*------v convertTo-UnWrappedText.ps1 v------
Function convertTo-UnWrappedText {
    <#
    .SYNOPSIS
    convertTo-UnWrappedText
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-04-17
    FileName    : convertTo-UnWrappedText
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-text
    Tags        : Powershell,Text
    REVISIONS   :
    * 9:34 AM 11/22/2021 swapped out hard-coded crlf, with os agnostic method (& purged unwrap-textN `n-targeting variant); made adv func ; ren'd unwrap-text -> convertTo-UnWrappedText, with unwrap-text alias; ren'd param to Text, w sText alias
    * 8:41 AM 4/12/2015, make it drop into the pipeline instead of return
    .DESCRIPTION
    convertTo-UnWrappedText
    .PARAMETER  sText
    Text to be unwrapped
    .INPUTS
    Accepts piped input.
    .OUTPUTS
    Outputs unwrapped text to pipeline
    .EXAMPLE
    get-fortune | convertTo-UnWrappedText | speak-words
    Get a fortune, unwrap the text, and text-to-speech the words
    .EXAMPLE
    convertTo-UnWrappedText $x ;
    .LINK
    https://github.com/tostka/verb-text
    #>
    [CmdletBinding()]
    [Alias('unwrap-text','Unwrap-TextN')]
    PARAM(
        [Parameter(Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelinebyPropertyName = $True, HelpMessage = 'Text to be unwrapped')]
        [Alias('sText')]
        [string]$Text
    )    
    Foreach ($sTxt in $Text) {
        $sTxt0 = $sTxt.replace(([Environment]::NewLine)," ");
        return $sTxtO;
    } 
}

#*------^ convertTo-UnWrappedText.ps1 ^------


#*------v convertTo-WordsReverse.ps1 v------
Function convertTo-WordsReverse {
    <#
    .SYNOPSIS
    convertTo-WordsReverse - Reverse the order of words in a sentance/phrase. 
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-11-08
    FileName    : convertTo-WordsReverse.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-text
    Tags        : Powershell,Text
    AddedCredit : REFERENCE
    AddedWebsite:	URL
    AddedTwitter:	URL
    REVISIONS
    * 10:54 AM 1/17/2023 # psv2 bug: $psitem isn't supported, need to use $_
    * 5:01 PM 4/6/2022 add name reverse example
    * 10:34 AM 11/19/2021 init
    .DESCRIPTION
    convertTo-WordsReverse - Reverse the order of words in a sentance/phrase. 
    Included silly period-to-line-end code, to avoid parsing periods into mid-phrase, where in original text.    
    (silly, but looks better in output). 
    -TextOnly switch suppresses punctuation, which normally space-splits associated with it's proximate word, and clutters the output. 
    .PARAMETER  lines
    Text to be reversed in word-order[-lines 'THESE are the times that try men's souls.']
    .EXAMPLE
    PS> "Those who would give up essential Liberty, to purchase a little temporary Safety, deserve neither Liberty nor Safety." | convertTo-WordsReverse ;
    Safety nor Liberty neither deserve Safety, temporary little a purchase to Liberty, essential up give would who Those.
    Simple example reversing a phrase
    .EXAMPLE
    PS> $h=@"
Caesar had his Brutus, Charles the First his Cromwell; and George the Third
- ['Treason!' cried the Speaker] -
may profit by their example. 
If this be treason, make the most of it. 
― Patrick Henry
"@ ; 
    PS> convertTo-WordsReverse -lines $h -textonly -verbose; 
        Third the George and Cromwell his First the Charles Brutus his had Caesar
        Speaker the cried Treason
        example their by profit may
        it of most the make treason be this If
        Henry Patrick
    Processing herestring block with TextOnly & verbose options. 
    .EXAMPLE
    PS> $h1=@"
Some say the world will end in fire,
Some say in ice.
From what I've tasted of desire
I hold with those who favor fire.
"@ ; 
    PS> $h1 | convertTo-WordsReverse  ; 
        fire, in end will world the say Some
        ice in say Some.
        desire of tasted I've what From.
        fire favor who those with hold I.    
    Pipeline processing of herestring block 
    .EXAMPLE
    PS> ('Atticus Ross' | convertTo-WordsReverse) -replace ' ',', ' ;
        Ross, Atticus 
    Demo turning an 'FName Lname' string into 'Lname, Fname'
    .LINK
    https://github.com/tostka/verb-Text
    #>
    [CmdletBinding()]
    param(
        [Parameter(Position=0,Mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Text to be reversed in word-order [-lines 'THESE are the times that try men's souls.']")]
        [ValidateNotNullOrEmpty()][Alias('text','string')]
        #[String]
        $lines,
        [Parameter(HelpMessage="Switch to pre-purge all non-alphanumeric chars (e.g. punctuation)[-TextOnly]")]
        [switch]$TextOnly
    )  ; 
    $rgxNonText = "[^a-zA-Z0-9 ]" ; 
   write-verbose "lines:`n$($lines)" ;
    if( ($lines.Split(@("`r`n", "`r", "`n"),[StringSplitOptions]::None) | measure).count -gt 1){
        write-verbose "(splitting multi-line block into array of lines)" ;
        # block with line returns, split it into an array for processing
        # advanatage of this, if input naturally has empty lines, it will not remove them, 
        # while env::newline naturally pads them, and the split remove *always* purges them back out. 
        $lines = $lines.Split(@("`r`n", "`r", "`n"),[StringSplitOptions]::None) ;  
        # trailing purge of empty lines (prevents periods on their own lines)
        $lines = $lines | where-object {$_} ; 
    } ; 

    # it's flipping line order, try aggregating to an array
    $out = @() ; 
    #$lines = $lines | foreach-object {
    $lines | foreach-object {
        if($TextOnly){
            write-verbose "(-TextOnly, removing all but:$($rgxNonText))"
            $l = $_ -replace $rgxNonText,'' ;
        } else {
            $l = $_ ; 
        } ; 
        [boolean]$hasPeriod = $false ; 
        write-verbose $_ ; 
        if($l -match '\.$'){
            $hashPeriod = $true ;
            $l = [regex]::match($l,'(.*)\.').captures[0].groups[1].value ;
        } else { 
            #$l = $_ 
        } ; 
        $array = $l -Split '\s' 
        #$array[($l.Count-1)..0] -join ' '
        [Array]::Reverse($array) ;
        if($hashPeriod){
            #"$($array -join ' ')."  
            $out+= "$($array -join ' ')." 
        } else { 
            #$array -join ' ' # | write-output ; 
            $out+= $array -join ' '
        } ; 
    } ; 
    
    #$lines | write-output ; 
    $out | Write-Output ;
    
}

#*------^ convertTo-WordsReverse.ps1 ^------


#*------v convertTo-WrappedText.ps1 v------
Function convertTo-WrappedText {
    <#
    .SYNOPSIS
    convertTo-WrappedText - Wrap a string at specified number of characters
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-11-08
    FileName    : convertTo-WrappedText.ps1
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-text
    Tags        : Powershell,Text
    AddedCredit : REFERENCE
    AddedWebsite:	URL
    AddedTwitter:	URL
    REVISIONS
    * 9:32 AM 11/22/2021 ren'd wrap-text -> convertTo-WrappedText, w wrap-text alias; added pipeline support ; spliced over -chars 'window' support from wordwrap-string.ps1 (and retired the variant); pulled strong type on $chars, shifted nchars name to an alias, and renamed it Characters; renamed $sText to $Text and shifted sText to an alias; added $host.name checking for 'Window' use
    * 8:35 PM 11/8/2021 typo'd postion on 2nd param; updated CBH to modern spec; added param name aliases (standardizing param names); added clipboard check for sText; defaulted nChars to 80
    * added CBH
    .DESCRIPTION
    convertTo-WrappedText - Wrap a string at specified number of characters
    .PARAMETER  Text
    String to be wrapped[-Text 'Four score and seven years ago']
    .PARAMETER  Characters
[int]Character number to wrap at, or 'WINDOW' to indicate wrap should be performed at width of current window[-Wrap 'WINDOW']
    .EXAMPLE
    $text=convertTo-WrappedText -sText "Please send issues to technisbetas@gmail.com, putting them in the reviews doesn't help me find fix them" -nChars 30 ;
    .LINK
    https://github.com/tostka/verb-Text
    #>
    [CmdletBinding()]
    [Alias('wrap-text')]
    param(
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="String to be wrapped[-Text 'Four score and seven years ago']")]
        [Alias('String','sText')]
        [string]$Text, 
        #[Parameter(Position=1,HelpMessage="Number of characters, at which to wrap the string[-nChars 120")]
        [Parameter(Position = 1, Mandatory = $True, HelpMessage = "[int]Character number to wrap at, or 'WINDOW' to indicate wrap should be performed at width of current window[-Wrap 'WINDOW']")][ValidateNotNullOrEmpty()]
        [Alias('nChars')]
        #[int]
        $Characters=80
    ) 
    
    switch ($Characters.GetType().FullName){
        'System.String' {
            if ($Characters.ToUpper() -eq "WINDOW") {
                switch ($host.name){
                    'ConsoleHost' {
                        [int]$Characters = (get-host).ui.rawui.windowsize.width ; 
                        write-verbose "wrapping to WINDOW -Characters:$($Characters)" ; 
                    }
                    default {
                        write-verbose "$($host.name):-Characters:$($Characters)`n$($Text.length) chars long" ;
                        throw "$($host.name) is not a supported host for this script with the -Characters 'Window' option`nPlease use an interger number instead" ;
                    } ; 
                } ; 
            } else {
                Throw "Unrecognized -Characters string (Please use an integer, or the word 'Window')" ;
            } ;
        } 
        'System.Int32' {
            write-verbose "wrapping to -Characters:$($Characters)" ; 
        } ;
        default {
            Throw "Unrecognized -Characters spec (Please use an integer number, or the word 'Window')" ; 
        } 
    } ; 
    
    if(-not $Text){
        $Text= (get-clipboard) # .trim().replace("'",'').replace('"','') ;
        if($Text){
            write-verbose "No -Text specified, detected text on clipboard:`n$($Text)" ;
        } else {
            write-warning "No -path specified, nothing suitable found on clipboard. EXITING!" ;
            Break ;
        } ;
    } else {
        write-verbose "Text:$($Text)" ;
    } ;
    
    $words = $Text.split(" ");
    $sPad = $sTextO = "";
    foreach ($word in $words) {
        if (($sPad + " " + $word).length -gt $Characters) {
            $sTextO = $sTextO + $sPad + [Environment]::Newline ;
            $sPad = $word ;
        }
        else {$sPad = $sPad + " " + $word  } ;
    }  ;
    if ($sPad.length -ne 0) {$sTextO = $sTextO + $sPad };
    $sTextO | write-output ; 
}

#*------^ convertTo-WrappedText.ps1 ^------


#*------v convert-UnicodeUPlusToCharCode.ps1 v------
function convert-UnicodeUPlusToCharCode {
    <#
    .SYNOPSIS
    convert-UnicodeUPlusToCharCode - Convert a Unicode U+nnnn literal into a Code Point, Decimal, and equivelent [char]0xnnn string
    .NOTES
    Version     : 0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 20240619-0300PM
    FileName    : convert-UnicodeUPlusToCharCode.ps1
    License     : MIT License
    Copyright   : (c) 2023 Todd Kadrie
    Github      : https://github.com/tostka/verb-Text
    Tags        : Powershell,Unicode,Type,Fonts,Conversion
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 3:46 PM 7/11/2024 shift into verb-text
    * 8:18 AM 6/20/2024 init, working, though likely/untested that long codepoints fail (at least they did in cmdline testing)
    .DESCRIPTION
    convert-UnicodeUPlusToCharCode - Convert a Unicode U+nnnn literal into a Code Point, Decimal, and equivelent [char]0xnnn string

    ## Unicode Ranges

        - Control Codes span U+0000 	0  to U+009F 	159
        - Basic Latin spans U+0020 	  	32 to U+007E 	~ 	126
        - Latin-1 Supplement spans U+00A0 	  	160  to U+00FF 	ÿ 	255
        - Latin Extended-Apans U+0100 	Ā 	256 to U+017F 	ſ 	383
        - Latin Extended-B spans U+0180 ƀ 384 to U+024F ɏ 591
        - Latin Extended Additional spans U+1E00 	Ḁ to U+1EFF 	ỿ 
        - IPA Extensions spans U+0250 ɐ 	592  to U+02AF ʯ 687
        - Spacing modifier letters spans U+02B0 	ʰ 	688 to U+02FF 	˿ 	767 
        - Combining marks spans U+0300 	   ̀ 	768 to U+036F 	   ͯ 	879
        - Greek and Coptic spans U+0370 	Ͱ 	880 to U+03FF 	Ͽ 	1023
        - Greek Extended spans U+1F00 	ἀ to U+1FFE ῾
        - Cyrillic spans U+0400 	Ѐ to 
        [ long list of language specific variants]
        - Unicode symbols spans U+2013 	– to U+204A 	⁊
        - General Punctuation spans U+2000 to U+206F 
        - Currency Symbols spans U+20A0 	₠ to U+20C0 	⃀
        - Letterlike Symbols spans U+2100 	℀ to U+214F ⅏
        - Number Forms spans U+2150 	⅐ to U+218B ↋
        - Arrows spans U+2190 	← to U+21FF ⇿
        - Mathematical symbols spans U+2200 	∀ to U+22FF ⋿
        - Miscellaneous Technical spans U+2300 	⌀ to U+23FF ⏿
        - Enclosed Alphanumerics spans U+2460 	① 	to U+24FF ⓿
        - Box Drawing spans U+2500 	─ to U+257F ╿
        - Block Elements spans U+2580 	▀  to U+259F 	▟ 
        - Geometric Shapes spans U+25A0 	■  to U+25FF 	◿ 
        - Miscellaneous Symbols spans U+2600 	☀ to U+26FF ⛿
        - Dingbats spans U+2700 	✀  to U+27BF 	➿ 
        - Alchemical symbols spans U+1F700 	🜀 to U+1F77 
        - Domino Tiles spans U+1F030 	🀰 to U+1F093 🂓
        - Playing Cards spans U+1F0A0 	🂠  to U+1F0F5 🃵
        - Chess Symbols spans U+1FA00 to U+1FA6D

        # getting from U+nnnn to [char]"code"
        U+0034 is the code for digit 4
        to make it a usable character code, 
        [char]0x34
        - carve U+0 off the front, prefix it with 0x, then and type the resulting string as [char] 
        [char]0x34
        4
        - you can pad with zeros to accomodate longer hex
        [char]0x0034
        4

        Unicode code points appear as U+<codepoint>?
        For example, U+2202 represents the character ∂.


        U+2705 	✅ 	White heavy check mark 
        U+2709 	✉ 	Envelope 
        U+270A 	✊ 	Raised fist
        U+270B 	✋ 	Raised hand 
        U+270C 	✌ 	Victory hand
        U+270D 	✍ 	Writing hand 
        U+2713 	✓ 	Check mark
        U+2714 	✔ 	Heavy check mark
        U+2715 	✕ 	Multiplication X
        U+2716 	✖ 	Heavy multiplication X
        U+2717 	✗ 	Ballot X
        U+2718 	✘ 	Heavy ballot X 
        U+2726 	✦ 	Black four-pointed star
        U+2727 	✧ 	White four-pointed star
        U+2728 	✨ 	Sparkles
        U+2729 	✩ 	Stress outlined white star
        U+272A 	✪ 	Circled white star
        U+272B 	✫ 	Open center black star
        U+272C 	✬ 	Black center white star
        U+272D 	✭ 	Outlined black star
        U+272E 	✮ 	Heavy outlined black star
        U+272F 	✯ 	Pinwheel star
        U+2730 	✰ 	Shadowed white star 
        U+2744 	❄ 	Snowflake
        U+2745 	❅ 	Tight trifoliate snowflake
        U+2746 	❆ 	Heavy chevron snowflake 
        U+274C 	❌ 	Cross mark 
        U+274E 	❎ 	Negative squared cross mark 
        U+2753 	❓ 	Black question mark ornament
        U+2754 	❔ 	White question mark ornament
        U+2755 	❕ 	White exclamation mark ornament
        U+2757 	❗ 	Heavy exclamation mark symbol 
        U+2764 	❤ 	Heavy black heart 
        U+2776 	❶ 	Dingbat negative circled digit one
        U+2777 	❷ 	Dingbat negative circled digit two
        U+2778 	❸ 	Dingbat negative circled digit three
        U+2779 	❹ 	Dingbat negative circled digit four
        U+277A 	❺ 	Dingbat negative circled digit five
        U+277B 	❻ 	Dingbat negative circled digit six
        U+277C 	❼ 	Dingbat negative circled digit seven
        U+277D 	❽ 	Dingbat negative circled digit eight
        U+277E 	❾ 	Dingbat negative circled digit nine
        U+277F 	❿ 	Dingbat negative circled digit ten
        U+2780 	➀ 	Dingbat circled sans-serif digit one
        U+2781 	➁ 	Dingbat circled sans-serif digit two
        U+2782 	➂ 	Dingbat circled sans-serif digit three
        U+2783 	➃ 	Dingbat circled sans-serif digit four
        U+2784 	➄ 	Dingbat circled sans-serif digit five
        U+2785 	➅ 	Dingbat circled sans-serif digit six
        U+2786 	➆ 	Dingbat circled sans-serif digit seven
        U+2787 	➇ 	Dingbat circled sans-serif digit eight
        U+2788 	➈ 	Dingbat circled sans-serif digit nine
        U+2789 	➉ 	Dingbat circled sans-serif digit ten
        U+278A 	➊ 	Dingbat negative circled sans-serif digit one
        U+278B 	➋ 	Dingbat negative circled sans-serif digit two
        U+278C 	➌ 	Dingbat negative circled sans-serif digit three
        U+278D 	➍ 	Dingbat negative circled sans-serif digit four
        U+278E 	➎ 	Dingbat negative circled sans-serif digit five
        U+278F 	➏ 	Dingbat negative circled sans-serif digit six
        U+2790 	➐ 	Dingbat negative circled sans-serif digit seven
        U+2791 	➑ 	Dingbat negative circled sans-serif digit eight
        U+2792 	➒ 	Dingbat negative circled sans-serif digit nine
        U+2793 	➓ 	Dingbat negative circled sans-serif digit ten
        U+2794 	➔ 	Heavy wide-headed rightward arrow
        U+2795 	➕ 	Heavy plus sign
        U+2796 	➖ 	Heavy minus sign
        U+2797 	➗ 	Heavy division sign 
        U+279C 	➜ 	Heavy round-tipped rightward arrow
        U+279D 	➝ 	Triangle-headed rightward arrow
        U+279E 	➞ 	Heavy triangle-headed rightward arrow
        U+279F 	➟ 	Dashed triangle-headed rightward arrow
        U+27A0 	➠ 	Heavy dashed triangle-headed rightward arrow
        U+27A1 	➡ 	Black rightward arrow
        U+27A2 	➢ 	Three-D top-lighted rightward arrowhead
        U+27A3 	➣ 	Three-D bottom-lighted rightward arrowhead
        U+27A4 	➤ 	Black rightward arrowhead 
        U+2620 	☠ 	Skull & Crossbones
        U+2622 ☣ Ionizing radiation
        U+2623 ☣ Biological hazard 	
        U+26A1 ⚡︎ High voltage
        U+26CC ⛌ Accident
        U+2615 ☕ drink
        U+2639 ☹ frowny
        U+263A ☺ smiley
        U+263B ☻ dark smiley
        U+26B0 	⚰ coffin
        U+26BF ⚿ Parental Controls

    #     For showing all (or almost all) characters run the following code. The example gets 15.000 characters.
    # Showing Unicode 16-bit character
    for($i=0; $i-lt15000;$i++) {
        "Char $i : $([char]$i)"
    }
    # Want more fun? Get Emoji Characters …
    [char]::ConvertFromUtf32(0x1F4A9)
    [char]::ConvertFromUtf32(0x1F601)
    [Full Emoji List, v15.1](https://unicode.org/emoji/charts/full-emoji-list.html)
    - includes Code U+1F600 and samples (browser, gmail, CLDR shortname)
    - spans U+1F600 	😀 	😀 	😀 	grinning face to [ downloads a looong time, never completes, it's a lot of chars]

    Convert glyph to Unicode CodePoint
    $ThumbsUp = "👍" ; 
    $utf32bytes = [System.Text.Encoding]::UTF32.GetBytes( $ThumbsUp ) ; 
    $codePoint = [System.BitConverter]::ToUint32( $utf32bytes ) ; 
    "0x{0:X}" -f $codePoint ; 

    # [Unicode literals in PowerShell – mnaoumov.NET](https://mnaoumov.wordpress.com/2014/06/14/unicode-literals-in-powershell/)
    C# has three ways to declare Unicode literals.
    \x 
    \u 
    \U 
    # example
    char x1Upper = '\xA';
    char x2Lower = '\xab';
    char x3Upper = '\xABC';
    char x4Mixed = '\xaBcD';
    char uUpper = '\uABCD';
    char UMixed = '\U000abcD1';

    But none of Unicode literals are available in PowerShell

    \xnnnn and \unnnn literals can be expressed by a simple cast hex int to char.

    $x1Upper = [char] 0xA
    $x2Lower = [char] 0xab
    $x3Upper = [char] 0xABC
    $x4Mixed = [char] 0xaBcD
    $uUpper = [char] 0xABCD

    \Unnnnnnnn literals require a bit more sophisticated approach

    PS> $UMixed = [char]::ConvertFromUtf32(0x000abcD1) ; 

    The last approach is the most generic and works for all literals
    When we need to declare a string with Unicode characters inside it requires more complex syntax

    PS> $str = "xyz$([char] 0xA)klm$([char]::ConvertFromUtf32(0x000abc

    [Working with Unicode scripts, blocks and categories in Powershell](https://www.serverbrain.org/system-administration/working-with-unicode-scripts-blocks-and-categories-in-powershell.html)
    - The last version is 8.0 and defines a code space of 1,114,112 code points in the range 0 hex to 10FFFF hex:
    (10FFFF)base16 = (1114111)base10
    - Each code point is referred to by writing "U+" followed by its hexadecimal number, where U stands for Unicode. So U+10FFFF is the code point for the last code point in the database

    # How to convert a glyph to a unicode code point
    PS> $char = 'X' ; [int][char]$char ; 
    PS> $char = '✅' ; [int][char]$char ; # ✅ 

    # How to convert a unicode code point to a glyph
    PS> [int][Convert]::ToInt32('0058', 16) ; [Convert]::ToChar([int][Convert]::ToInt32('0058', 16)) ; 
    # a loop to convert all the four digits long hex values of the Basic Multilingual Plane to their corresponding glyphs.
    PS> '0058','0389','221A','0040','9999','0033' | % { [Convert]::ToChar([int][Convert]::ToInt32($_, 16)) }
    X
    Ή
    √
    @
    香
    3

    # simpler way to get the same result, which relies on the implicit conversion performed by the compiler when numbers are prefixed by '0x':
    PS> 0x0058, 0x389, 0x221a, 0x0040, 0x9999, 0x0033 | % { [char]$_ }

    .PARAMETER  Value
    Unicode H+nnnn Code Point Literal array (e.g. U+0021)
    .INPUTS
    System.string Accepts piped input.
    .OUTPUTS
    System.double
    .EXAMPLE
    PS> 'U+0021','U+0783','U+2752' | convert-UnicodeUPlusToCharCode ; 
    Demo converting a single quota property of an Exchange mailbox, from dehydrated string format to double in megabytes.
    .LINK
    https://www.serverbrain.org/system-administration/working-with-unicode-scripts-blocks-and-categories-in-powershell.html
    https://mnaoumov.wordpress.com/2014/06/14/unicode-literals-in-powershell/
    https://unicode.org/emoji/charts/full-emoji-list.html
    #>
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding()]
    ## PSV3+ whatif support:[CmdletBinding(SupportsShouldProcess)]
    ###[Alias('Alias','Alias2')]
    PARAM(
        #[Parameter(ValueFromPipeline=$true)] # this will cause params to match on matching type, [array] input -> [array]$param
        #[Parameter(ValueFromPipelineByPropertyName=$true)] # this will cause params to 
            # match on type, but *also* must have _same param name_ (must be an inbound property 
            # named 'arrayVariable' to match the -arrayVariable param, and it must be an 
            # [array] type, for the initial match 
        # -- if you use both Pipeline & ByPropertyName, you'll get mixed results. 
        # -> if it breaks, strip back to ValueFromPipeline and ensure you have type matching on inbound object and typed parameter.
        # see Trace-Command use below, for t-shooting
        #On type matches: ```[array]$arrayVariable``` param will be matched with 
          #  inbound pipeline [array] type data, (and other type-to-type matching).  including 
          #  typed array variants like: ```[string[]]$stringArrayVariable``` 
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="HELPMSG[-PARAM SAMPLEINPUT]")]
            [ValidateNotNullOrEmpty()]
            [ValidatePattern("^U\+[0-9A-F]+$")]
            #[Alias('ALIAS1', 'ALIAS2')]
            [string]$Value
    ) ;
    BEGIN { 
        if ($PSCmdlet.MyInvocation.ExpectingInput) {
            $smsg = "Data received from pipeline input: '$($InputObject)'" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } else {
            # doesn't actually return an obj in the echo
            #$smsg = "Data received from parameter input: '$($InputObject)'" ;
            #if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            #else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ;
    }
    PROCESS{
        foreach($item in $value) {
            # works
            # [int][convert]::ToInt32('2752',16) ; [convert]::ToChar([int][convert]::ToInt32('2752',16))
            # $ucode.replace('0x','')

            $oReport = [ordered]@{
                CodePoint = $item ; 
                Hex = $null ; 
                Decimal = $null ; 
                DecimalToChar = $null ; 
                CodePointToChar = $null ; 
                Character = $null ; 
            } ; 
            #$inUPlus = $_ ; 
            $ucode = $item -replace 'U\+','0x' ; 
            $oReport.Hex = $ucode ; 
            #write-host "`n`n$item converted to Hex: $($ucode)" ; 
            #$deci = [int][convert]::ToInt32($ucode.replace('0x',''),16)  ; 
            $oReport.Decimal = [int][convert]::ToInt32($ucode.replace('0x',''),16) ; 
            $oReport.DecimalToChar = "[convert]::ToChar($($oReport.Decimal))" ; 
            $oReport.CodePointToChar = "[char]$($ucode)" ; 
            #write-host "$item converted to [int32]$($deci)" ; 
            #write-host "output as char: [convert]::ToChar($deci)`n or via [char]$($ucode)" ; 
            #[convert]::ToChar($deci) ; 
            $oReport.Character = [convert]::ToChar($($oReport.Decimal)) ; 
            [pscustomobject]$oReport | write-output ; 
        } ; 
    } ; 
}

#*------^ convert-UnicodeUPlusToCharCode.ps1 ^------


#*------v Get-CharInfo.ps1 v------
function Get-CharInfo {
    <#
    .SYNOPSIS
    Get-CharInfo.ps1 - Return basic information about supplied Unicode characters.
    .NOTES
    Version     : 0.0.
    Author      : JosefZ
    Website     : https://stackoverflow.com/users/3439404/josefz
    Twitter     : 
    CreatedDate : 2024-
    FileName    : Get-CharInfo.ps1
    License     : CC0 https://creativecommons.org/publicdomain/zero/1.0/legalcode
    Copyright   : (none asserted)
    Github      : https://github.com/tostka/verb-text
    Tags        : Powershell
    AddedCredit      : Todd Kadrie
    AddedWebsite     : http://www.toddomation.com
    AddedTwitter     : @tostka / http://twitter.com/tostka
    REVISIONS
    2:25 PM 6/21/2024 updated CBH, moved the type load into BEGIN{} of function (from outside of func)
        Improved by: https://stackoverflow.com/users/3439404/josefz
                    (to version 2)
    .DESCRIPTION
    Get-CharInfo.ps1 - Return basic information about supplied Unicode characters.

    Return information about supplied Unicode characters:
        - as a PSCustomObject for programming purposes,
        - in a human-readable form, and
        - with optional additional output to the Information Stream.

    Properties of the output PSCustomObject are as follows:

    Char        The character itself (if renderable)
    CodePoint   [string[]]Unicode CodePoint, its UTF-8 byte sequence
    Category    General Category (long name or abbreviation)
    Description Name (and surrogate pair in parentheses if apply).

    The UnicodeData.txt file (if used) must be saved locally
    from https://www.unicode.org/Public/UNIDATA/UnicodeData.txt
    (currently Unicode 13.0.0)

    The UnicodeData.txt file is not required however, in such case,
    Get-CharInfo function could be return inaccurate properties
    Category and Description for characters above BMP, see Example-3.
    HISTORY NOTES

    Origin by: http://poshcode.org/5234
                http://fossil.include-once.org/poshcode/artifact/5757dbbd0bc26c84333e7cf4ccc330ab89447bf679e86ddd6fbd3589ca24027e

    .PARAMETER  PARAMNAME

    .PARAMETER  PARAMNAME2

    .PARAMETER Ticket
    Ticket number[-ticket 123456]
    .PARAMETER Path
    Path [-path c:\path-to\]
    .PARAMETER File
    File [-file c:\path-to\file.ext]
    .PARAMETER TargetMailboxes
    HelpMessage="Mailbox email addresses(array)[-Targetmailboxes]
    .PARAMETER ResultSize
    Integer maximum number of results to request (for shortened debugging passes)
    .PARAMETER TenOrg
    Tenant Tag (3-letter abbrebiation)[-TenOrg 'XYZ']
    .PARAMETER Credential
    Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]
    .PARAMETER UserRole
    Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER Silent
    Switch to specify suppression of all but warn/error echos.(unimplemented, here for cross-compat)
    .PARAMETER showDebug
    Debugging Flag [-showDebug]
    .PARAMETER whatIf
    Whatif Flag  [-whatIf]
    .INPUTS
    An array of characters, strings and numbers (in any combination)
    can be piped to the function as parameter $InputObject, e.g as
    "ΧАB",[char]4301,191,0x1F3DE | Get-CharInfo
    or (the same in terms of decimal numbers) as
    935,1040,66,4301,191,127966 | Get-CharInfo

    On the other side, the $InputObject parameter supplied named
    or positionally must be of the only base type: either a number
    or a character or a string.
    The same input as a string:
    Get-CharInfo -InputObject 'ΧАBჍ¿🏞'

    -Verbose implies all -OutUni, -OutHex and -OutStr

    .OUTPUTS
    [System.Management.Automation.PSCustomObject]
    [Object[]]    (an array like [PSCustomObject[]])
    .EXAMPLE
    # full (first three lines are in the Information Stream)
    'r Ř👍'|Get-CharInfo -OutUni -OutHex -OutStr -IgnoreWhiteSpace

    r Ř👍
    0x0072,0x0020,0x0158,0x0001F44D
    \u0072\u0020\u0158\U0001F44D
        Char CodePoint                             Category Description                
        ---- ---------                             -------- -----------                
        r {U+0072, 0x72}                 LowercaseLetter Latin Small Letter R       
        Ř {U+0158, 0xC5,0x98}            UppercaseLetter Latin Capital Letter R W...
        👍 {U+1F44D, 0xF0,0x9F,0x91,0x8D}              So THUMBS UP SIGN (0xd83d,0...


    .EXAMPLE
    # shortened version of above (output is the same)
    'r Ř👍'|chr -Verbose -IgnoreWhiteSpace

    .EXAMPLE
    # inaccurate (inexact) output above BMP if missing UnicodeData.txt
    'r Ř👍'|chr -Verbose -IgnoreWhiteSpace -UnicodeData .\foo.bar

    r Ř👍
    0x0072,0x0020,0x0158,0x0001F44D
    \u0072\u0020\u0158\U0001F44D
        Char CodePoint                             Category Description                
        ---- ---------                             -------- -----------                
        r {U+0072, 0x72}                 LowercaseLetter Latin Small Letter R       
        Ř {U+0158, 0xC5,0x98}            UppercaseLetter Latin Capital Letter R W...
        👍 {U+1F44D, 0xF0,0x9F,0x91,0x8D}     OtherSymbol ??? (0xd83d,0xdc4d)        

    .LINK
    https://stackoverflow.com/questions/65748858/how-to-display-unicode-character-names-and-their-hexadecimal-codes-with-powershe
    .LINK
    Unicode® Standard Annex #44: Unicode Character Database (UCD)
    .LINK
    https://www.unicode.org/reports/tr44/
    .LINK
    https://www.unicode.org/reports/tr44/#General_Category_Values
    .LINK
    https://github.com/tostka/verb-text
    .FUNCTIONALITY
    Tested: Windows 8.1/64bit, Powershell 4
            Windows 10 /64bit, Powershell 5
            Windows 10 /64bit, Powershell Core 6.2.0
            Windows 10 /64bit, Powershell Core 7.1.0
    #>
    [CmdletBinding()]
    [Alias('chr')]
    [OutputType([System.Management.Automation.PSCustomObject],
                [System.Array])]
    PARAM(
        # named or positional: a string or a number e.g. 'r Ř👍'
        # pipeline: an array of strings and numbers, e.g 'r Ř',0x1f44d
        [Parameter(Position=0, Mandatory, ValueFromPipeline,HelpMessage="a string or a number['r Ř👍']")]
            $InputObject,
        # + Write-Host Python-like Unicode literal e.g. \u0072\u0020\u0158\U0001F44D
        [Parameter(HelpMessage="Switch to output Python-like Unicode literal e.g. \u0072\u0020\u0158\U0001F44D")]
            [switch]$OutUni,
        # + Write-Host array of hexadecimals e.g. 0x0072,0x0020,0x0158,0x0001F44D
        [Parameter(HelpMessage="Switch to output array of hexadecimals e.g. 0x0072,0x0020,0x0158,0x0001F44D")]
            [switch]$OutHex,
        # + Write-Host concatenated string e.g. r Ř👍
        [Parameter(HelpMessage="Switch to output concatenated string e.g. r Ř👍")]
            [switch]$OutStr,
        # choke down whitespaces ( $s -match '\s' ) from output
        [Parameter(HelpMessage="Switch to choke down whitespaces ( `$s -match '\s' ) from output")]
            [switch]$IgnoreWhiteSpace,
        # from https://www.unicode.org/Public/UNIDATA/UnicodeData.txt
        [Parameter(HelpMessage="Optional Path to local downloaded copy of https://www.unicode.org/Public/UNIDATA/UnicodeData.txt (improves info accuracy)[-UnicodeData c:\pathto\UnicodeData.txt")]
            [string]$UnicodeData = 'c:\usr\work\ps\scripts\CodePages\UnicodeData.txt'
    )
    BEGIN {
        if ( -not ('Microsofts.CharMap.UName' -as [type]) ) {
          Add-Type -Name UName -Namespace Microsofts.CharMap -MemberDefinition $(
            switch ("$([System.Environment]::SystemDirectory -replace 
                        '\\', '\\')\\getuname.dll") {
            {Test-Path -LiteralPath $_ -PathType Leaf} {@"
[DllImport("${_}", ExactSpelling=true, SetLastError=true)]
private static extern int GetUName(ushort wCharCode, 
    [MarshalAs(UnmanagedType.LPWStr)] System.Text.StringBuilder buf);

public static string Get(char ch) {
    var sb = new System.Text.StringBuilder(300);
    UName.GetUName(ch, sb);
    return sb.ToString();
}
"@
            }
            default {'public static string Get(char ch) { return "???"; }'}
            })
        }    
        Set-StrictMode -Version latest
        if ( [string]::IsNullOrEmpty( $UnicodeData) ) { $UnicodeData = '::' }
        Function ReadUnicodeRanges {
            if ($Script:UnicodeFirstLast.Count -eq 0) {
                $Script:UnicodeFirstLast = @'
                    First,Last,Category,Description
                    128,128,Cc-Control,Padding Character
                    129,129,Cc-Control,High Octet Preset
                    132,132,Cc-Control,Index
                    153,153,Cc-Control,Single Graphic Character Introducer
                    13312,19903,Lo-Other_Letter,CJK Ideograph Extension A
                    19968,40956,Lo-Other_Letter,CJK Ideograph
                    44032,55203,Lo-Other_Letter,Hangul Syllable
                    94208,100343,Lo-Other_Letter,Tangut Ideograph
                    101632,101640,Lo-Other_Letter,Tangut Ideograph Supplement
                    131072,173789,Lo-Other_Letter,CJK Ideograph Extension B
                    173824,177972,Lo-Other_Letter,CJK Ideograph Extension C
                    177984,178205,Lo-Other_Letter,CJK Ideograph Extension D
                    178208,183969,Lo-Other_Letter,CJK Ideograph Extension E
                    183984,191456,Lo-Other_Letter,CJK Ideograph Extension F
                    196608,201546,Lo-Other_Letter,CJK Ideograph Extension G
                    983040,1048573,Co-Private_Use,Plane 15 Private Use
                    1048576,1114109,Co-Private_Use,Plane 16 Private Use
'@ | ConvertFrom-Csv -Delimiter ',' |
                ForEach-Object {
                    [PSCustomObject]@{
                        First      = [int]$_.First
                        Last       = [int]$_.Last
                        Category   = $_.Category
                        Description= $_.Description
                    }
                }
            }
            foreach ( $FirstLast in $Script:UnicodeFirstLast) {
                if ( $FirstLast.First -le $ch -and $ch -le $FirstLast.Last ) {
                    $out.Category = $FirstLast.Category
                    $out.Description = $FirstLast.Description + $nil
                    break
                }
            }
        }
        $AuxHex = [System.Collections.ArrayList]::new()
        $AuxStr = [System.Collections.ArrayList]::new()
        $AuxUni = [System.Collections.ArrayList]::new()
        $Script:UnicodeFirstLast = @()
        $Script:UnicodeDataLines = @()
        function ReadUnicodeData {
            if ( $Script:UnicodeDataLines.Count -eq 0 -and (Test-Path $UnicodeData) ) {
                 $Script:UnicodeDataLines = @([System.IO.File]::ReadAllLines(
                        $UnicodeData, [System.Text.Encoding]::UTF8))
            }
            $DescrLine = $Script:UnicodeDataLines -match ('^{0:X4}\;' -f $ch)
            if ( $DescrLine.Count -gt 0) {
                $u0, $Descr, $Categ, $u3 = $DescrLine[0] -split ';'
                $out.Category = $Categ
                $out.Description = $Descr + $nil
            }
        }
        function out {
            param(
                [Parameter(Position=0, Mandatory=$true )] $ch,
                [Parameter(Position=1, Mandatory=$false)]$nil=''
                 )
            if (0 -le $ch -and 0xFFFF -ge $ch) {
                [void]$AuxHex.Add('0x{0:X4}' -f $ch)
                $s = [char]$ch
                [void]$AuxStr.Add($s)
                [void]$AuxUni.Add('\u{0:X4}' -f $ch)
                $out = [pscustomobject]@{
                    Char      = $s
                    CodePoint = ('U+{0:X4}' -f $ch),
                        (([System.Text.UTF32Encoding]::UTF8.GetBytes($s) |
                            ForEach-Object { '0x{0:X2}' -f $_ }) -join ',')
                    Category  = [System.Globalization.CharUnicodeInfo]::GetUnicodeCategory($ch)
                    Description = [Microsofts.CharMap.UName]::Get($ch)
                }
                if ( $out.Description -eq 'Undefined' ) { ReadUnicodeRanges }
                if ( $out.Description -eq 'Undefined' ) { ReadUnicodeData }
            } elseif (0x10000 -le $ch -and 0x10FFFF -ge $ch) {
                [void]$AuxHex.Add('0x{0:X8}' -f $ch)
                $s = [char]::ConvertFromUtf32($ch)
                [void]$AuxStr.Add($s)
                [void]$AuxUni.Add('\U{0:X8}' -f $ch)
                $out = [pscustomobject]@{
                    Char        = $s
                    CodePoint   = ('U+{0:X}' -f $ch),
                        (([System.Text.UTF32Encoding]::UTF8.GetBytes($s) |
                            ForEach-Object { '0x{0:X2}' -f $_ }) -join ',')
                    Category    = [System.Globalization.CharUnicodeInfo]::GetUnicodeCategory($s, 0)
                    Description = '???' + $nil
                }
                ReadUnicodeRanges 
                if ( $out.Description -eq ('???' + $nil) ) { ReadUnicodeData }
            } else {
                Write-Warning ('Character U+{0:X4} is out of range' -f $ch)
                $s = $null
            }
            if (( $null -eq $s ) -or
                ( $IgnoreWhiteSpace.IsPresent -and ( $s -match '\s' ))
               ) {
            } else {
                $out
            }
        }
    }
    PROCESS {
        #if ($PSBoundParameters['Verbose']) {
        #    Write-Warning "InputObject $InputObject, type = $($InputObject.GetType().Name)"
        #}
        if ( ($InputObject -as [int]) -gt 0xFFFF -and 
             ($InputObject -as [int]) -le 0x10ffff ) {
            $InputObject = [string][char]::ConvertFromUtf32($InputObject)
        }
        if ($null -cne ($InputObject -as [char])) {
            #Write-Verbose "A $([char]$InputObject) InputObject character"
            out $([int][char]$InputObject) ''
        } elseif (  $InputObject -isnot [string] -and 
                    $null -cne ($InputObject -as [int])) {
            #Write-Verbose "B $InputObject InputObject"
            out $([int]$InputObject) ''
        } else {
            $InputObject = [string]$InputObject
            #Write-Verbose "C $InputObject InputObject.Length $($InputObject.Length)"
            for ($i = 0; $i -lt $InputObject.Length; ++$i) {
                if (  [char]::IsHighSurrogate($InputObject[$i]) -and 
                      (1+$i) -lt $InputObject.Length -and 
                      [char]::IsLowSurrogate($InputObject[$i+1])) {
                    $aux = ' (0x{0:x4},0x{1:x4})' -f [int]$InputObject[$i], 
                                                   [int]$InputObject[$i+1]
                    # Write-Verbose "surrogate pair $aux at position $i" 
                    out $([char]::ConvertToUtf32($InputObject[$i], $InputObject[1+$i])) $aux
                    $i++
                } else {
                    out $([int][char]$InputObject[$i]) ''
                }
            }
        }
    }
    END {
        if ( $OutStr.IsPresent -or $PSBoundParameters['Verbose']) {
            Write-Host -ForegroundColor Magenta -Object $($AuxStr -join '')
        }
        if ( $OutHex.IsPresent -or $PSBoundParameters['Verbose']) {
            Write-Host -ForegroundColor Cyan -Object $($AuxHex -join ',')
        }
        if ( $OutUni.IsPresent -or $PSBoundParameters['Verbose']) {
            Write-Host -ForegroundColor Yellow -Object $($AuxUni -join '')
        }
    }

}

#*------^ Get-CharInfo.ps1 ^------


#*------v get-StringHash.ps1 v------
function get-StringHash {
        <#
        .SYNOPSIS
        get-StringHash.ps1 - Convert specifed string to designated Cryptographic Hash string (SHA1|SHA256|SHA384|SHA512|MACTripleDES|MD5|RIPEMD160)
        .NOTES
        Version     : 1.0.0
        Author      : Todd Kadrie
        Website     :	http://www.toddomation.com
        Twitter     :	@tostka / http://twitter.com/tostka
        CreatedDate : 2020-
        FileName    : 
        License     : MIT License
        Copyright   : (c) 2020 Todd Kadrie
        Github      : https://github.com/tostka
        Tags        : Powershell
        AddedCredit : Bryan Dady
        AddedWebsite:	https://www.powershellgallery.com/packages/PSLogger/1.4.3/Content/GetStringHash.psm1
        REVISIONS
        * 2:22 PM 8/21/2024 add: alias: convertto-StringHash
        * 11:42 AM 11/22/2021 fixed CBH, missing desc to comply w pester
        * 11:59 AM 4/17/2020 updated CBH, moved from incl-servercore to verb-text
        * 9:46 PM 9/1/2019 updated, added Algorithm param, added pshelp
        * 1/21/11 posted version
        .DESCRIPTION
        get-StringHash.ps1 - Convert specifed string to designated Cryptographic Hash string (SHA1|SHA256|SHA384|SHA512|MACTripleDES|MD5|RIPEMD160)
        Hybrid of work by Ivovan & Bryan Dady
        .PARAMETER  String
        Specify string to be hashed. Accepts from pipeline
        .PARAMETER  Algorithm
        Hashing Algorithm (SHA1|SHA256|SHA384|SHA512|MACTripleDES|MD5|RIPEMD160) -Algorithm MD5
        .EXAMPLE
        $env:username | get-StringHash -Algorithm md5 ;
        .LINK
        https://www.powershellgallery.com/packages/PSLogger/1.4.3/Content/GetStringHash.psm1
        #>
        [Alias('convertto-StringHash')]
        PARAM (
            [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = 'Specify string to be hashed. Accepts from pipeline.')]
            [alias('text', 'InputObject')]
            [ValidateNotNullOrEmpty()]
            [string]$String,
            [Parameter(Mandatory = $false, Position = 1, ValueFromPipeline = $false, ValueFromPipelineByPropertyName = $false, HelpMessage = "Hashing Algorithm (SHA1|SHA256|SHA384|SHA512|MACTripleDES|MD5|RIPEMD160) -Algorithm MD5")]
            [alias('HashName')]
            [ValidateSet('SHA1', 'SHA256', 'SHA384', 'SHA512', 'MACTripleDES', 'MD5', 'RIPEMD160')]
            [string]$Algorithm = 'SHA256'
        ) ;
        $StringBuilder = New-Object -TypeName System.Text.StringBuilder ;
        [System.Security.Cryptography.HashAlgorithm]::Create($Algorithm).ComputeHash([System.Text.Encoding]::UTF8.GetBytes($String)) | ForEach-Object -Process { [Void]$StringBuilder.Append($_.ToString('x2')) } ;
        #'Optimize New-Object invocation, based on Don Jones' recommendation: https://technet.microsoft.com/en-us/magazine/hh750381.aspx
        $Private:properties = @{
            'Algorithm' = $Algorithm ;
            'Hash'      = $StringBuilder.ToString()  ;
            'String'    = $String ;
        } ;
        $Private:RetObject = New-Object -TypeName PSObject -Prop $properties | Sort-Object ;
        return $RetObject  ;
    }

#*------^ get-StringHash.ps1 ^------


#*------v new-LoremString.ps1 v------
function new-LoremString {
    <#
    .SYNOPSIS
    new-LoremString - Creates a new Lorem Ipsum string with the specified characteristics. 
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2016-04-04
    FileName    : new-LoremString.ps1
    License     : (Non asserted)
    Copyright   : (Non asserted)
    Github      : https://github.com/tostka/verb-TEXT
    Tags        : Powershell
    AddedCredit : Adam Driscoll
    AddedWebsite: https://www.powershellgallery.com/packages/LoremIpsum/1.0
    AddedTwitter: @adamdriscoll
    REVISIONS
    * 4:19 PM 9/11/2024 added trim() to wrap-text outputs (tends to have a leading space)
    * 1:25 PM 6/1/2023 fixed param $AltLexicon; wrapped in @() forced array.
    * 12:47 PM 5/4/2023 Took AD's basic idea (stringbuilder assembly on looping 
        array), and reworked the logic, primarily to require less inputs to get 
        any output; defaulted some params, coereced others around inputs, expanded 
        CBH, filled out param specs, added trailing explicit write-output; added 
        verbose outputs; dbl CR between paras; Capped 1st char of ea Sentance; 
        added -AltLexicon & -NoLorem params; range of extra CBH examples.
    * 4/4/16 AD's posted PSG vers 1.0 
    .DESCRIPTION
    new-LoremString - Creates a new Lorem Ipsum string with the specified characteristics. 
    
    By default, without parameters, outputs a six-word random Lorem-based sentance.

    The -AltLexicon parameter is prestocked with 100 words from Google's [100 Random Words - This Site Is Totally Random - Google Sites](https://sites.google.com/site/thissiteistotallyrandom/100-random-words)
    and are used as the word source with the -NoLorem parameter. 
    This parameter can also be specified on the command line with a custom string array of other words.

    .PARAMETER minWords
    Min number of words to be returned (defaults to 6)[-minwords 5]
    .PARAMETER maxWords
    Max number of words to be returned[-maxwords 7]
    .PARAMETER minSentences
    Min number of sentances to be returned(defaults to 1)[-minSentences 1]
    .PARAMETER maxSentences
    Max number of sentances to be returned[-maxSentences 3]
    .PARAMETER numParagraphs
    Number of paragraphs to be returned(defaults to 1)[-numParagraphs 2]
    .PARAMETER NoLorem
    Switch to use non-Lorem-based words (random 100 words)[-NoLorem]
    .PARAMETER AltLexicon
    String array of random words to use with -NoLorem switch (prepopulated with 100 random words from https://sites.google.com/site/thissiteistotallyrandom/100-random-words)[-AltLexicon 'word1','word2']
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    System.String
    .EXAMPLE
    PS> new-loremstring -minWords 12 ;

        Dolore erat elit diam nonummy dolore ipsum laoreet elit diam laoreet tincidunt. 

    Output a single 12 word sentance. 
    .EXAMPLE
    PS> new-loremstring -minWords 15 -NoLorem ;

        Prison juice moon frog computer flying hyperlink element cords mediocre moon zebra home cords final. 

    Output a single 15 word sentance using the alt non-Lorem-text-based word list
    
    .EXAMPLE
    PS> new-loremstring -minWords 4 -maxWords 8 -minSentences 3 -maxSentences 5 -numParagraphs 2 ; 

        Elit consectetuer elit magna. Euismod ut consectetuer ut. Sit elit elit ut. 

        Elit aliquam ut elit. Erat tincidunt nibh euismod. Elit nibh nibh nibh. 

    Generate two random paragraphs of 3-5 sentances with 4-8 word each.
    .EXAMPLE
    PS> (new-loremstring -minWords 4 -maxWords 13 -minSentences 3 -maxSentences 12 -numParagraphs 2 | wrap-text -Characters 80).trim() ;

        Ut erat magna dolor amet magna ipsum erat. Nonummy laoreet nonummy diam erat
        lorem ipsum adipiscing. Ut nibh amet sed euismod magna diam nibh. Ut euismod
        elit laoreet adipiscing dolor ipsum aliquam. Ipsum dolor elit euismod diam
        adipiscing ut dolor. Laoreet laoreet diam aliquam euismod sit nibh laoreet.
        Laoreet sit euismod tincidunt dolore dolor amet dolor. 

        Diam ut laoreet dolor
        sit nonummy tincidunt tincidunt. Nonummy sed laoreet ut aliquam magna diam nibh.
        Sit aliquam magna ipsum euismod erat nibh aliquam. Dolore consectetuer tincidunt
        dolore dolore elit ut elit. Sit elit euismod erat nibh dolore ipsum dolore. Ut
        sit tincidunt ipsum nibh sed dolore ut. Lorem diam aliquam dolor ipsum ipsum sit
        amet. 

    Longer example piped through my verb-Text:wrap-text() to produce wrapped text output:
    .EXAMPLE
    PS> (new-loremstring -minWords 6).replace(' ','').substring(0,15) ; 
        
        Elitnonummyelit

    Demo generation of a 16-character semi-random lorem-based string, with all spaces removed (for dummy values & inputs).
    .EXAMPLE
    PS> ((new-loremstring -minWords 6) | convertto-titlecase).replace(' ','').substring(0,15)

        LaoreetIpsumDol

    Variant demo that uses my verb-text:convertto-TitleCase to titlecase each word before removing spaces, and truncating to 16 characters.
    .EXAMPLE
    $block = @() ; 
    $block = new-loremstring -minwords 6 | convertto-titlecase ; 
    $block += "`n`r" ; 
    $block += new-loremstring -minWords 4 -maxWords 13 -minSentences 3 -maxSentences 12 -numParagraphs 2 ;
    ($block | wrap-text -char 80).trim() ; 
    Demo building a mixed case 'post' with title of dummy text, word wrapped. Uses my verb-Text module convertTo-Titlecase. 
    .LINK
    https://github.com/tostka/verb-text
    #>
    [CmdletBinding()]
    PARAM(
        [Parameter(HelpMessage="Min number of words to be returned (defaults to 6)[-minwords 5]")]
            [int]$minWords = 6, 
        [Parameter(HelpMessage="Max number of words to be returned[-maxwords 7]")]
            [int]$maxWords, 
        [Parameter(HelpMessage="Min number of sentances to be returned(defaults to 1)[-minSentences 1]")]
            [int]$minSentences = 1, 
        [Parameter(HelpMessage="Max number of sentances to be returned[-maxSentences 3]")]
            [int]$maxSentences, 
        [Parameter(HelpMessage="Number of paragraphs to be returned(defaults to 1)[-numParagraphs 2]")]
            [int]$numParagraphs = 1,
        [Parameter(HelpMessage="Switch to use non-Lorem-based words (random 100 words)[-NoLorem]")]
            [switch]$NoLorem, 
        [Parameter(HelpMessage="String Array of random words to use with -NoLorem switch (prepopulated with 100 random words from https://sites.google.com/site/thissiteistotallyrandom/100-random-words)[-AltLexicon 'word1','word2']")]
            [string[]]$AltLexicon = @('sausage','blubber','pencil','cloud','moon','water','computer','school','network','hammer','walking','violently','mediocre','literature','chair','two','window','cords','musical','zebra','xylophone','penguin','home','dog','final','ink','teacher','fun','website','banana','uncle','softly','mega','ten','awesome','attatch','blue','internet','bottle','tight','zone','tomato','prison','hydro','cleaning','telivision','send','frog','cup','book','zooming','falling','evily','gamer','lid','juice','moniter','captain','bonding','loudly','thudding','guitar','shaving','hair','soccer','water','racket','table','late','media','desktop','flipper','club','flying','smooth','monster','purple','guardian','bold','hyperlink','presentation','world','national','comment','element','magic','lion','sand','crust','toast','jam','hunter','forest','foraging','silently','tawesomated','joshing','pong')
    ) ;
    $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
    write-verbose "`$PSBoundParameters:`n$(($PSBoundParameters|out-string).trim())" ;

    $lex = "lorem;ipsum;dolor;sit;amet;consectetuer;adipiscing;elit;sed;diam;nonummy;nibh;euismod;tincidunt;ut;laoreet;dolore;magna;aliquam;erat".split(';') ;
    # seed this with a fresh random list from: https://sites.google.com/site/thissiteistotallyrandom/100-random-words

    if(-not $NoLorem){ $words = $lex } 
    else {
        write-host "(using non-Lorum 100-word seed list)" ; 
        $words = $AltLexicon ;
    } ; 

    if (($minWords -AND ($maxWords -gt 0)) -AND ($minWords -gt $maxWords)){
        throw "MinWords cannot be greater than MaxWords." ; 
    }
    if (($minSentences -AND ($maxSentences -gt 0)) -AND ($minSentences -gt $maxSentences)){
        throw "MinSentences cannot be greater than MaxSentences." ; 
    }

    if($minWords -gt 0 -AND $maxWords -eq 0){
        $numWords = $minWords
    } elseif($minWords -gt 0 -AND ($maxWords -gt 0)) {    
        $pltGRWord = @{
            Minimum = $minWords ; 
            Maximum = $maxWords
        } ; 
    } ;
    if($minSentences -gt 0 -AND $maxSentences -eq 0){
        $numSentences = $minSentences  ; 
    } elseif($minSentences -gt 0 -AND ($maxSentences -gt 0)) {    
        $pltGRSent = @{
            Minimum = $minSentences ; 
            Maximum = $maxSentences
        } ; 
    } ; 
    
    if($numWords -eq $null -and ( ($pltGRWord.keys).count -ge 2)){
        write-verbose "get-Random [words] w`n$(($pltGRWord|out-string).trim())" ; 
        $numWords = Get-Random @pltGRWord ; 
    } ; 
    
    if($numSentences -eq $null -and ( ($pltGRSent.keys).count -ge 2)){
        write-verbose "get-Random [sentances] w`n$(($pltGRSent|out-string).trim())" ; 
        $numSentences = Get-Random @pltGRSent ; 
    } ; 
    
    $smsg = "numWords:$($numWords)" ; 
    $smsg += "`nnumSentences:$($numSentences)" ; 
    $smsg += "`nnumParagraphs:$($numParagraphs)" ; 
    write-verbose $smsg ; 

    $result = New-Object System.Text.StringBuilder ; 
    for($p = 0; $p -lt $numParagraphs; $p++) {
        for($s = 0; $s -lt $numSentences; $s++) {
            for($w = 0; $w -lt $numWords; $w++) {
                if ($w -gt 0) { $result.Append(" ") | Out-Null }
                if($w -eq 0){
                    $word = $words[(Get-Random -Minimum 0 -Maximum $words.Length)]
                    $result.Append( $word.substring(0,1).toupper() + $word.substring(1).tolower() ) | Out-Null ;
                } else { 
                    $result.Append($words[(Get-Random -Minimum 0 -Maximum $words.Length)]) | Out-Null ; 
                } ; 
            } ; 
            $result.Append(". ") | Out-Null ; 
        } ; 
        $result.Append("`r`n`r`n") | Out-Null ; 
    } ; 
    $result.ToString() | write-output ; 
}

#*------^ new-LoremString.ps1 ^------


#*------v Remove-StringDiacritic.ps1 v------
function Remove-StringDiacritic {
    <#
    .SYNOPSIS
    Remove-StringDiacritic() - This function will remove the diacritics (accents) characters from a string.unaccented characters.
    .NOTES
    Version     : 1.0.0
    Author      : Francois-Xavier Cat
    Website     :	github.com/lazywinadmin, www.lazywinadmin.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2019-3-22
    FileName    : Remove-StringDiacritic.ps1
    License     : (none-specified)
    Copyright   : (none-specified)
    Github      : https://github.com/tostka
    Tags        : Powershell,Text,String,ForeignLanguage,Language
    REVISIONS
    * 3:42 PM 9/23/2024 added regex pretest example
    * 10:54 AM 1/17/2023 # psv2 bug: $psitem isn't supported, need to use $_
    * 1:50 PM 11/22/2021 added param pipeline support & hepmessage on params
    * Mar 22, 2019, init
    .DESCRIPTION
    Remove-StringDiacritic() - This function will remove the diacritics (accents) characters from a string.unaccented characters.
    
    Note verb-text\converTo-CleanString() wraps this and Remove-StringLatinCharacters (pipeline passthrough)
    .PARAMETER String ;
    Specifies the String(s) on which the diacritics need to be removed ;
    .PARAMETER NormalizationForm ;
    Specifies the normalization form to use ;
    https://msdn.microsoft.com/en-us/library/system.text.normalizationform(v=vs.110).aspx
    .EXAMPLE
    PS C:\> Remove-StringDiacritic "L'�t� de Rapha�l" ;
    L'ete de Raphael ;
    .EXAMPLE
    write-verbose "Note: Clipboard tends to paste latin cyrillics as western charcters (removes diacritical from 'ę', pastes as 'e'), so pull from clipboard into a variable for processing, to ensure we're converting the raw latin characters with the functions" ;
    PS> $in = get-clipboard ;
    PS> write-host "'$($in)'" ;
    PS> [regex]$rgxAccentedNameChars = "[^a-zA-Z0-9\s\.\(\)\{\}\/\&\$\#\@\,\`"\'\’\:\–_-]" ; 
    PS> if($in -match $rgxAccentedNameChars){
    PS> 	$clean = $in |ConvertTo-CleanString ;
    PS> 	write-host "'$($clean)'" ;
    PS> } else {write-host "already clean raw text:$(in)" } ; 
    Demo pipeline conversion, sourced from clipboard (rather than pasted text string), avoids autoconversion performed on paste to console, by Powershell.
    .LINK
    https://lazywinadmin.com/2015/05/powershell-remove-diacritics-accents.html
    #>
    [CMdletBinding()]
    PARAM (
      [Parameter(Mandatory = $true,Position = 0,ValueFromPipeline = $true,ValueFromPipelineByPropertyName = $true, HelpMessage = 'Specifies the String(s) on which the diacritics need to be removed')]
      [ValidateNotNullOrEmpty()][Alias('Text')]
      [System.String[]]$String,
      [Parameter(HelpMessage = 'optional the normalization form to use (defaults to FormD)')]
      [System.Text.NormalizationForm]$NormalizationForm = "FormD"
    ) ;
    foreach ($StringValue in $String) {
        Write-Verbose -Message "$StringValue"
        try {
            # Normalize the String
            $Normalized = $StringValue.Normalize($NormalizationForm) ;
            $NewString = New-Object -TypeName System.Text.StringBuilder
            # Convert the String to CharArray
            $normalized.ToCharArray() |
            ForEach-Object -Process {
                if ([Globalization.CharUnicodeInfo]::GetUnicodeCategory($_) -ne [Globalization.UnicodeCategory]::NonSpacingMark) {
                    [void]$NewString.Append($_) ;
                } ;
            } ;
            #Combine the new string chars
            Write-Output $($NewString -as [string]) ;
        } Catch {
            Write-Error -Message $Error[0].Exception.Message
        } ;
    } ;
}

#*------^ Remove-StringDiacritic.ps1 ^------


#*------v Remove-StringLatinCharacters.ps1 v------
function Remove-StringLatinCharacters {
<#
    .SYNOPSIS
    Remove-StringLatinCharacters() - Substitute Cyrillic characters into normal unaccented characters. Addon to Remove-Stringdiacriic, converts untouched Polish crossed-L to L. But doesn't proper change some german chars (rplcs german est-set with ? -> do Remove-StringDiacritic first, and it won't damage german).
   .NOTES
    Version     : 1.0.1
    Author: Marcin Krzanowicz
    Website:	https://lazywinadmin.com/2015/05/powershell-remove-diacritics-accents.html#
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2019-3-22
    FileName    : Remove-StringDiacritic.ps1
    License     : (none-specified)
    Copyright   : (none-specified)
    Github      : https://github.com/tostka
    Tags        : Powershell,Text,String,ForeignLanguage,Language
    REVISIONS   :
    * 3:42 PM 9/23/2024 added regex pretest example
    * 1:53 PM 11/22/2021 added param pipeline support
    * May 21, 2015 posted version
    .DESCRIPTION
    Remove-StringLatinCharacters() - Substitute Cyrillic characters into normal unaccented characters. Addon to Remove-Stringdiacriic, converts untouched Polish crossed-L to L. But doesn't proper change some german chars (rplcs german est-set with ? -> do Remove-StringDiacritic first, and it won't damage german).
    
    Note verb-text\converTo-CleanString() wraps this and Remove-StringDiacritic (pipeline passthrough)
    .PARAMETER String ;
    Specifies the String(s) on which the latin chars need to be removed ;
    .EXAMPLE
    Remove-StringLatinCharacters -string "string" ;
    Substitute normal unaccented chars for cyrillic chars in the string specified
    .EXAMPLE
    write-verbose "Note: Clipboard tends to paste latin cyrillics as western charcters (removes diacritical from 'ę', pastes as 'e'), so pull from clipboard into a variable for processing, to ensure we're converting the raw latin characters with the functions" ;
    PS> $in = get-clipboard ;
    PS> write-host "'$($in)'" ;
    PS> [regex]$rgxAccentedNameChars = "[^a-zA-Z0-9\s\.\(\)\{\}\/\&\$\#\@\,\`"\'\’\:\–_-]" ; 
    PS> if($in -match $rgxAccentedNameChars){
    PS> 	$clean = $in | Remove-StringLatinCharacters ;
    PS> 	write-host "'$($clean)'" ;
    PS> } else {write-host "already clean raw text:$(in)" } ; 
    Demo pipeline conversion, sourced from clipboard (rather than pasted text string), avoids autoconversion performed on paste to console, by Powershell.
    .LINK
    https://lazywinadmin.com/2015/05/powershell-remove-diacritics-accents.html
    #>
    [CMdletBinding()]
    PARAM (
        [Parameter(Mandatory = $true,Position = 0,ValueFromPipeline = $true,ValueFromPipelineByPropertyName = $true, HelpMessage = 'Specifies the String(s) on which the latin chars need to be removed ')]
        [ValidateNotNullOrEmpty()]
        [Alias('Text')]
        [System.String[]]$String
    ) ;
    [Text.Encoding]::ASCII.GetString([Text.Encoding]::GetEncoding("Cyrillic").GetBytes($String)) ;
}

#*------^ Remove-StringLatinCharacters.ps1 ^------


#*------v resolve-user.ps1 v------
function resolve-user {
    <#
    .SYNOPSIS
    resolve-user.ps1 - Resolve specified array of -users (displayname, emailaddress, samaccountname) to mail asset, lic & ticket descriptors
    .NOTES
    Version     : 1.0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-07-13
    FileName    : resolve-user.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 12:06 PM 9/23/2024 added param for regex to detect non-raw text names; ahdd running $usr input through Remove-StringDiacritic & Remove-StringLatinCharacters() ; 
    * 2:16 PM 6/24/2024: rem'd out #Requires -RunasAdministrator; sec chgs in last x mos wrecked RAA detection
    * 4:28 PM 2/27/2024 updated path-detect code (was discovering into the Mods dir);  updated CBH, quota mbx size, LegalHold example; add additional reporting/detecting to LegalHold status; fixed borked/non-dumping $prpMbxHold = ...@{n="InPlaceHolds";e={ ($_.inplaceholds (*KEY* indicator of a hold in place); updated prompts to echo DiscoveryHolds folder & it's newestItem (both indicate LHs, and if not curr, when it was disabled)
    * 2:51 PM 2/26/2024 add | sort version | select -last 1  on gmos, LF installed 3.4.0 parallel to 3.1.0 and broke auth: caused mult versions to come back and conflict with the assignement of [version] type (would require [version[]] to accom both, and then you get to code everything for mult handling)
    * 12:22 PM 9/26/2023 nesting limit loop, pulled vxo & vx2010  reqs
    * 3:59 PM 9/25/2023 working, ready to drop back into vxo finished in-port of get-xoMailboxQuotaStatus support, now functional, also expanded the mbxstat filter to cover room|shared|Equip recipienttypedetails variants; 
        appears I spliced over $getQuotaUsage support from get-xoMailboxQuotaStatus, looks like it needs to be debugged.
    * 12:43 PM 9/18/2023 re-removed the obsolete xow support: EOM31+ doesn't need it.
    * 3:47 PM 12/14/2022 spliced in xow support. Works on initial pass.
    # 3:57 PM 6/29/2022 fundemental retool for exov2 requirements; pulled all 
        aliasing (wasn't functional for exov2, didn't want to rewrite, and with hard 
        mfa req, exov2 is only way forward, there'll never be verb-EXOnoun use again, 
        due to MS fundemental seizure of the prefix for their 13 'special' cmdlets. 
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    * 3:55 PM 2/22/2022 extended the cloud federate test code, to include an INT block (though there's no hybrid to arbitrate, the users are onprem in AD at INT)
    * 12:24 PM 2/1/2022 updated CBH, added a crlf on the console echo (headers weren't lining up); added -getMobile & get-exoMobileDeviceStats support, with conditional md output block; added full aliased xo cmds, implementing full -exov2 support.
    * 2:51 PM 12/27/2021 flipped DN & Desc from md tbl to fl (drops a crlf) ; 
         flipped $propsMailx output to md fmt split lines (condensed output vertically) ; 
         added forward props to propsMailx, and test & echo to tag forwarded mbxs; wrapped $prop* vari's for legibility
    * 11:02 AM 12/13/2021 #11111:had $hsum IsADDisabled, typo: to IsAADDisabled
    * 2:40 PM 12/10/2021 more cleanup ; added $hsum.isDirSynced, for further bulk filter/profiling
        flipped $hsum.isUnlicensed -> Islicensed & added msol.Islicensed test to pop ; 
        appears to work in console - output a stack of filterable objects into collection variable.
        further tweaking and nobrain t-shooting outputs ; added 
        output switches: 
        isNoBrain,isSplitBrain,isUnlicensed,IsDisabledOU,IsADDisabled,IsAADDisabled for 
        postfiltering large collections in bulk, to identify patterns ; reformulated 
        nobrain detec, to have an unlic'd block as well as a licensed - with deadwood 
        offboard nobrains, they'll never have a lic. 
    * 4:19 PM 12/9/2021 improved pipeline support; fixed pipeline param mbinding fails ; added supoort for resolving
        baddomain users or op.mailusers where need to resolve aadu.immutableid to
        aduser, to *ensure* we have a hardmatch of problem objects (resolving baddomain
        DDG-DL-AllDOMAIN recipients to internal NoBrain etc. Still doesn't seem to be
        setting $hsum.NoBrain properly in outputs, but is dropping direct to pipe. May
        have borked single-indiceent xml object dumps tho.
    * 10:30 AM 11/8/2021 fixed CBH/HelpMessage tagging on -outobject
    * 3:30 PM 10/12/2021 added new Name:ObjName_guid support (new hires turn up with aduser named this way); added some marginal multi xoRcp & xoMailbox handling (loops outputs on the above, and the mapiTest), but doesn't do full AzureAD,Msoluser,MailUser,Guest lookups for these. It's really about error-suppression, and notifying the issue more than returning the full picture
    * 1:04 PM 9/28/2021 added:$AADUserManager lookup and dump of UPN, OpDN & mail (for correlating what email pol a user should have -> the one their manager does)
    * 1:52 PM 9/17/2021 moved $props to top ; test enabled/acctenabled, licRecon & mapi test results and use ww on issues ; flipped caad's to -silent (match cmsol 1st echo's to confirm tenant, rest silent); ren $xMProps -> $propsMailx, $XMFedProps-> $propsXMFed, $lProps -> $propsLic,$adprops -> $propsADU, $aaduprops -> $propsAADU, $aaduFedProps -> $propsAADUfed, $RcpPropsTbl -> $propsRcpTbl, $pltgM-> $pltGMailObj, $pltgMU -> $pltgMsoUsr
    * 4:33 PM 9/16/2021 fixed typo in get-AzureAdUser call, reworked output (aadu into markdown delimited wide layout), moved user detaiil reporting to below aadu, and output the federated AD remote DN, (proxied through AADU ext prop)
    * 10:56 AM 9/9/2021 force-resolve xoMailbox, added AADUser pop to the msoluser pop block; added test-xxMapiConnectivity as well; expanded ADU outputs - description, when*, Enabled, to look for terms/recent-hires/disabled accts
    * 3:05 PM 9/3/2021 fixed bugs introduced trying to user MaxResults (msol|aad), which come back param not recog'd when actually used - had to implement as postfiltering to assert open set return limits. ; Also implemented $xxxMeta.rgxOPFederatedDom check to resolve obj primarysmtpaddress to federating AD or AAD.
    * 11:20 AM 8/30/2021 added $MaxResults (shutdown return-all recips in addr space, on failure to match oprcp or xorcp ; fixed a couple of typos; minior testing/logic improvements. Still needs genercized 7pswlt support.
    * 1:30 PM 8/27/2021 new sniggle: CMW user that has EXOP mbx, remote: Added xoMailUser support, failed through DName lookups to try '*lname*' for near-missies. Could add trailing 'lnamne[0-=3]* searches, if not rcp/xrcps found...
    * 9:16 AM 8/18/2021 $xMProps: add email-drivers: CustomAttribute5, EmailAddressPolicyEnabled
    * 12:40 PM 8/17/2021 added -outObject, outputs a full descriptive object for each resolved recipient ; added a $hSum hash and shifted all the varis into mountpoints in the hash, with -outObject, the entire hash is conv'd to an obj and appended to $Rpt ; renamed most of the varis/as objects very clearly for what they are, as sub-props of the output objects. Wo -outobject, the usual comma-delim'd string of addresses is output.
    * 3:26 PM 7/29/2021 had sorta bug (AD context was xxxx:, gadu failing throwing undefined error), but debugging added extensive verbose echos, and an AD-specific try/catch to trap AD notfound errors (notorious, they throw terminating fails, unlike other modules; which crashes out processing even when using -EA continue). So it hardens up the fail recovery process.
    * 12:55 PM 7/19/2021 added guest & exo-mailcontact support (resolving missing ext-federated addresses), retolled logic down to grcp & gxrcp to drive balance of tests.
    * 12:05 PM 7/14/2021 rem'd requires: verb-exo  rem'd requires version 5 (gen'ing 'version' is specified more than once.); rem'd the $rgxSamAcctName, gen's parsing errors compiling into mod ;  added alias 'ulu'; added mailcontact excl on init grcp, to force those to exombx qry ; init vers
    .DESCRIPTION
    resolve-user.ps1 - Resolve specified array of -users (displayname, emailaddress, samaccountname) to mail asset, lic & ticket descriptors

    Key parameter options: 

    -getMobile parameter, to return details on xo MobileDevices in use with the EXO mailbox

    -getQuotaUsage parameter, returns details on xo MailboxFolderStatistics and effective Quota, 
        used with users with mailbox size issues (and/or LegalHold symptoms)

        Note: use of -getQuotaUsage also does an extensive check for LegalHold signs in the mailbox. including reporting on:
            - xoMailbox.LitigationHoldEnabled
            - xoMailbox.InPlaceHolds, 
            - xoMailbox.ComplianceTagHoldApplied
            - xoMailbox.DelayHoldApplied 
            - xoMailbox.DelayReleaseHoldApplied 
            - checks if xoMailboxFolderStats 'DiscoveryHolds' folder has ItemsInFolder -gt 0


    .PARAMETER  users
    Array of user descriptors: displayname, emailaddress, UPN, samaccountname (checks clipboard where unspecified)
    .PARAMETER Ticket
    Ticket number[-ticket 123456]
    .PARAMETER getMobile
    switch to return mobiledevice info for target XO Mailbox (not supported for onprem mailboxes)[-getMobile]
    .PARAMETER getQuotaUsage
    switch to return Quota & MailboxFolderStatistics & LegalHold analysis (XO-only)[-getQuotaUsage]
    .PARAMETER rgxAccentedNameChars
    Regular Expression that identifies input 'user' strings that should ahve diacriticals/latin/non-simple english characters replaced, before lookups
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER outObject
    switch to return a system.object summary to the pipeline[-outObject]
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    System.Object - returns summary report to pipeline
    .EXAMPLE
    PS> resolve-user 
    Default, no user identifier specified: attempts to parse a user descriptor from clipboard contents
    .EXAMPLE
    PS> resolve-user -users 'John Public'
    Process user displayname
    .EXAMPLE
    PS> resolve-user -users 'Test@domain.com','User Name','Alias','ExternalContact@emaildomain.com','confroom@tenant.onmicrosoft.com' -verbose ;
    Process an array of descriptors
    .EXAMPLE
    PS> $results = resolve-user -outobject -users 'Test@domain.com','John Public','Alias','ExternalContact@emaildomain.com','confroom@tenant.onmicrosoft.com''  ;
    PS> $feds = $results| group federator | select -expand name ;
    PS> write-verbose "echo filtered subsets" ;
    PS> ($results| ?{$_.federator -eq $feds[1] }).xomailbox
    PS> ($results| ?{$_.federator -eq $feds[1] }).xomailbox.primarysmtpaddress
    PS> write-verbose "profile results:" ; 
    PS> $analysis = foreach ($data in $resolved_objects){
    PS>     $Rpt = [ordered]@{
    PS>         PrimarySmtpAddress = $data.xorcp.primarysmtpaddress ; 
    PS>         ADUser_UPN = $data.aduser.userprincipalname ; 
    PS>         AADUser_UPN = $data.aaduser.UserPrincipalName ; 
    PS>         isDirSynced = $data.isDirSynced ; 
    PS>         IsNoBrain = $data.IsNoBrain ; 
    PS>         isSplitBrain = $data.isSplitBrain;
    PS>         IsLicensed = $data.IsLicensed;
    PS>         IsDisabledOU = $data.IsDisabledOU;
    PS>         IsADDisabled = $data.IsADDisabled; 
    PS>         IsAADDisabled = $data.IsAADDisabled;
    PS>     } ; 
    PS>     [pscustomobject]$Rpt ; 
    PS> } ; 
    PS> write-verbose "output tabular results" ; 
    PS> $analysis | ft -auto ;
    
    Demo does the following: 
        - Process array of users, specify return detailed object (-outobject), for post-processing & filtering,
        - Group results on federation sources,
        - Output summary of EXO mailboxes for the second federator
        - Then output the primary smtpaddress for all EXO mailboxes resolved to that federator
        - Then create a summary object of the is* properties and UPN, primarySmtpAddress, 
        - Finally display the summary as a console table
    .EXAMPLE
    PS> $rptNNNNNN_FName_LName_Domain_com = ulu -o -users 'FName.LName@Domain.com' ;  $rpt655692_FName_LName_Domain_com | xxml .\logs\rpt655692_FName_LName_Domain_com.xml
    Example (from ahk 7uluo! macro parser output) that creates a variable based on ticketnumber & email address (with underscores for alphanums), from the output, and then exports the variable content to xml. 
    Assigns to an immediately parsable inmem variable, along with the canned .xml that can be reloaded in future, or attached to a ticket.
    .EXAMPLE
    PS> resolve-user -users 'John Public' -getmobile
    Example that includes the -getMobile parameter, to return details on xo MobileDevices in use with the EXO mailbox
    .EXAMPLE
    PS> $999999Rpt = resolve-user fname.lname@toro.com -Ticket 99999 -getQuotaUsage -outObject ; 

        10:39:53:===v (1/1):Input: 'FNAME.LNAME@toro.com' | 'FNAME' | 'LNAME' v===(EML)
        get-Rmbx/xMbx: (Rmbx)(TOR USER, fed:ad.toro.com)
        SamAccountName | WindowsEmailAddress
        LNAMEFI         | FNAME.LNAME@toro.com
        Office | RecipientTypeDetails | RemoteRecipientType | IsDirSynced
                | RemoteUserMailbox    | Migrated            |
        ExternalDirectoryObjectId | CustomAttribute5 | EmailAddressPolicyEnabled
                                    |                  | True
        Outlook (xoMAPI) Access Test Result:Success
        xoMailboxStats Count:1
        10:39:56: INFO:  (-getQuotaUsage:running lengthy Get-xoMailboxFolderStatistics...)
        =get-AADuser FNAME.LNAME@toro.com>:
        =get-AADuserManager FNAME.LNAME@toro.com>:
        ===$hSum.ADUser: 
        UPN                 | DName      | FName | LName | Title                             
        FNAME.LNAME@toro.com | FNAME LNAME | FNAME | LNAME  | Supervisor II, Distribution Center
        Company | Dept                            | Ofc          
                | Operations Distribution El Paso | El Paso-D, TX
        Street | City | State | Zip | Phone           | Mobile
                |      |       |     | +1 915 231 7404 |
        Enabled | DN                                                          
        True    | CN=FNAME LNAME,OU=Users,OU=ELP,DC=global,DC=ad,DC=toro,DC=com
        whenCreated          | whenChanged         
        8/18/2017 4:13:54 PM | 2/23/2024 8:23:33 AM
        Desc : 8/21/17 FT for FNAME LNAME 146294 -bk
        LicenseGroup:(direct-assigned E3)
        ===$hSum.AADUserMgr: 
        UserPrincipalName       | Mail                   
        FNAME.LNAME@toro.com | FNAME.LNAME@toro.com
        OpOU : OU=Users,OU=ELP,DC=global,DC=ad,DC=toro,DC=com
        10:40:06: PROMPT:  UserPrincipalName       | Mail                   
        FNAME.LNAME@toro.com | FNAME.LNAME@toro.com
        OpOU : OU=Users,OU=ELP,DC=global,DC=ad,DC=toro,DC=com

        Licenses::
        MCOEV, FLOW_FREE, MCOPSTNC, ENTERPRISEPACK, POWER_BI_STANDARD, EMS, Microsoft_Teams_Audio_Conferencing_select_dial_out

        which specify the following size limits:
        IssueWarningQuotaMB        : 14336
        ProhibitSendQuotaMB        : 15360
        ProhibitSendReceiveQuotaMB : 17408
        (UseDatabaseQuotaDefaults:False)

        Current TotalMailboxSizeMB: 10912.2

        10:40:06: PROMPT:  QuotaStatus: Mailbox is below mandated SendReceiveQuotaMB by 4,447.80 megabytes
        10:40:06: PROMPT:  
        With the following non-zero folder metrics

        Folder                                                               Items SizeMB  OldestItem NewestItem          FolderType               
        ------                                                               ----- ------  ---------- ----------          ----------               
        annnnnnn-nbne-nnnn-anne-necncannbnnn\Inbox                           23774 5764.38 20230111   02/27/2024 16:37:25 Inbox                    
        annnnnnn-nbne-nnnn-anne-necncannbnnn\Deleted Items                   12434 4599.58 20220323   02/27/2024 16:35:34 DeletedItems             
        ...
        annnnnnn-nbne-nnnn-anne-necncannbnnn\Top of Information Store        1     0                                      Root
        10:40:06: INFO:  
        ===output to::
        D:\scripts\logs\823795-FNAME.LNAME@toro.com-folder-sizes-NONHIDDEN-NONZERO-run20240227-1039AM.xml

        10:40:09: WARNING:  
        10:40:09: WARNING:  
        10:40:09: WARNING:  EVIDENCE OF LEGAL HOLD DETECTED!:
        10:40:09: WARNING:  LitigationHoldEnabled    : False
        10:40:09: WARNING:  
        10:40:09: WARNING:  InPlaceHolds             : UniHnbnednbn-bndn-nnnf-nddn-annndnndnnae, UniHnnnneene-ndnd-naae-annn-nnnnnnnnnncn
        10:40:09: WARNING:  
        10:40:09: WARNING:  ComplianceTagHoldApplied : False
        10:40:09: WARNING:  
        10:40:09: WARNING:  DelayHoldApplied         : False
        10:40:09: WARNING:  
        10:40:09: WARNING:  DelayReleaseHoldApplied  : False
        10:40:09: WARNING:  
        10:40:09: WARNING:  
        10:40:09: WARNING:  Folder          Items    SizeMB OldestItem NewestItem          FolderType                    
        10:40:09: WARNING:  
        10:40:09: WARNING:  ------          -----    ------ ---------- ----------          ----------                    
        10:40:09: WARNING:  
        10:40:09: WARNING:  DiscoveryHolds 267225 101967.69            02/21/2024 08:42:57 RecoverableItemsDiscoveryHolds
        10:40:09: WARNING:  
        10:40:09: WARNING:  
        10:40:09: WARNING:  - DiscoveryHolds folder: If In-Place Hold is enabled or if a Microsoft 365 or Office 365 retention policy is assigned to the mailbox, this subfolder contains all items that meet the hold query parameters and are hard deleted.
        10:40:09: WARNING:  - DiscoveryHolds folder.NewestItem: Will reflect *last time LegalHold captured an item* (e.g. if/when LH was disabled and stopped holding traffic, if in the past)
        10:40:09: WARNING:  
    
    Example that includes the -getQuotaUsage parameter, to return details on xo MailboxFolderStatistics and effective Quota, around users with mailbox size issues, and assigns the returned summary to the variable `$999999Rpt
    Note: use of -getQuotaUsage also does an extensive check for LegalHold signs in the mailbox. including reporting on:
        - xoMailbox.LitigationHoldEnabled
        - xoMailbox.InPlaceHolds, 
        - xoMailbox.ComplianceTagHoldApplied
        - xoMailbox.DelayHoldApplied 
        - xoMailbox.DelayReleaseHoldApplied 
        - checks if xoMailboxFolderStats 'DiscoveryHolds' folder has ItemsInFolder -gt 0
    .LINK
    https://github.com/tostka/verb-exo
    #>

    # 2:49 PM 3/8/2022 pull verb-ex2010 ref - I think it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    # 12:19 PM 9/26/2023 pull verb-exo ref "
    #Requires -Modules ActiveDirectory, MSOnline, AzureAD, ExchangeOnlineManagement, verb-AAD, verb-ADMS, verb-Auth, verb-IO, verb-logging
    ##Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("(lyn|bcc|spb|adl)ms6(4|5)(0|1).(china|global)\.ad\.DOMAIN\.com")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding()]
    [Alias('ulu')]
    PARAM(
        #[Parameter(Position=0,Mandatory=$False,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Array of user descriptors: displayname, emailaddress, UPN, samaccountname (checks clipboard where unspecified)")]
        # failing to map pipeline to $users, reduce to Value from Pipeline
        [Parameter(Position=0,Mandatory=$False,ValueFromPipeline=$true,HelpMessage="Array of user descriptors: displayname, emailaddress, UPN, samaccountname (checks clipboard where unspecified)")]
            #[ValidateNotNullOrEmpty()]
            #[Alias('ALIAS1', 'ALIAS2')]
            [array]$users,
        [Parameter(Mandatory=$False,HelpMessage="Ticket Number [-Ticket '999999']")]
            [string]$Ticket,
        [Parameter(HelpMessage="switch to return mobiledevice info for target user[-getMobile]")]
            [switch] $getMobile,
        [Parameter(HelpMessage="switch to return Quota & MailboxFolderStatistics & LegalHold analysis (XO-only)[-getQuotaUsage]")]
            [switch]$getQuotaUsage,
        [Parameter(HelpMessage="Regular Expression that identifies input 'user' strings that should ahve diacriticals/latin/non-simple english characters replaced, before lookups (has default value, used to override for future temp exclusion)[-rgxAccentedNameChars `$rgx]")]
            [ValidateNotNullOrEmpty()]
            [regex]$rgxAccentedNameChars = "[^a-zA-Z0-9\s\.\(\)\{\}\/\&\$\#\@\,\`"\'\’\:\–_-]",
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
        [ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential,
        [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
            # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ;
            #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
            # pulling the pattern from global vari w friendly err
            [ValidateScript({
                if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ;
                return $true ;
            })]
            [string[]]$UserRole = @('SID','CSVC'),
            # svcAcct use: @('ESvcCBA','CSvcCBA','SIDCBA')
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
            [switch] $useEXOv2=$true,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent,
        [Parameter(HelpMessage="switch to return a system.object summary to the pipeline[-outObject]")]
            [switch] $outObject
    ) ;
    BEGIN{
        #region CONSTANTS_AND_ENVIRO #*======v CONSTANTS_AND_ENVIRO v======
        # Debugger:proxy automatic variables that aren't directly accessible when debugging (must be assigned and read back from another vari) ; 
        $rPSCmdlet = $PSCmdlet ; 
        $rPSScriptRoot = $PSScriptRoot ; 
        $rPSCommandPath = $PSCommandPath ; 
        $rMyInvocation = $MyInvocation ; 
        $rPSBoundParameters = $PSBoundParameters ; 
        [array]$score = @() ; 
        if($rPSCmdlet.MyInvocation.InvocationName){
            if($rPSCmdlet.MyInvocation.InvocationName -match '\.ps1$'){
                $score+= 'ExternalScript' 
            }elseif($rPSCmdlet.MyInvocation.InvocationName  -match '^\.'){
                write-warning "dot-sourced invocation detected!:$($rPSCmdlet.MyInvocation.InvocationName)`n(will be unable to leverage script path etc from MyInvocation objects)" ; 
                # dot sourcing is implicit scripot exec
                $score+= 'ExternalScript' ; 
            } else {$score+= 'Function' };
        } ; 
        if($rPSCmdlet.CommandRuntime){
            if($rPSCmdlet.CommandRuntime.tostring() -match '\.ps1$'){$score+= 'ExternalScript' } else {$score+= 'Function' }
        } ; 
        $score+= $rMyInvocation.MyCommand.commandtype.tostring() ; 
        $grpSrc = $score | group-object -NoElement | sort count ;
        if( ($grpSrc |  measure | select -expand count) -gt 1){
            write-warning  "$score mixed results:$(($grpSrc| ft -a count,name | out-string).trim())" ;
            if($grpSrc[-1].count -eq $grpSrc[-2].count){
                write-warning "Deadlocked non-majority results!" ;
            } else {
                $runSource = $grpSrc | select -last 1 | select -expand name ;
            } ;
        } else {
            write-verbose "consistent results" ;
            $runSource = $grpSrc | select -last 1 | select -expand name ;
        };
        write-host "Calculated `$runSource:$($runSource)" ;
        'score','grpSrc' | get-variable | remove-variable ; # cleanup temp varis

        # function self-name (equiv to script's: $MyInvocation.MyCommand.Path) ;
        ${CmdletName} = $rPSCmdlet.MyInvocation.MyCommand.Name ;
        $PSParameters = New-Object -TypeName PSObject -Property $rPSBoundParameters ;
        write-verbose "`$rPSBoundParameters:`n$(($rPSBoundParameters|out-string).trim())" ;
        $Verbose = ($VerbosePreference -eq 'Continue') ; 
        # pre psv2, no $rPSBoundParameters autovari to check, so back them out:
        if($rPSCmdlet.MyInvocation.InvocationName){
            if($rPSCmdlet.MyInvocation.InvocationName  -match '^\.'){
                $smsg = "detected dot-sourced invocation: Skipping `$PSCmdlet.MyInvocation.InvocationName-tied cmds..." ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            } else { 
                write-verbose 'Collect all non-default Params (works back to psv2 w CmdletBinding)'
                $ParamsNonDefault = (Get-Command $rPSCmdlet.MyInvocation.InvocationName).parameters | Select-Object -expand keys | Where-Object{$_ -notmatch '(Verbose|Debug|ErrorAction|WarningAction|ErrorVariable|WarningVariable|OutVariable|OutBuffer)'} ;
            } ; 
        } else { 
            $smsg = "(blank `$rPSCmdlet.MyInvocation.InvocationName, skipping Parameters collection)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ; 
        #region ENVIRO_DISCOVER ; #*------v ENVIRO_DISCOVER v------
        <#
        # Debugger:proxy automatic variables that aren't directly accessible when debugging ; 
        $rPSScriptRoot = $PSScriptRoot ; 
        $rPSCommandPath = $PSCommandPath ; 
        $rMyInvocation = $MyInvocation ; 
        $rPSBoundParameters = $PSBoundParameters ; 
        #>
        $ScriptDir = $scriptName = '' ;     
        if($ScriptDir -eq '' -AND ( (get-variable -name rPSScriptRoot -ea 0) -AND (get-variable -name rPSScriptRoot).value.length)){
            $ScriptDir = $rPSScriptRoot
        } ; # populated rPSScriptRoot
        if( (get-variable -name rPSCommandPath -ea 0) -AND (get-variable -name rPSCommandPath).value.length){
            $ScriptName = $rPSCommandPath
        } ; # populated rPSCommandPath
        if($ScriptDir -eq '' -AND $runSource -eq 'ExternalScript'){$ScriptDir = (Split-Path -Path $rMyInvocation.MyCommand.Source -Parent)} # Running from File
        # when $runSource:'Function', $rMyInvocation.MyCommand.Source is empty,but on functions also tends to pre-hit from the rPSCommandPath entFile.FullPath ;
        if( $scriptname -match '\.psm1$' -AND $runSource -eq 'Function'){
            write-host "MODULE-HOMED FUNCTION:Use `$CmdletName to reference the running function name for transcripts etc (under a .psm1 `$ScriptName will reflect the .psm1 file  fullname)"
            if(-not $CmdletName){write-warning "MODULE-HOMED FUNCTION with BLANK `$CmdletNam:$($CmdletNam)" } ;
        } # Running from .psm1 module
        if($ScriptDir -eq '' -AND (Test-Path variable:psEditor)) {
            write-verbose "Running from VSCode|VS" ; 
            $ScriptDir = (Split-Path -Path $psEditor.GetEditorContext().CurrentFile.Path -Parent) ; 
                if($ScriptName -eq ''){$ScriptName = $psEditor.GetEditorContext().CurrentFile.Path }; 
        } ;
        if ($ScriptDir -eq '' -AND $host.version.major -lt 3 -AND $rMyInvocation.MyCommand.Path.length -gt 0){
            $ScriptDir = $rMyInvocation.MyCommand.Path ; 
            write-verbose "(backrev emulating `$rPSScriptRoot, `$rPSCommandPath)"
            $ScriptName = split-path $rMyInvocation.MyCommand.Path -leaf ;
            $rPSScriptRoot = Split-Path $ScriptName -Parent ;
            $rPSCommandPath = $ScriptName ;
        } ;
        if ($ScriptDir -eq '' -AND $rMyInvocation.MyCommand.Path.length){
            if($ScriptName -eq ''){$ScriptName = $rMyInvocation.MyCommand.Path} ;
            $ScriptDir = $rPSScriptRoot = Split-Path $rMyInvocation.MyCommand.Path -Parent ;
        }
        if ($ScriptDir -eq ''){throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$rMyInvocation IS BLANK!" } ;
        if($ScriptName){
            if(-not $ScriptDir ){$ScriptDir = Split-Path -Parent $ScriptName} ; 
            $ScriptBaseName = split-path -leaf $ScriptName ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($ScriptName) ;
        } ; 
        # blank $cmdlet name comming through, patch it for Scripts:
        if(-not $CmdletName -AND $ScriptBaseName){
            $CmdletName = $ScriptBaseName
        }
        # last ditch patch the values in if you've got a $ScriptName
        if($rPSScriptRoot.Length -ne 0){}else{ 
            if($ScriptName){$rPSScriptRoot = Split-Path $ScriptName -Parent }
            else{ throw "Unpopulated, `$rPSScriptRoot, and no populated `$ScriptName from which to emulate the value!" } ; 
        } ; 
        if($rPSCommandPath.Length -ne 0){}else{ 
            if($ScriptName){$rPSCommandPath = $ScriptName }
            else{ throw "Unpopulated, `$rPSCommandPath, and no populated `$ScriptName from which to emulate the value!" } ; 
        } ; 
        if(-not ($ScriptDir -AND $ScriptBaseName -AND $ScriptNameNoExt  -AND $rPSScriptRoot  -AND $rPSCommandPath )){ 
            throw "Invalid Invocation. Blank `$ScriptDir/`$ScriptBaseName/`ScriptNameNoExt" ; 
            BREAK ; 
        } ; 
        # echo results dyn aligned:
        $tv = 'runSource','CmdletName','ScriptName','ScriptBaseName','ScriptNameNoExt','ScriptDir','PSScriptRoot','PSCommandPath','rPSScriptRoot','rPSCommandPath' ; 
        $tvmx = ($tv| Measure-Object -Maximum -Property Length).Maximum * -1 ; 
        $tv | get-variable | %{  write-verbose ("`${0,$tvmx} : {1}" -f $_.name,$_.value) } ; 
        'tv','tvmx'|get-variable | remove-variable ; # cleanup temp varis
        
        #endregion ENVIRO_DISCOVER ; #*------^ END ENVIRO_DISCOVER ^------

        if(-not $DoRetries){$DoRetries = 4 } ;    # # times to repeat retry attempts
        if(-not $RetrySleep){$RetrySleep = 10 } ; # wait time between retries
        if(-not $RetrySleep){$DawdleWait = 30 } ; # wait time (secs) between dawdle checks
        if(-not $DirSyncInterval){$DirSyncInterval = 30 } ; # AADConnect dirsync interval
        if(-not $ThrottleMs){$ThrottleMs = 50 ;}
        if(-not $rgxDriveBanChars){$rgxDriveBanChars = '[;~/\\\.:]' ; } ; # ;~/\.:,
        if(-not $rgxCertThumbprint){$rgxCertThumbprint = '[0-9a-fA-F]{40}' } ; # if it's a 40char hex string -> cert thumbprint  
        if(-not $rgxSmtpAddr){$rgxSmtpAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$" ; } ; # email addr/UPN
        if(-not $rgxDomainLogon){$rgxDomainLogon = '^[a-zA-Z][a-zA-Z0-9\-\.]{0,61}[a-zA-Z]\\\w[\w\.\- ]+$' } ; # DOMAIN\samaccountname 
        if(-not $exoMbxGraceDays){$exoMbxGraceDays = 30} ; 

        $rgxEmailAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$" ;
        # added support for . fname lname delimiter (supports pasted in dirname of email addresses, as user)
        $rgxDName = "^([a-zA-Z]{2,}(\s|\.)[a-zA-Z]{1,}'?-?[a-zA-Z]{2,}\s?([a-zA-Z]{1,})?)" ;
        #"^([a-zA-Z]{2,}\s[a-zA-Z]{1,}'?-?[a-zA-Z]{2,}\s?([a-zA-Z]{1,})?)" ;
        $rgxObjNameNewHires = "^([a-zA-Z]{2,}(\s|\.)[a-zA-Z]{1,}'?-?[a-zA-Z]{2,}\s?([a-zA-Z]{1,})?)_[a-z0-9]{10}"  # Name:Fname LName_f4feebafdb (appending uniqueness guid chunk)
        $rgxSamAcctNameTOR = "^\w{2,20}$" ; # up to 20k, the limit prior to win2k
        #$rgxSamAcctName = "^[^\/\\\[\]:;|=,+?<>@?]+$" # no char limit ;
        $MaxRecips = 25 ; # max number of objects to permit on a return resultsize/,ResultSetSize, to prevent empty set return of everything in the addressspace

        # props dyn filtering: write-host "=get-xMbx:>`n$(($hSum.xoMailbox |fl ($xMprops |?{$_ -notmatch '(sam.*|dist.*)'})|out-string).trim())`n-Title:$($hSum.xoUser.Title)";
        # $propsMailx: add email-drivers: CustomAttribute5, EmailAddressPolicyEnabled
        # 11:01 AM 12/27/2021 add forwarding settings (critical to bounce/block tracking for RM)
        #$propsMailx='samaccountname','windowsemailaddress','DistinguishedName','Office','RecipientTypeDetails','RemoteRecipientType','IsDirSynced','ExternalDirectoryObjectId','CustomAttribute5','EmailAddressPolicyEnabled' ;
        $propsMailx='samaccountname','windowsemailaddress','DistinguishedName','Office','RecipientTypeDetails','RemoteRecipientType',
            'IsDirSynced','ExternalDirectoryObjectId','CustomAttribute5','EmailAddressPolicyEnabled',
            'DeliverToMailboxAndForward','DeliverToMailboxAndForward','ForwardingSmtpAddress' ;
        # pulls: 'ImmutableId',
        # 1:41 PM 12/27/2021 add multiline md tbl output
        $propsMailxL1 = 'SamAccountName','WindowsEmailAddress' ; 
        $propsMailxL2 = 'Office','RecipientTypeDetails','RemoteRecipientType', 'IsDirSynced' ;
        $propsMailxL3 = 'ExternalDirectoryObjectId','CustomAttribute5','EmailAddressPolicyEnabled' ; 
        $propsMailxL4 = 'DistinguishedName' ; 
        $propsMailxL5 = 'ForwardingAddress','ForwardingSmtpAddress','DeliverToMailboxAndForward' ;        
        $propsXMFed = 'samaccountname','windowsemailaddress','DistinguishedName','Office','RecipientTypeDetails','RemoteRecipientType',
            'ImmutableId','ExternalDirectoryObjectId','CustomAttribute5','EmailAddressPolicyEnabled' ;
        $propsLic = @{Name='HasLic'; Expression={$_.IsLicensed }},@{Name='LicIssue'; Expression={$_.LicenseReconciliationNeeded }} ;
        $propsADU = 'UserPrincipalName','DisplayName','GivenName','Surname','Title','Company','Department','PhysicalDeliveryOfficeName',
            'StreetAddress','City','State','PostalCode','TelephoneNumber','MobilePhone','Enabled','DistinguishedName',
            'Description','whenCreated','whenChanged'
        #'samaccountname','UserPrincipalName','distinguishedname','Description','title','whenCreated','whenChanged','Enabled','sAMAccountType','userAccountControl' ;
        $propsADUsht = 'Enabled','Description','whenCreated','whenChanged','Title' ;
        $propsAADU = 'UserPrincipalName','DisplayName','GivenName','Surname','Title','Company','Department','PhysicalDeliveryOfficeName',
            'StreetAddress','City','State','PostalCode','TelephoneNumber','MobilePhone','Enabled','DistinguishedName' ;
        #'UserPrincipalName','name','ImmutableId','DirSyncEnabled','LastDirSyncTime','AccountEnabled' ;

        $propsAADUfed = 'UserPrincipalName','name','ImmutableId','DirSyncEnabled','LastDirSyncTime' ;
        $propsRcpTbl = 'Alias','PrimarySmtpAddress','RecipientType','RecipientTypeDetails' ;
        # line1-X AADU outputs
            #$propsMailx='samaccountname','windowsemailaddress','DistinguishedName','Office','RecipientTypeDetails','RemoteRecipientType','IsDirSynced','ImmutableId','ExternalDirectoryObjectId','CustomAttribute5','EmailAddressPolicyEnabled' ;
        <# full size
        $propsADL1 = 'UserPrincipalName','DisplayName','GivenName','Surname','Title' ;
        $propsADL2 = 'Company','Department','PhysicalDeliveryOfficeName' ;
        $propsADL3 = 'StreetAddress','City','State','PostalCode','TelephoneNumber','MobilePhone' ;
        # non-ADU props
        #$propsADL4 = 'DirSyncEnabled','ImmutableId','LastDirSyncTime','UsageLocation' ;
        #$propsADL5 = 'ObjectType','UserType' ;
        #>
        # abbreviated:
        $propsADL1 = @{Name='UPN';Expression={$_.UserPrincipalName }}, @{Name='DName';Expression={$_.DisplayName }}, 
            @{Name='FName';Expression={$_.GivenName }},@{Name='LName';Expression={$_.Surname }},
            @{Name='Title';Expression={$_.Title }};
        $propsADL2 = @{Name='Company';Expression={$_.Company }},@{Name='Dept';Expression={$_.Department }},
            @{Name='Ofc';Expression={$_.PhysicalDeliveryOfficeName }} ;
        $propsADL3 = @{Name='Street';Expression={$_.StreetAddress }}, 'City','State',
            @{Name='Zip';Expression={$_.PostalCode }}, @{Name='Phone';Expression={$_.TelephoneNumber }}, 
            @{Name='Mobile';Expression={$_.MobilePhone }} ;
        $propsADL4 = 'Enabled',@{Name='DN';Expression={$_.DistinguishedName }} ;
        #$propsADL4 = @{Name='Dsync';Expression={$_.DirSyncEnabled }}, @{Name='ImutID';Expression={$_.ImmutableId }}, @{Name='LastDSync';Expression={$_.LastDirSyncTime }}, @{Name='UseLoc';Expression={$_.UsageLocation }};
        #$propsADL5 = 'ObjectType','UserType' ;
        $propsADL5 = 'whenCreated','whenChanged' ; 
        $propsADL6 = @{Name='Desc';Expression={$_.Description }} ;

        # line1-5 AADU outputs
        <# full size
        $propsAADL1 = 'UserPrincipalName','DisplayName','GivenName','Surname','JobTitle' ;
        $propsAADL2 = 'CompanyName','Department','PhysicalDeliveryOfficeName' ;
        $propsAADL3 = 'StreetAddress','City','State','PostalCode','TelephoneNumber','Mobile' ;
        $propsAADL4 = 'DirSyncEnabled','ImmutableId','LastDirSyncTime','UsageLocation' ;
        $propsAADL5 = 'ObjectType','UserType' ;
        #>
        # abbreviated:
        $propsAADL1 = @{Name='UPN';Expression={$_.UserPrincipalName }}, @{Name='DName';Expression={$_.DisplayName }}, 
            @{Name='FName';Expression={$_.GivenName }},@{Name='LName';Expression={$_.Surname }},
            @{Name='Title';Expression={$_.JobTitle }};
        $propsAADL2 = @{Name='Company';Expression={$_.CompanyName }},@{Name='Dept';Expression={$_.Department }},
            @{Name='Ofc';Expression={$_.PhysicalDeliveryOfficeName }} ;
        $propsAADL3 = @{Name='Street';Expression={$_.StreetAddress }}, 'City','State',
            @{Name='Zip';Expression={$_.PostalCode }}, @{Name='Phone';Expression={$_.TelephoneNumber }}, 'Mobile' ;
        $propsAADL4 = @{Name='Dsync';Expression={$_.DirSyncEnabled }}, @{Name='ImutID';Expression={$_.ImmutableId }}, 
            @{Name='LastDSync';Expression={$_.LastDirSyncTime }}, @{Name='UseLoc';Expression={$_.UsageLocation }};
        $propsAADL5 = 'ObjectType','UserType', @{Name='Enabled';Expression={$_.AccountEnabled }} ;

        #$propsAADMgr = 'UserPrincipalName','Mail',@{Name='OpDN';Expression={$_.ExtensionProperty.onPremisesDistinguishedName }} ;
        # get mgr OU, not DN: ExtensionProperty.onPremisesDistinguishedName.split(',') | select -skip 1 ) -join ','
        $propsAADMgr = 'UserPrincipalName','Mail',
            @{Name='OpOU';Expression={($_.ExtensionProperty.onPremisesDistinguishedName.split(',') | select -skip 1) -join ',' }} ;
        $propsAADMgrL1 = 'UserPrincipalName','Mail' ;
        $propsAADMgrL2 = @{Name='OpOU';Expression={($_.ExtensionProperty.onPremisesDistinguishedName.split(',') | select -skip 1) -join ',' }} ;

        if($getMobile){
            # mobile device props
            #$MDtbl=[ordered]@{NoDashRow=$true } ; # out-markdowntable splat
            #$propsMobDevStats = 'DeviceFriendlyName','DeviceType','DeviceOS','ClientType','DeviceID',
            #    'FirstSyncTime','LastSyncAttemptTime','LastSuccessSync','NumberOfFoldersSynced' ; 
            $propsMobL1 = @{Name='FriendlyName';Expression={$_.DeviceFriendlyName }},@{Name='DevType';Expression={$_.DeviceType }},
                @{Name='DevOs';Expression={$_.DeviceOS }},@{Name='ClntType';Expression={$_.ClientType }},
                @{Name='DevID';Expression={$_.DeviceID }} ; 
            # shorten times: (get-date '6/20/2021 1:45:34 AM' -format 'M/d/yy H:mmtt');
            $propsMobL2 = @{Name='1stSyncTime';Expression={(get-date $_.FirstSyncTime -format 'M/d/yy H:mmtt') }},
                @{Name='LastSyncTime';Expression={(get-date $_.LastSyncAttemptTime -format 'M/d/yy H:mmtt') }},
                @{Name='LastSuccSync';Expression={(get-date $_.LastSuccessSync -format 'M/d/yy H:mmtt') }},
                @{Name='#Folders';Expression={$_.NumberOfFoldersSynced }} ; 
        } ; 
        if($getQuotaUsage){

            # 12:54 PM 9/18/2023 adds for MbxFolderStats, Quota & LegalHold eval:
            $prpStat = 'DisplayName',@{n="DBIssueWarningQuotaMB";e={[math]::round($_.DatabaseIssueWarningQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                @{n="DBProhibitSendQuotaMB";e={[math]::round($_.DatabaseProhibitSendQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                @{n="DBProhibitSendReceiveQuotaMB";e={[math]::round($_.DatabaseProhibitSendReceiveQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                @{n="TotalMailboxSizeMB";e={[math]::round($_.TotalItemSize.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                'LastLogonTime' ,'LastLogoffTime' ;

            $prpFldr = @{Name='Folder'; Expression={$_.Identity.tostring()}},@{Name="Items"; Expression={$_.ItemsInFolder}}, 
                @{n="SizeMB"; e={[math]::round($_.FolderSize.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}}, 
                @{Name="OldestItem"; Expression={get-date $_.OldestItemReceivedDate -f "yyyyMMdd"}}, 
                @{Name="NewestItem"; Expression={$_.NewestItemReceivedDate -f "yyyyMMdd"}},"FolderType" ;

            # 10:01 AM 2/27/2024 new spec for reporting on LegalHold symptom folders
            $prpFldrLH = @{Name='Folder'; Expression={$_.Name.tostring()}},@{Name="Items"; Expression={$_.ItemsInFolder}}, 
                @{n="SizeMB"; e={[math]::round($_.FolderSize.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}}, 
                @{Name="OldestItem"; Expression={get-date $_.OldestItemReceivedDate -f "yyyyMMdd"}}, 
                @{Name="NewestItem"; Expression={$_.NewestItemReceivedDate -f "yyyyMMdd"}},"FolderType" ;
                
            # 9:41 AM 2/27/2024 fixed borked InPlaceHolds expansion (was empty, and the prop is where JanelS holds actually *appear*)
$prpMbxHold = 'LitigationHoldEnabled',@{n="InPlaceHolds";e={ ($_.inplaceholds ) -join ', '}},
                'ComplianceTagHoldApplied','DelayHoldApplied','DelayReleaseHoldApplied' ; 

            $rgxHiddn = '.*\\(Versions|SubstrateHolds|DiscoveryHolds|Yammer.*|Social\sActivity\sNotifications|Suggested\sContacts|Recipient\sCache|PersonMetadata|Audits|Calendar\sLogging|Purges)$' ; 

        } ; 
        $rgxOPLic = '^CN\=ENT\-APP\-Office365\-(EXOK|F1|MF1)-DL$' ;
        $rgxXLic = '^CN\=ENT\-APP\-Office365\-(EXOK|F1|MF1)-DL$' ;

        #endregion CONSTANTS_AND_ENVIRO ; #*------^ END CONSTANTS_AND_ENVIRO ^------

        <# if we want pipeline to work have to move the clipboard grab out or down into process{}, where pipeline binding will be actually populated
        if(!$users){
            $users= (get-clipboard).trim().replace("'",'').replace('"','') ;
            if($users){
                write-verbose "No -users specified, detected value on clipboard:`n$($users)" ;
            } else {
                write-warning "No -users specified, nothing matching dname, emailaddress or samaccountname, found on clipboard. EXITING!" ;
                Break ;
            } ;
        } else {
            write-verbose "($(($users|measure).count)) user(s) specified:`n'$($users -join "','")'" ;
        } ;
        #>

        # pre psv2, no $PSBoundParameters autovari to check, so back them out:
        write-verbose 'Collect all non-default Params (works back to psv2 w CmdletBinding)'
        $ParamsNonDefault = (Get-Command $PSCmdlet.MyInvocation.InvocationName).parameters | Select-Object -expand keys | Where-Object{$_ -notmatch '(Verbose|Debug|ErrorAction|WarningAction|ErrorVariable|WarningVariable|OutVariable|OutBuffer)'} ;

        #if ($PSScriptRoot -eq "") {
        if( -not (get-variable -name PSScriptRoot -ea 0) -OR ($PSScriptRoot -eq '')){
            if ($psISE) { $ScriptName = $psISE.CurrentFile.FullPath } 
            elseif($psEditor){
                if ($context = $psEditor.GetEditorContext()) {$ScriptName = $context.CurrentFile.Path } 
            } elseif ($host.version.major -lt 3) {
                $ScriptName = $MyInvocation.MyCommand.Path ;
                $PSScriptRoot = Split-Path $ScriptName -Parent ;
                $PSCommandPath = $ScriptName ;
            } else {
                if ($MyInvocation.MyCommand.Path) {
                    $ScriptName = $MyInvocation.MyCommand.Path ;
                    $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                } else {throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$MyInvocation IS BLANK!" } ;
            };
            if($ScriptName){
                $ScriptDir = Split-Path -Parent $ScriptName ;
                $ScriptBaseName = split-path -leaf $ScriptName ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($ScriptName) ;
            } ; 
        } else {
            if($PSScriptRoot){$ScriptDir = $PSScriptRoot ;}
            else{
                write-warning "Unpopulated `$PSScriptRoot!" ; 
                $ScriptDir=(Split-Path -parent $MyInvocation.MyCommand.Definition) + "\" ;
            }
            if ($PSCommandPath) {$ScriptName = $PSCommandPath } 
            else {
                $ScriptName = $myInvocation.ScriptName
                $PSCommandPath = $ScriptName ;
            } ;
            $ScriptBaseName = (Split-Path -Leaf ((& { $myInvocation }).ScriptName))  ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
        } ;
        if(-not $ScriptDir){
            write-host "Failed `$ScriptDir resolution on PSv$($host.version.major): Falling back to $MyInvocation parsing..." ; 
            $ScriptDir=(Split-Path -parent $MyInvocation.MyCommand.Definition) + "\" ;
            $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ; 
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;     
        } else {
            if(-not $PSCommandPath ){
                $PSCommandPath  = $ScriptName ; 
                if($PSCommandPath){ write-host "(Derived missing `$PSCommandPath from `$ScriptName)" ; } ;
            } ; 
            if(-not $PSScriptRoot  ){
                $PSScriptRoot   = $ScriptDir ; 
                if($PSScriptRoot){ write-host "(Derived missing `$PSScriptRoot from `$ScriptDir)" ; } ;
            } ; 
        } ; 
        if(-not ($ScriptDir -AND $ScriptBaseName -AND $ScriptNameNoExt)){ 
            throw "Invalid Invocation. Blank `$ScriptDir/`$ScriptBaseName/`ScriptNameNoExt" ; 
            BREAK ; 
        } ; 

        $smsg = "`$ScriptDir:$($ScriptDir)" ;
        $smsg += "`n`$ScriptBaseName:$($ScriptBaseName)" ;
        $smsg += "`n`$ScriptNameNoExt:$($ScriptNameNoExt)" ;
        $smsg += "`n`$PSScriptRoot:$($PSScriptRoot)" ;
        $smsg += "`n`$PSCommandPath:$($PSCommandPath)" ;  ;
        write-verbose $smsg ; 

        if(-not $DoRetries){$DoRetries = 4 } ;    # # times to repeat retry attempts
        if(-not $RetrySleep){$RetrySleep = 10 } ; # wait time between retries
        if(-not $RetrySleep){$DawdleWait = 30 } ; # wait time (secs) between dawdle checks
        if(-not $DirSyncInterval){$DirSyncInterval = 30 } ; # AADConnect dirsync interval
        if(-not $ThrottleMs){$ThrottleMs = 50 ;}
        if(-not $rgxDriveBanChars){$rgxDriveBanChars = '[;~/\\\.:]' ; } ; # ;~/\.:,
        if(-not $rgxCertThumbprint){$rgxCertThumbprint = '[0-9a-fA-F]{40}' } ; # if it's a 40char hex string -> cert thumbprint  
        if(-not $rgxSmtpAddr){$rgxSmtpAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$" ; } ; # email addr/UPN
        if(-not $rgxDomainLogon){$rgxDomainLogon = '^[a-zA-Z][a-zA-Z0-9\-\.]{0,61}[a-zA-Z]\\\w[\w\.\- ]+$' } ; # DOMAIN\samaccountname 
        if(-not $exoMbxGraceDays){$exoMbxGraceDays = 30} ; 


        # 3:19 PM 6/23/2022: for exo2, this is going to have to be rearranged, if not shifted into smarter cxo2.
        <#rx10 -Verbose:$false ;
        rxo  -Verbose:$false ;
        cmsol  -Verbose:$false ;
        #>
        <#dx10 ; 
        rxo2 ; 
        rx10 ; 
        caad ;
        #>

        # 1:00 PM 9/18/2023 splice in modern svcconns
        #region SERVICE_CONNECTIONS #*======v SERVICE_CONNECTIONS v======
        # PRETUNE STEERING separately *before* pasting in balance of region
        #*------v STEERING VARIS v------
        $useO365 = $true ;
        $useEXO = $true ; 
        $UseOP=$true  ; 
        $UseExOP=$true ;
        $useForestWide = $true ; # flag to trigger cross-domain/forest-wide code in AD & EXoP
        $UseOPAD = $true ; 
        $UseMSOL = $false ; # should be hard disabled now in o365
        $UseAAD = $true  ; 
        $useO365 = [boolean]($useO365 -OR $useEXO -OR $UseMSOL -OR $UseAAD)
        $UseOP = [boolean]($UseOP -OR $UseExOP -OR $UseOPAD) ;
        #*------^ END STEERING VARIS ^------
        #*------v EXO V2/3 steering constants v------
        $EOMModName =  'ExchangeOnlineManagement' ;
        $EOMMinNoWinRMVersion = $MinNoWinRMVersion = '3.0.0' ; # support both names
        #*------^ END EXO V2/3 steering constants ^------
        # assert Org from Credential specs (if not param'd)
        # 1:36 PM 7/7/2023 and revised again -  revised the -AND, for both, logic wasn't working
        if($TenOrg){    
            $smsg = "Confirmed populated `$TenOrg" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } elseif(-not($tenOrg) -and $Credential){
            $smsg = "(unconfigured `$TenOrg: asserting from credential)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $TenOrg = get-TenantTag -Credential $Credential ;
        } else { 
            # if not using Credentials or a TargetTenants/TenOrg loop, default the $TenOrg on the $env:USERDOMAIN
            $smsg = "(unconfigured `$TenOrg & *NO* `$Credential: fallback asserting from `$env:USERDOMAIN)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            switch -regex ($env:USERDOMAIN){
                ([regex]('(' + (( @($TORMeta.legacyDomain,$CMWMeta.legacyDomain)  |foreach-object{[regex]::escape($_)}) -join '|') + ')')).tostring() {$TenOrg = $env:USERDOMAIN.substring(0,3).toupper() } ;
                $TOLMeta.legacyDomain {$TenOrg = 'TOL' }
                default {throw "UNRECOGNIZED `$env:USERDOMAIN!:$($env:USERDOMAIN)" ; exit ; } ;
            } ; 
        } ; 
        #region useO365 ; #*------v useO365 v------
        #$useO365 = $false ; # non-dyn setting, drives variant EXO reconnect & query code
        #if($CloudFirst){ $useO365 = $true } ; # expl: steering on a parameter
        if($useO365){
            #region GENERIC_EXO_CREDS_&_SVC_CONN #*------v GENERIC EXO CREDS & SVC CONN BP v------
            # o365/EXO creds
            <### Usage: Type defaults to SID, if not spec'd - Note: there must be a *logged in & configured *profile*
            $o365Cred = get-TenantCredentials -TenOrg $TenOrg -verbose -userrole SID ;
            Returns a credential set for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred = get-TenantCredentials -TenOrg $TenOrg -verbose -userrole CSVC ;
            Returns the CSVC Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred = get-TenantCredentials -TenOrg $TenOrg -verbose -userrole B2BI ;
            Returns the B2BI Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            ###>
            $o365Cred = $null ;
            if($Credential){
                $smsg = "`Credential:Explicit credentials specified, deferring to use..." ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                 # get-TenantCredentials() return format: (emulating)
                 $o365Cred = [ordered]@{
                    Cred=$Credential ; 
                    credType=$null ; 
                } ; 
                $uRoleReturn = resolve-UserNameToUserRole -UserName $Credential.username -verbose:$($VerbosePreference -eq "Continue") ; # Username
                #$uRoleReturn = resolve-UserNameToUserRole -Credential $Credential -verbose = $($VerbosePreference -eq "Continue") ;   # full Credential support
                if($uRoleReturn.UserRole){
                    $o365Cred.credType = $uRoleReturn.UserRole ; 
                } else { 
                    $smsg = "Unable to resolve `$credential.username ($($credential.username))"
                    $smsg += "`nto a usable 'UserRole' spec!" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    throw $smsg ;
                    Break ;
                } ; 
            } else { 
                $pltGTCred=@{TenOrg=$TenOrg ; UserRole=$null; verbose=$($verbose)} ;
                if($UserRole){
                    $smsg = "(`$UserRole specified:$($UserRole -join ','))" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $pltGTCred.UserRole = $UserRole; 
                } else { 
                    $smsg = "(No `$UserRole found, defaulting to:'CSVC','SID' " ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    $pltGTCred.UserRole = 'CSVC','SID' ; 
                } ; 
                $smsg = "get-TenantCredentials w`n$(($pltGTCred|out-string).trim())" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $o365Cred = get-TenantCredentials @pltGTCred
            } ; 
            if($o365Cred.credType -AND $o365Cred.Cred -AND $o365Cred.Cred.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
                #$smsg = "(Resolved credentials CredType/UserRole as: $($o365Cred.credType)" ; 
                $smsg = "(validated `$o365Cred contains .credType:$($o365Cred.credType) & `$o365Cred.Cred.username:$($o365Cred.Cred.username)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } else { 
                $smsg = "UNABLE TO RESOLVE FUNCTIONAL CredType/UserRole from specified explicit -Credential:$($Credential.username)!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 

                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                break ; 
            } ; 
            if($o365Cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                if(get-Variable -Name cred$($tenorg) -scope Script -ea 0 ){ remove-Variable -Name cred$($tenorg) -scope Script } ;
                New-Variable -Name cred$($tenorg) -scope Script -Value $o365Cred.cred ;
                $smsg = "Resolved $($Tenorg) `$o365cred:$($o365Cred.cred.username) (assigned to `$cred$($tenorg))" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatettus_$($tenorg)).value + $statusdelta) ;
                $smsg = "Unable to resolve $($tenorg) `$o365Cred value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                Break ;
            } ;
            # configure splat for connections: (see above useage)
            # downstream commands
            $pltRXO = [ordered]@{
                Credential = $Credential ;
                verbose = $($VerbosePreference -eq "Continue")  ;
            } ;
            if((gcm Reconnect-EXO).Parameters.keys -contains 'silent'){
                $pltRxo.add('Silent',$silent) ;
            } ;
            # default connectivity cmds - force silent false
            $pltRXOC = [ordered]@{} ; $pltRXO.GetEnumerator() | ?{ $_.Key -notmatch 'silent' }  | ForEach-Object { $pltRXOC.Add($_.Key, $_.Value) } ; $pltRXOC.Add('silent',$true) ; 
            if((gcm Reconnect-EXO).Parameters.keys -notcontains 'silent'){
                $pltRxo.remove('Silent') ;
            } ; 
            #region EOMREV ; #*------v EOMREV Check v------
            #$EOMmodname = 'ExchangeOnlineManagement' ;
            $pltIMod = @{Name = $EOMmodname ; ErrorAction = 'Stop' ; verbose=$false} ;
            # do a gmo first, faster than gmo -list
            if([version]$EOMMv = (Get-Module @pltIMod| sort version | select -last 1).version){}
            elseif([version]$EOMMv = (Get-Module -ListAvailable @pltIMod| sort version | select -last 1).version){}
            else {
                $smsg = "$($EOMmodname) PowerShell v$($MinNoWinRMVersion) module is required, do you want to install it?" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                else{ write-host -foregroundcolor YELLOW "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $bRet = Read-Host "Enter YYY to continue. Anything else will exit"  ;
                if ($bRet.ToUpper() -eq "YYY") {
                    $smsg = "Installing $($EOMmodname) module..." ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Install-Module $EOMmodname -Repository PSGallery -AllowClobber -Force ;
                } else {
                    $smsg = "Please install $($EOMmodname) PowerShell v$($MinNoWinRMVersion)  module." ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #exit 1
                    break ;
                }  ;
            } ;
            $smsg = "(Checking for WinRM support in this EOM rev...)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            if([version]$EOMMv -ge [version]$MinNoWinRMVersion){
                $MinNoWinRMVersion = $EOMMv.tostring() ;
                $IsNoWinRM = $true ;
            }elseif([version]$EOMMv -lt [version]$MinimumVersion){
                $smsg = "Installed $($EOMmodname) is v$($MinNoWinRMVersion): This module is obsolete!" ;
                $smsg += "`nAnd unsupported by this function!" ;
                $smsg += "`nPlease install $($EOMmodname) PowerShell v$($MinNoWinRMVersion)  module!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Break ;
            } else {
                $IsNoWinRM = $false ;
            } ;
            [boolean]$UseConnEXO = [boolean]([version]$EOMMv -ge [version]$MinNoWinRMVersion) ;
            #endregion EOMREV ; #*------^ END EOMREV Check  ^------
            #-=-=-=-=-=-=-=-=
            <### CALLS ARE IN FORM: (cred$($tenorg))
            # downstream commands
            $pltRXO = @{
                Credential = (Get-Variable -name cred$($tenorg) ).value ;
                #verbose = $($verbose) ;
                Verbose = $FALSE ; 
            } ;
            if((gcm Reconnect-EXO).Parameters.keys -contains 'silent'){
                $pltRxo.add('Silent',$false) ;
            } ; 
            # default connectivity cmds - force silent false
            $pltRXOC = [ordered]@{} ; $pltRXO.GetEnumerator() | ?{ $_.Key -notmatch 'silent' }  | ForEach-Object { $pltRXOC.Add($_.Key, $_.Value) } ; $pltRXOC.Add('silent',$true) ;
            if((gcm Reconnect-EXO).Parameters.keys -notcontains 'silent'){
                $pltRxo.remove('Silent') ;
            } ; 
            #$pltRXO creds & .username can also be used for AzureAD connections:
            #Connect-AAD @pltRXOC ;
            ###>
            #endregion GENERIC_EXO_CREDS_&_SVC_CONN #*------^ END GENERIC EXO CREDS & SVC CONN BP ^------

        } else {
            $smsg = "(`$useO365:$($useO365))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ; # if-E if($useO365 ){
        #endregion useO365 ; #*------^ END useO365 ^------

        #region useEXO ; #*------v useEXO v------
        # 1:29 PM 9/15/2022 as of MFA & v205, have to load EXO *before* any EXOP, or gen get-steppablepipeline suffix conflict error
        if($useEXO){
            if ($script:useEXOv2 -OR $useEXOv2) { reconnect-eXO2 @pltRXOC }
            else { reconnect-EXO @pltRXOC } ;
        } else {
            $smsg = "(`$useEXO:$($useEXO))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ; # if-E 
        #endregion  ; #*------^ END useEXO ^------
        
        #region GENERIC_EXOP_CREDS_&_SRVR_CONN #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
        # steer all onprem code on $XXXMeta.ExOPAccessFromToro & Ex10Server values
        #$UseOP=$true ; 
        #$UseExOP=$true ;
        #$useForestWide = $true ; # flag to trigger cross-domain/forest-wide code in AD & EXoP
        <# no onprem dep
        if((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro -AND (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server){
            $UseOP = $UseExOP = $true ;
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`ENABLING use of OnPrem Ex system this pass." ;
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        } else {
            $UseOP = $UseExOP = $false ;
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`nDISABLING use of OnPrem Ex system this pass." ;
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        } ;
        #>
        if($UseOP){
            #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
            # do the OP creds too
            $OPCred=$null ;
            # default to the onprem svc acct
            # userrole='ESVC','SID'
            #$pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC','SID'; verbose=$($verbose)} ;
            # userrole='SID','ESVC'
            $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='SID','ESVC'; verbose=$($verbose)} ;
            $smsg = "get-HybridOPCredentials w`n$(($pltGHOpCred|out-string).trim())" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                if(get-Variable -Name "cred$($tenorg)OP" -scope Script -ea 0 ){ remove-Variable -Name "cred$($tenorg)OP" -scope Script } ;
                New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
                $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
                Break ;
            } ;
            $smsg= "Using OnPrem/EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            <### CALLS ARE IN FORM: (cred$($tenorg))
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                #verbose = $($verbose) ;
                Verbose = $FALSE ; 
            } ;
            $1stConn = $false ; # below uses silent suppr for both x10 & xo!
            if($1stConn){
                $pltRX10.silent = $pltRXO.silent = $false ;
            } else {
                $pltRX10.silent = $pltRXO.silent =$true ;
            } ;
            if($pltRX10){ReConnect-Ex2010 @pltRX10 }
            else {ReConnect-Ex2010 }
            #$pltRx10 creds & .username can also be used for local ADMS connections
            ###>
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                #verbose = $($verbose) ;
                Verbose = $FALSE ; 
            } ;
            if((gcm Reconnect-Ex2010).Parameters.keys -contains 'silent'){
                $pltRX10.add('Silent',$false) ;
            } ;

            # defer cx10/rx10, until just before get-recipients qry
            #endregion GENERIC_EXOP_CREDS_&_SRVR_CONN #*------^ END GENERIC EXOP CREDS & SRVR CONN BP ^------
            # connect to ExOP X10
            if($useEXOP){
                if($pltRX10){
                    #ReConnect-Ex2010XO @pltRX10 ;
                    ReConnect-Ex2010 @pltRX10 ;
                } else { Reconnect-Ex2010 ; } ;
                #Add-PSSnapin -Name 'Microsoft.Exchange.Management.PowerShell.SnapIn'
                #TK: add: test Exch & AD functional connections
                TRY{
                    if(get-command -module (get-module |?{$_.name -like 'tmp_*'}).name -name 'get-OrganizationConfig'){} else {
                        $smsg = "(mangled Ex10 conn: dx10,rx10...)" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        disconnect-ex2010 ; reconnect-ex2010 ; 
                    } ; 
                    if(-not ($OrgName = ((get-OrganizationConfig).DistinguishedName.split(',') |?{$_ -like 'DC=*'}) -join '.' -replace 'DC=','')){
                        $smsg = "Missing Exchange Connection! (no (Get-OrganizationConfig).name returned)" ; 
                        throw $smsg ; 
                        $smsg | write-warning  ; 
                    } ; 
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = $ErrTrapd ;
                    $smsg += "`n";
                    $smsg += $ErrTrapd.Exception.Message ;
                    if ($logging) { _write-log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    CONTINUE ;
                } ;
            } else { 
            
            } ; 
            if($useForestWide){
                #region  ; #*------v OPTIONAL CODE TO ENABLE FOREST-WIDE NATIVE EXCHANGE SUPPORT v------
                $smsg = "(`$useForestWide:$($useForestWide)):Enabling EXoP Forestwide)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $smsg = 'Set-AdServerSettings -ViewEntireForest `$True' ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Set-AdServerSettings -ViewEntireForest $True ;
                #endregion  ; #*------^ END OPTIONAL CODE TO ENABLE FOREST-WIDE NATIVE EXCHANGE SUPPORT ^------
            } ;
        } else {
            $smsg = "(`$useOP:$($UseOP))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        }  ;  # if-E $UseOP

        #region UseOPAD #*------v UseOPAD v------
        if($UseOP -OR $UseOPAD){
            #region GENERIC_ADMS_CONN_&_XO #*------v GENERIC ADMS CONN & XO  v------
            $smsg = "(loading ADMS...)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # always capture load-adms return, it outputs a $true to pipeline on success
            $ADMTLoaded = load-ADMS -Verbose:$FALSE ;
            # 9:32 AM 4/20/2023 trimmed disabled/fw-borked cross-org code
            TRY {
                if(-not(Get-ADDomain  -ea STOP).DNSRoot){
                    $smsg = "Missing AD Connection! (no (Get-ADDomain).DNSRoot returned)" ; 
                    throw $smsg ; 
                    $smsg | write-warning  ; 
                } ; 
                $objforest = get-adforest -ea STOP ; 
                # Default new UPNSuffix to the UPNSuffix that matches last 2 elements of the forestname.
                $forestdom = $UPNSuffixDefault = $objforest.UPNSuffixes | ?{$_ -eq (($objforest.name.split('.'))[-2..-1] -join '.')} ; 
                if($useForestWide){
                    #region  ; #*------v OPTIONAL CODE TO ENABLE FOREST-WIDE AD GC QRY SUPPORT v------
                    $smsg = "(`$useForestWide:$($useForestWide)):Enabling AD Forestwide)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $smsg = 'Set-AdServerSettings -ViewEntireForest `$True' ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #TK 9:44 AM 10/6/2022 need org wide for rolegrps in parent dom (only for onprem RBAC, not EXO)
                    $GcFwide = "$((Get-ADDomainController -Discover -Service GlobalCatalog).hostname):3268" ;        
                    #endregion  ; #*------^ END  OPTIONAL CODE TO ENABLE FOREST-WIDE AD GC QRY SUPPORT  ^------
                } ;    
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = $ErrTrapd ;
                $smsg += "`n";
                $smsg += $ErrTrapd.Exception.Message ;
                if ($logging) { _write-log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                CONTINUE ;
            } ;        
            #endregion GENERIC_ADMS_CONN_&_XO #*------^ END GENERIC ADMS CONN & XO ^------
        } else {
            $smsg = "(`$UseOP:$($UseOP))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        }  ;
        #if (!$domaincontroller) { $domaincontroller = get-gcfast } ;
        #if(!$domaincontroller){ if(test-path function:get-gcfast){$domaincontroller = get-gcfast} else { throw "no get-gcfast()!" } ;} else {"(existing `$domaincontroller:$($domaincontroller))"} ;
        # use new get-GCFastXO cross-org dc finde
        # default to Op_ExADRoot forest from $TenOrg Meta
        #if($UseOP -AND -not $domaincontroller){
        if($UseOP -AND -not (get-variable domaincontroller -ea 0)){
            #$domaincontroller = get-GCFastXO -TenOrg $TenOrg -subdomain ((gv -name "$($TenOrg)Meta").value['OP_ExADRoot']) -verbose:$($verbose) |?{$_.length};
            # need to debug the above, credential issue?
            # just get it done
            $domaincontroller = get-GCFast
        }  else { 
            # have to defer to get-azuread, or use EXO's native cmds to poll grp members
            # TODO 1/15/2021
            $useEXOforGroups = $true ; 
            $smsg = "$($TenOrg):HAS NO ON-PREM ACTIVEDIRECTORY, DEFERRING ALL GROUP ACCESS & MGMT TO NATIVE EXO CMDS!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
        if($useForestWide -AND -not $GcFwide){
            #region  ; #*------v OPTIONAL CODE TO ENABLE FOREST-WIDE ACTIVEDIRECTORY SUPPORT: v------
            $smsg = "`$GcFwide = Get-ADDomainController -Discover -Service GlobalCatalog" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $GcFwide = "$((Get-ADDomainController -Discover -Service GlobalCatalog).hostname):3268" ;
            $smsg = "Discovered `$GcFwide:$($GcFwide)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #endregion  ; #*------^ END OPTIONAL CODE TO ENABLE FOREST-WIDE ACTIVEDIRECTORY SUPPORT ^------
        } ;
        #endregion UseOPAD #*------^ END UseOPAD ^------

        #region MSOL_CONNECTION ; #*------v  MSOL CONNECTION v------
        #$UseMSOL = $false 
        if($UseMSOL){
            #$reqMods += "connect-msol".split(";") ;
            #if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
            $smsg = "(loading MSOL...)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #connect-msol ;
            connect-msol @pltRXOC ;
        } else {
            $smsg = "(`$UseMSOL:$($UseMSOL))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ;
        #endregion MSOL_CONNECTION ; #*------^  MSOL CONNECTION ^------

        #region AZUREAD_CONNECTION ; #*------v AZUREAD CONNECTION v------
        #$UseAAD = $false 
        if($UseAAD){
            #$reqMods += "Connect-AAD".split(";") ;
            #if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
            $smsg = "(loading AAD...)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Connect-AAD @pltRXOC ;
        } else {
            $smsg = "(`$UseAAD:$($UseAAD))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ;
        #endregion AZUREAD_CONNECTION ; #*------^ AZUREAD CONNECTION ^------
        
        <# defined above
        # EXO connection
        $pltRXO = @{
            Credential = (Get-Variable -name cred$($tenorg) ).value ;
            verbose = $($verbose) ; } ;
        #>
        <#
        if($VerbosePreference = "Continue"){
            $VerbosePrefPrior = $VerbosePreference ;
            $VerbosePreference = "SilentlyContinue" ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        disconnect-exo ;
        if ($script:useEXOv2) { reconnect-eXO2 @pltRXOC }
        else { reconnect-EXO @pltRXOC } ;
        # reenable VerbosePreference:Continue, if set, during mod loads
        if($VerbosePrefPrior -eq "Continue"){
            $VerbosePreference = $VerbosePrefPrior ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        #>
        #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        #endregion SERVICE_CONNECTIONS #*======^ END SERVICE_CONNECTIONS ^======
    

        # finally if we're using pipeline, and aggregating, we need to aggreg outside of the process{} block
        if($PSCmdlet.MyInvocation.ExpectingInput){
            # pipeline instantiate an aggregator here
        } ;

        # check if using Pipeline input or explicit params:
        if ($PSCmdlet.MyInvocation.ExpectingInput) {
            $smsg = "Data received from pipeline input: '$($InputObject)'" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } else {
            # doesn't actually return an obj in the echo
            #$smsg = "Data received from parameter input: '$($InputObject)'" ;
            #if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            #else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ;


    }
    PROCESS{
        # ps1 faked: #region PROCESS ; #*------v PROCESS:$($identity -join ',') v------

        #$dname= 'Todd Kadrie' ;
        #$dname = 'Stacy Sotelo'

        if(-not $users){
            $users= (get-clipboard).trim().replace("'",'').replace('"','') ;
            if($users){
                write-verbose "No -users specified, detected value on clipboard:`n$($users)" ;
            } else {
                write-warning "No -users specified, nothing matching dname, emailaddress or samaccountname, found on clipboard. EXITING!" ;
                Break ;
            } ;
        } else {
            write-verbose "($(($users|measure).count)) user(s) specified:`n'$($users -join "','")'" ;
        } ;

        $ttl = ($users|measure).count ; $Procd=0 ;
        [array]$Rpt =@() ;
        # with pipeline input, the pipeline evals as either $_ (if unmapped to a param in binding), or iterating on the mapped value.
        #     the foreach loop below doesn't actually loop. Process{} is the loop with a pipeline-fed param, and the bound - $users - variable once per pipeline bound element - per array item on an array -
        #     is run with the $users value populated with each element in turn. IOW, the foreach is a single-run pass, and the Process{} block is the loop.
        # you need both a bound $users at the top - to handle explicit assigns resolve-user -users $variable.
        # with a process {} block to handle any pipeline passed input. The pipeline still maps to the bound param: $users, but the entire process{} is run per element, rather than iteratign the internal $users foreach.
        foreach ($usr in $users){
            
            #region START-LOG #*======v START-LOG OPTIONS v======
            #region START-LOG-HOLISTIC #*------v START-LOG-HOLISTIC v------
            # Single log for script/function example that accomodates detect/redirect from AllUsers scope'd installed code, and hunts a series of drive letters to find an alternate logging dir (defers to profile variables)
            #${CmdletName} = $rPSCmdlet.MyInvocation.MyCommand.Name ;
            if(!(get-variable LogPathDrives -ea 0)){$LogPathDrives = 'd','c' };
            foreach($budrv in $LogPathDrives){if(test-path -path "$($budrv):\scripts" -ea 0 ){break} } ;
            if(!(get-variable rgxPSAllUsersScope -ea 0)){
                $rgxPSAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps(((d|m))*)1|dll)$" ;
            } ;
            if(!(get-variable rgxPSCurrUserScope -ea 0)){
                $rgxPSCurrUserScope="^$([regex]::escape([Environment]::GetFolderPath('MyDocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps((d|m)*)1|dll)$" ;
            } ;
            $pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($whatif) ;} ;
            # if using [CmdletBinding(SupportsShouldProcess)] + -WhatIf:$($WhatIfPreference):
            #$pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($WhatIfPreference) ;} ;
            $pltSL.Tag = $null ; # $CmdletName # $ModuleName ; 
            if($script:rPSCommandPath){ $prxPath = $script:rPSCommandPath }
            elseif($script:PSCommandPath){$prxPath = $script:PSCommandPath}
            if($rMyInvocation.MyCommand.Definition){$prxPath2 = $rMyInvocation.MyCommand.Definition }
            elseif($MyInvocation.MyCommand.Definition){$prxPath2 = $MyInvocation.MyCommand.Definition } ; 
            if($prxPath){
                if(($prxPath -match $rgxPSAllUsersScope) -OR ($prxPath -match $rgxPSCurrUserScope)){
                    $bDivertLog = $true ; 
                    switch -regex ($prxPath){
                        $rgxPSAllUsersScope{$smsg = "AllUsers"} 
                        $rgxPSCurrUserScope{$smsg = "CurrentUser"}
                    } ;
                    $smsg += " context script/module, divert logging into [$budrv]:\scripts" 
                    write-verbose $smsg  ;
                    if($bDivertLog){
                        if((split-path $prxPath -leaf) -ne $cmdletname){
                            # function in a module/script installed to allusers|cu - defer name to Cmdlet/Function name
                            $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
                        } else {
                            # installed allusers|CU script, use the hosting script name
                            $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $prxPath -leaf)) ;
                        }
                    } ;
                } else {
                    $pltSL.Path = $prxPath ;
                } ;
           }elseif($prxPath2){
                if(($prxPath2 -match $rgxPSAllUsersScope) -OR ($prxPath2 -match $rgxPSCurrUserScope) ){
                     $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $prxPath2 -leaf)) ;
                } elseif(test-path $prxPath2) {
                    $pltSL.Path = $prxPath2 ;
                } elseif($cmdletname){
                    $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
                } else {
                    $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$CMDLETNAME, FROM WHICH TO BUILD A START-LOG.PATH!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    BREAK ;
                } ; 
            } else{
                $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$CMDLETNAME, FROM WHICH TO BUILD A START-LOG.PATH!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                BREAK ;
            }  ;
            write-verbose "start-Log w`n$(($pltSL|out-string).trim())" ; 
            $logspec = start-Log @pltSL ;
            $error.clear() ;
            TRY {
                if($logspec){
                    $logging=$logspec.logging ;
                    $logfile=$logspec.logfile ;
                    $transcript=$logspec.transcript ;
                    $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                    if($stopResults){
                        $smsg = "Stop-transcript:$($stopResults)" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    } ; 
                    $startResults = start-Transcript -path $transcript ;
                    if($startResults){
                        $smsg = "start-transcript:$($startResults)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ; 
                } else {throw "Unable to configure logging!" } ;
            } CATCH [System.Management.Automation.PSNotSupportedException]{
                if($host.name -eq 'Windows PowerShell ISE Host'){
                    $smsg = "This version of $($host.name):$($host.version) does *not* support native (start-)transcription" ; 
                } else { 
                    $smsg = "This host does *not* support native (start-)transcription" ; 
                } ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;
            #endregion START-LOG-HOLISTIC #*------^ END START-LOG-HOLISTIC ^------
            #region LOGBUILD ; #*------v LOGBUILD v------
            # building an outputfile name dynamically using paremeters
            #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            # start by rebuilding from base of start-log(): $logfile: 'D:\scripts\logs\get-ExOPSmtpReceiveTLSReport-SERVER50'
            # *first* reset $ofile; it's picking the filename up from the OS
            $ofile = $null;
            [array]$ofile = $ofile ;
            #$ofile += ("$($_.Name)-$($_.value)" -join ',' );
            #$ofile=".\$($ticket)-$($usr)-folder-sizes-NONHIDDEN-NONZERO-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;
            $ofile += @("$($ticket)-$($usr)") ; 
            $ofile += "REPORT" ; 
            $ofile += "run$(get-date -format 'yyyyMMdd-HHmmtt')" ; 
            [string]$ofile = $ofile -join '-' ; 
            [string]$ofile += ".xml" ; 
            # split existing logfile path out: e.g. D:\scripts\logs\update-xoRetiringConfRmWindows-(TOR)-LASTPASS
            #[string]$ofile = join-path -path ($logfile -split '-LOG-BATCH-')[0]  -childpath $ofile ; 
            # raw path, no cmdletname prefix
            [string]$ofile = join-path -path (split-path $logfile) -childpath $ofile ; 
            

            #$fname = $lname = $dname = $OPRcp = $OPMailbox = $OPRemoteMailbox = $ADUser = $xoRcp = $xoMailbox = $xoUser = $xoMemberOf = $MsolUser = $LicenseGroup = $null ;
            $isEml=$isDname=$isSamAcct=$isXORcpMulti  = $false ;


            $hSum = [ordered]@{
                dname = $null ;
                fname = $null ;
                lname = $null ;
                OPRcp = $null ;
                xoRcp = $null ;
                OPMailbox = $null ;
                OPRemoteMailbox = $null ;
                ADUser = $null ;
                Federator = $null ;
                xoMailbox = $null ;
                xoMUser = $null ;
                xoUser = $null ;
                xoMemberOf = $null ;
                txGuest = $null ;
                OPMapiTest = $null ;
                xoMapiTest = $null ;
                MsolUser = $null ;
                AADUser = $null ; # added for MailUser variant
                AADUserMgr = $null ;
                AADUserLics = $null ; 
                LicenseGroup = $null ;
                isDirSynced = $null 
                isNoBrain = $false ;
                isSplitBrain = $false;
                #isUnlicensed = $false ;
                IsLicensed = $false ; 
                IsDisabledOU = $false ; 
                IsADDisabled = $false ; 
                IsAADDisabled = $false ; 
            } ;
            $procd++ ;
            write-verbose "processing:$($usr)" ;
            if($getMobile){
                $smsg = "(-getMobile:retrieving user xo MobileDevices)" ; 
                if($verbose){
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-verbose $smsg } ; 
                } ; 
                $hsum.add('xoMobileDeviceStats',$null) ; 
            } ; 
            if($getQuotaUsage){
                $smsg = "(-getQuotaUsage:retrieving user xo Mailbox*Statistics & Effective Quotas)" ; 
                if($verbose){
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-verbose $smsg } ; 
                } ; 
                $hsum.add('xoMailboxStats',$null) ; 
                $hsum.add('xoMailboxFolderStats',$null) ; 
                $hsum.add('xoEffectiveQuotas',$null) ; 
                $hsum.add('xoNetOfSendReceiveQuotaMB',$null) ; 
                [string]$ofMbxFolderStats = $ofile.replace('REPORT',"folder-sizes-NONHIDDEN-NONZERO") ; 

            } ; 

            if($usr -match $rgxAccentedNameChars){
                # 9:36 AM 9/23/2024 pre remove all diacritics & latin chars 
                #Remove-StringDiacritic -String 'Helen Bräuchle' |Remove-StringLatinCharacters
                $smsg = "Remove-StringDiacritic -String $($usr) (if needed)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $usr = Remove-StringDiacritic -String $usr ; 
            
                $smsg = "Remove-StringLatinCharacters -String $($usr) (if needed)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $usr = Remove-StringLatinCharacters -String $usr ; 
            } ; 

            switch -regex ($usr){
                $rgxEmailAddr {
                    $hSum.fname,$hSum.lname = $usr.split('@')[0].split('.') ;
                    $hSum.dname = $usr ;
                    write-verbose "(detected user ($($usr)) as EmailAddr)" ;
                    $isEml = $true ;
                    Break ;
                }
                $rgxObjNameNewHires{
                    write-verbose "(detected user ($($usr)) as ObjNameNewHires)" ;
                    $hSum.fname,$hSum.lname = $usr.split('_')[0].split(' ');
                    $hSum.dname = $usr.split('_')[0] ;
                    write-verbose "(detected user ($($usr)) as DisplayName)" ;
                    $isObjName = $true ;
                    Break ;
                }
                $rgxDName {
                    if($usr.contains('.')){
                        write-verbose "(replacing period in DName)" ;
                        $usr = $usr.replace('.',' ') ;
                    };
                    $hSum.fname,$hSum.lname = $usr.split(' ') ;
                    $hSum.dname = $usr ;
                    write-verbose "(detected user ($($usr)) as DisplayName)" ;
                    $isDname = $true ;
                    Break ;
                }
                $rgxSamAcctNameTOR {
                    $hSum.lname = $usr ;
                    write-verbose "(detected user ($($usr)) as SamAccountName)" ;
                    $isSamAcct  = $true ;
                    Break ;
                }
                default {
                    write-warning "$((get-date).ToString('HH:mm:ss')):No -user specified, nothing matching dname, emailaddress or samaccountname, found on clipboard. EXITING!" ;
                    #Break ;
                } ;
            } ;

            $sBnr="===v ($($Procd)/$($ttl)):Input: '$($usr)' | '$($hSum.fname)' | '$($hSum.lname)' v===" ;
            if($isEml){$sBnr+="(EML)"}
            elseif($isDname){$sBnr+="(DNAM)"}
            elseif($isObjName){$sBnr+="(ONAM)"}
            elseif($isSamAcct){$sBnr+="(SAM)"}
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr)" ;

            write-host -foreground yellow "get-Rmbx/xMbx: " -nonewline;


            # $isEml=$isDname=$isSamAcct=$false ;
            $MDtbl=[ordered]@{NoDashRow=$true } ; # out-markdowntable splat
            $pltGMailObj=[ordered]@{
                ResultSize = $MaxRecips ;
            } ;
            if($isEml -OR $isSamAcct){
                write-verbose "processing:'identity':$($usr)" ;
                $pltGMailObj.add('identity',$usr) ;
            } ;
            if($isObjName){
                # filter on Name, (not dname)
                $dname = $hSum.dname
                $fltr = "name -like '$usr'" ;
                write-verbose "processing:'filter':$($fltr)" ;
                $pltGMailObj.add('filter',$fltr) ;
            } ;
            if($isDname){
                # interestinb bug: switched to $hSum.dname: ISE is fine, but ConsoleHost fails to expand the $fltr properly.
                # standard is: Variables: Enclose variables that need to be expanded in single quotation marks (for example, '$User'). Don't use curly-brackets (impedes expansion)
                # workaround: looks like have to proxy the $hsum.Dname, to provide a single non-dotted variable name
                $dname = $hSum.dname
                $fltr = "displayname -like '$dname'" ;
                write-verbose "processing:'filter':$($fltr)" ;
                $pltGMailObj.add('filter',$fltr) ;
            } ;

            $error.clear() ;

            #write-verbose "get-[exo]Recipient w`n$(($pltGMailObj|out-string).trim())" ;
            #write-verbose "get-recipient w`n$(($pltGMailObj|out-string).trim())" ;
            # exclude contacts, they don't represent real onprem mbx assoc, and we need to refer those to EXO mbx qry anyway.
            write-verbose "get-recipient w`n$(($pltGMailObj|out-string).trim())" ;
            rx10 -Verbose:$false -silent ;
            if($hSum.OPRcp=get-recipient @pltGMailObj -ea 0 | select -first $MaxRecips | ?{$_.recipienttypedetails -ne 'MailContact'}){
                write-verbose "`$hSum.OPRcp found" ;
                switch ($hSum.OPRcp.recipienttypedetails){
                    'RemoteUserMailbox' {write-host "(Rmbx)" -nonewline}
                    'UserMailbox' {write-host "(Mbx)" -nonewline}
                    # no rmbx, but remote obj?
                    'MailUser' {
                        $smsg = "MAILUSER WO RMBX DETECTED! - POSSIBLE NOBRAIN?"
                        write-warning $smsg
                        #$hsum.isNoBrain = $true ;
                    }
                    'MailUniversalDistributionGroup' {write-host "(DG)" -nonewline}
                    'DynamicDistributionGroup'  {write-host "(DDG)" -nonewline}
                    'MailContact' {write-host "(MC)" -nonewline]}
                    default{}
                }
            } elseif($isDname -and $hsum.lname) {
                $smsg = "Failed:RETRY: detected 'LName':$($hsum.lname) for near matches..." ;
                write-host $smsg ;
                $lname = $hsum.lname ;
                $fltrB = "displayname -like '*$lname*'" ;
                write-verbose "RETRY:get-recipient -filter {$($fltr)}" ;
                if($hSum.OPRcp=get-recipient -filter $fltr -ea 0 | select -first $MaxRecips |?{$_.recipienttypedetails -ne 'MailContact'}){
                    write-verbose "`$hSum.OPRcp found" ;
                } ;
            };

            if(!$hsum.OpRcp){
                $smsg = "(Failed to OP:get-recipient on:$($usr))"
                if($isDname){$smsg += " or *$($hsum.lname )*"}
                write-host $smsg ;
            } else {
                write-verbose "`$hSum.OPRcp:`n$(($hSum.OPRcp|out-string).trim())" ;
            } ;


            #write-verbose "$((get-alias ps1GetxRcp).definition) w`n$(($pltGMailObj|out-string).trim())" ;
            write-verbose "get-xorecipient  w`n$(($pltGMailObj|out-string).trim())" ;
            #rxo  -Verbose:$false -silent ;
            if($hSum.xoRcp=get-xorecipient @pltGMailObj -ea 0 | select -first $MaxRecips ){
                write-verbose "`$hSum.xoRcp found" ;
            } elseif($isDname -and $hsum.lname) {
                $smsg = "Failed:RETRY: detected 'LName':$($hsum.lname) for near matches..." ;
                write-host $smsg ;
                $lname = $hsum.lname ;
                $fltrB = "displayname -like '*$lname*'" ;
                write-verbose "RETRY:get-recipient -filter {$($fltr)}" ;
                if($hSum.xoRcp=get-xorecipient -filter $fltr -ea 0 -ResultSize $MaxRecips |?{$_.recipienttypedetails -ne 'MailContact'}){
                    write-verbose "`$hSum.xoRcp found" ;
                } ;
            }
            if(!$hsum.xoRcp){
                #$smsg = "Failed to $((get-alias ps1GetxRcp).definition) on:$($usr)"
                $smsg = "get-xorecipient on:$($usr)"
                if($isDname){$smsg += " or *$($hsum.lname )*"} ;
                write-host $smsg ;
            } else {
                $smsg =  "`$hSum.xoRcp:`n$(($hSum.xoRcp|out-string).trim())" ;
                write-verbose $smsg ;
                if($hSum.xoRcp -is [system.array]){
                    write-warning "Multiple matching xoRcps!:$($smsg)`nTHIS WILL NOT RETURN FULL AADUSER ETC FOR BOTH OBJECTS!`nUSE TARGETED UPN ETC TO DUMP VARIANT OBJECTS!" ;
                    $isXORcpMulti = $true ;
                } ;
            } ;

            if($hSum.OPRcp){
                $error.clear() ;
                TRY {
                    switch -regex ($hSum.OPRcp.recipienttype){
                        "UserMailbox" {
                            write-verbose "'UserMailbox':get-mailbox $($hSum.OPRcp.identity)"
                            if($hSum.OPMailbox=get-mailbox $hSum.OPRcp.identity -resultsize $MaxRecips | select -first $MaxRecips ){ ;
                                #write-verbose "`$hSum.OPMailbox:`n$(($hSum.OPMailbox|out-string).trim())" ;
                                if($outObject){

                                } else {
                                    $Rpt += $hSum.OPMailbox.primarysmtpaddress ;
                                } ;
                                write-verbose "'UserMailbox':Test-MAPIConnectivity -identity $($hSum.OPMailbox.userprincipalname)"
                                $hSum.OPMapiTest = Test-MAPIConnectivity -identity $hSum.OPMailbox.userprincipalname ;
                                $smsg = "Outlook (MAPI) Access Test Result:$($hsum.OPMapiTest.result)" ;
                                if($hsum.OPMapiTest.result -eq 'Success'){
                                    write-host -foregroundcolor green $smsg ;
                                } else {
                                    write-WARNING $smsg ;
                                } ;
                            } ;
                        }
                        "MailUser" {
                            write-verbose "'MailUser':get-remotemailbox $($hSum.OPRcp.identity)"
                            if($hSum.OPRemoteMailbox=get-remotemailbox $hSum.OPRcp.identity -resultsize $MaxRecips -ea 0 | select -first $MaxRecips){
                                write-verbose "`$hSum.OPRemoteMailbox:`n$(($hSum.OPRemoteMailbox|out-string).trim())" ;
                            }else{
                                $smsg = "RecipientTypeDetails:MailUser with NO Rmbx! (NoBrain?)" ;
                                write-warning $smsg ;
                                if($hsum.xoRcp.ExternalDirectoryObjectId){
                                    # of course has match to AADU  - always does - we're going to need the AADU before we can lookup the ADU
                                    # $pltGadu.identity = $hSum.AADUser.ImmutableId | convert-ImmuntableIDToGUID | select -expand guid ;
                                    caad  -Verbose:$false -silent ;
                                    write-verbose "OPRcp:Mailuser, ensure GET-ADUSER pulls AADUser.matched object for cloud recipient:`nfallback:get-AzureAdUser  -objectid $($hsum.xoRcp.ExternalDirectoryObjectId)" ;
                                    # have to postfilter, if want specific count -maxresults catch's with no $error[0]
                                    $hSum.AADUser  = get-AzureAdUser  -objectid $hsum.xoRcp.ExternalDirectoryObjectId | select -first $MaxRecips;  ;
                                } else {
                                    throw "Unsupported object, blank `$hsum.xoRcp.ExternalDirectoryObjectId!" ;
                                } ;
                            }
                            if($outObject){

                            } else {
                                $Rpt += $hSum.OPRemoteMailbox.primarysmtpaddress ;
                            } ;
                        } ;
                        default {
                            write-warning "$((get-date).ToString('HH:mm:ss')):Unsupported RecipientType:($hSum.OPRcp.recipienttype). EXITING!" ;
                            Break ;
                        }
                    }
                    <# get-aduser docs say REsultSetSize is documented,
                    [Get-ADUser (ActiveDirectory) | Microsoft Docs - docs.microsoft.com/](https://docs.microsoft.com/en-us/powershell/module/activedirectory/get-aduser?view=windowsserver2019-ps)
                     but use of it throws: Parameter set cannot be resolved using the specified named parameters.
                     pull it and post filter to 1...
                    #>
                    #ResultSetSize = $MaxRecips
                    #$pltGadu=[ordered]@{Identity = $null ; Properties='*' ;errorAction='STOP' ; } ;
                    $pltGadu=[ordered]@{Identity = $null ; Properties=$propsADU ;errorAction='STOP' ; } ;
                    if($hSum.OPRemoteMailbox ){
                        # get-aduser dox but doesn't really support ResultSetSize, post filter for it.
                        $pltGadu.identity = $hSum.OPRemoteMailbox.samaccountname ;
                    }elseif($hSum.OPMailbox){
                        $pltGadu.identity = $hSum.OPMailbox.samaccountname ;
                    } else {
                        # cloud-first or no brain, neither oprmbx or opmailbox;  should have populated $hSum.AADUser above, use immutable lookup
                        if($hSum.AADUser.DirSyncEnabled){
                            $smsg = "Falling back to AADU Immutable lookup to locate replicated adu source" ;
                            if($pltGadu.identity = $hSum.AADUser.ImmutableId | convert-ImmuntableIDToGUID | select -expand guid){
                                $smsg = "(Resolved AADU.Immutable ->GUID:$($pltGadu.identity))" ;
                                write-verbose $smsg ;
                            }else {
                                $smsg = "UNABLE TO RESOLVE ADU.IMMUTABLEID TO ADU GUID!"
                                write-warning $smsg ;
                                throw $smsg ;
                            }
                        } else {
                            $smsg = "$AADUsuer not DirSyncEnabled: CLOUD FIRST!"
                            write-warning $smsg ;
                            #throw $smsg ;
                        } ;
                    };
                    if($pltGadu.identity){
                        <# this is throwing a blank fail
                        WARNING: 15:04:18:Failed processing .
                        Error Message:
                        Error Details:
                        # and dumping balance of processing
                        issue: was in adms drive: :xxxx, gadu was searching root domain only
                        so it was a search fail, throwing an error, but didn't return details. Still good idea to trap not found and echo it
                        #>
                        #$hSum.ADUser =Get-ADUser @pltGadu ;
                        write-verbose "Get-ADUser w`n$(($pltGadu|out-string).trim())" ;
                        # try a nested local trycatch, against a missing result
                        Try {
                            #Get-ADUser $DN -ErrorAction Stop ;
                            $hSum.ADUser =Get-ADUser @pltGadu | select -first $MaxRecips ;
                        } Catch [Microsoft.ActiveDirectory.Management.ADIdentityNotFoundException] {
                            write-warning "(no matching ADuser found:$($pltGadu.identity))" ;
                        } catch {
                            $ErrTrapd=$Error[0] ;
                            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Continue ;
                        } ;

                        write-verbose "`$hSum.ADUser:`n$(($hSum.ADUser|fl $propsADU| out-string).trim())" ;
                        $smsg = "(TOR USER, fed:$($TORMeta.adforestname))" ;
                        $hSum.Federator = $TORMeta.adforestname ;
                        write-host -Fore yellow $smsg ;
                        
                        <#
                        if($hSum.OPRemoteMailbox){
                            $smsg = "$(($hSum.OPRemoteMailbox |fl $propsMailx|out-string).trim())"
                        } ;
                        if($hSum.OPMailbox){
                            $smsg =  "$(($hSum.OPMailbox |fl $propsMailx|out-string).trim())" ;
                        } ;
                        #>
                        # swap to md tbl fmt
                        if($hSum.OPRemoteMailbox){$MailRecip = $hSum.OPRemoteMailbox } ; 
                        if($hSum.OPMailbox){$MailRecip = $hSum.OPMailbox } ; 
                        $smsg = "$(($MailRecip| select $propsMailxL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                        $smsg += "`n$(($MailRecip|select $propsMailxL2 |out-markdowntable @MDtbl|out-string).trim())" ;
                        $smsg += "`n$(($MailRecip|select $propsMailxL3 |out-markdowntable @MDtbl|out-string).trim())" ;
                        #$smsg += "`n$(($MailRecip|select $propsMailxL4 |out-markdowntable @MDtbl|out-string).trim())" ;
                        #$smsg += "`n$(($MailRecip|select $propsMailxL4 | fl |out-string).trim())" ;
                        # drop L4 it's DN, which is already in ADU md tbl
                        # flip dn L4 to fl (suppress crlf)

                        write-host $smsg ;
                        #if($MailRecip.ForwardingAddress){
                        #    $smsg += "`n$(($MailRecip|select $propsMailxL5 |out-markdowntable @MDtbl|out-string).trim())" ;
                        #} ; 
                        <#
                        if($hSum.OPRemoteMailbox -AND $hSum.OPRemoteMailbox.ForwardingAddress){
                            write-host $smsg ; # write pending primary (using ww on next)
                            #$smsg = "==FORWARDED rMBX!:`n$(($hSum.OPRemoteMailbox  |ft -a ForwardingAddress,DeliverToMailboxAndForward,ForwardingSmtpAddress|out-string).trim())" ;
                            $smsg = "==FORWARDED rMBX!:" ; 
                            $smsg += "`n$(($MailRecip|select $propsMailxL5 |out-markdowntable @MDtbl|out-string).trim())" ;
                        } ;
                        if($hSum.OPMailbox -AND $hSum.OPMailbox.ForwardingAddress){
                            write-host $smsg ; # write pending primary (using ww on next)
                            $smsg = "==FORWARDED opMBX!:`n$(($hSum.OPMailbox |ft -a ForwardingAddress,DeliverToMailboxAndForward,ForwardingSmtpAddress|out-string).trim())" ;
                        } ;
                        #>
                        if($hSum.OPRemoteMailbox.ForwardingAddress -OR $hSum.OPMailbox.ForwardingAddress){
                            write-host $smsg ; # echo pending, using ww below
                            $smsg = "==FORWARDED rMBX!:" ; 
                            $smsg += "`n$(($MailRecip|select $propsMailxL5 |out-markdowntable @MDtbl|out-string).trim())" ;
                            write-warning $smsg ;
                        } ; 

                        #$smsg += "`n$(($hSum.ADUser |fl $propsADUsht  |out-string).trim())"
                        # these are already in the ADU md tbl dump, drop them
                        #$smsg = "$(($hSum.ADUser |fl $propsADUsht  |out-string).trim())"
                        #write-host $smsg ;
                    } ;
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Continue ;
                } ;
            }elseif($hSum.xoRcp){
                foreach($txR in $hSum.xoRcp){
                    TRY {
                        switch -regex ($txR.recipienttypedetails){
                            "UserMailbox" {
                                #write-verbose "$((get-alias ps1GetxMbx).definition) w`n$(($pltGMailObj|out-string).trim())" ;
                                write-verbose "get-exomailbox w`n$(($pltGMailObj|out-string).trim())" ;
                                if($hSum.xoMailbox=get-xomailbox @pltGMailObj -ea 0 | select -first $MaxRecips ){
                                    write-verbose "`$hSum.xoMailbox:`n$(($hSum.xoMailbox|out-string).trim())" ;
                                    if($outObject){

                                    } else {
                                        $Rpt += $hSum.xoMailbox.primarysmtpaddress ;
                                    } ;
                                    if($hSum.xoMailbox -is [system.array]){
                                        write-warning "Multiple mailboxes matched!" ;
                                    } ;
                                    # accomodate array returned (multiple matches):
                                    $ino = 0 ;
                                    foreach($xmbx in $hSum.xoMailbox){
                                        $ino++ ;
                                        if($hSum.xoMailbox -isnot [system.array]){
                                            $smsg = "xmbx$($ino):$($xmbx.userprincipalname)" ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        } ;
                                        write-verbose "'xoUserMailbox':Test-exoMAPIConnectivity $($xmbx.userprincipalname)"
                                        $hSum.xoMapiTest = Test-xoMAPIConnectivity -identity $xmbx.userprincipalname ;
                                        $smsg = "Outlook (xoMAPI) Access Test Result:$($hsum.xoMapiTest.result)" ;
                                        if($hsum.xoMapiTest.result -eq 'Success'){
                                            write-host -foregroundcolor green $smsg ;
                                        } else {
                                            write-WARNING $smsg ;
                                        } ;
                                        if($getMobile){
                                            # $devstats = Get-exoMobileDeviceStatistics -Mailbox UPN
                                            #$smsg = "'xoMobileDeviceStats':$((get-alias ps1GetxMobilDevStats).definition) -Mailbox $($xmbx.userprincipalname)"
                                            $smsg = "'xoMobileDeviceStats':Get-xoMobileDeviceStatistics -Mailbox $($xmbx.userprincipalname)"
                                            if($verbose){
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                                else{ write-verbose $smsg } ; 
                                            } ; 
                                            $hsum.xoMobileDeviceStats = Get-xoMobileDeviceStatistics -Mailbox $xmbx.userprincipalname -ea STOP ; 
                                            $smsg = "xoMobileDeviceStats Count:$(($hsum.xoMapiTest|measure).count)" ;
                                            write-host -foregroundcolor green $smsg ;
                                        } ; 
                                        if($getQuotaUsage){
                                            $pltGMbxStatX=[ordered]@{
                                                identity = $hSum.xoMailbox.exchangeguid ;
                                                ErrorAction = 'STOP' ; 
                                            } ;
                                            $smsg = "Get-xoMailboxStatistics  w`n$(($pltGMbxStatX|out-string).trim())"
                                            if($verbose){
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                                else{ write-verbose $smsg } ; 
                                            } ; 
                                            $hSum.xoMailboxStats = Get-xoMailboxStatistics @pltGMbxStatX | select $prpStat;
                                            $smsg = "xoMailboxStats Count:$(($hsum.xoMapiTest|measure).count)" ;
                                            write-host -foregroundcolor green $smsg ;

                                            If($hSum.xoMailbox.UseDatabaseQuotaDefaults){
                                                $hSum.xoEffectiveQuotas = $hSum.xoMailboxStats | select @{N ='IssueWarningQuotaMB'; e={$_.DBIssueWarningQuotaMB}},
                                                @{n='ProhibitSendQuotaMB'; e={$_.DBProhibitSendQuotaMB}},
                                                @{n='ProhibitSendReceiveQuotaMB';e={$_.DBProhibitSendReceiveQuotaMB}}; 
                                            } else {
                                                $hSum.xoEffectiveQuotas = $hSum.xoMailbox | select @{n="IssueWarningQuotaMB";e={[math]::round($_.IssueWarningQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                                                @{n="ProhibitSendQuotaMB";e={[math]::round($_.ProhibitSendQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                                                @{n="ProhibitSendReceiveQuotaMB";e={[math]::round($_.ProhibitSendReceiveQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}} ;
                                            } ;  
                                            $hSum.xoNetOfSendReceiveQuotaMB = $hSum.xoEffectiveQuotas.ProhibitSendQuotaMB - $hSum.xoMailboxStats.TotalMailboxSizeMB ; 

                                            $pltGMbxStatX.add('IncludeOldestAndNewestItems',$true) ; 
                                            $smsg = "Get-xoMailboxFolderStatistics  w`n$(($pltGMbxStatX|out-string).trim())" ;
                                            if($verbose){
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                                else{ write-verbose $smsg } ; 
                                            } ; 
                                            TRY{
                                                $hsum.xoMailboxFolderStats = Get-xoMailboxFolderStatistics @pltGMbxStatX  ;

                                                $smsg = "Export FolderStats to`n$(($ofMbxFolderStats|out-string).trim())" ;
                                                if($verbose){
                                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                                    else{ write-verbose $smsg } ; 
                                                } ; 
                                                $hsum.xoMailboxFolderStats | ?{$_.ItemsInFolder -gt 0 -AND $_.identity -notmatch $rgxHiddn } | 
                                                    select $prpFldr | sort SizeMB -desc | export-csv  -path $ofMbxFolderStats -notype ;

                                            } CATCH {
                                                $ErrTrapd=$Error[0] ;
                                                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                                                write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                                            } ; 
                                        } ; 
                                    } ;
                                    break ;
                                } ;
                            }
                            "MailUser" {
                                # external mail recipient, *not* in TTC - likely in other rgs, and migrated to remote EXOP enviro
                                #$hSum.OPRemoteMailbox=get-remotemailbox $txR.identity  ;
                                caad -silent -verbose:$false ;
                                #write-verbose "`$txR | $((get-alias ps1GetxMUsr).definition)..." ;
                                write-verbose "`$txR | Get-xoMailUser..." ;
                                $hSum.xoMUser = $txR | Get-xoMailUser -ResultSize $MaxRecips | select -first $MaxRecips ;
                                #write-verbose "`$txR | $((get-alias ps1GetxUser).definition)..." ;
                                write-verbose "`$txR | get-xoUser ..." ;
                                $hSum.xoUser = $txR | get-xouser -ResultSize $MaxRecips | select -first $MaxRecips ;
                                write-verbose "`$hSum.xoUser:`n$(($hSum.xoUser|out-string).trim())" ;
                                #write-verbose "get-AzureAdUser  -objectid $($hSum.xoUser.userPrincipalName)" ;
                                #$hSum.AADUser  = get-AzureAdUser  -objectid $hSum.xoMUser.userPrincipalName -Top $MaxRecips ;
                                write-verbose "`$hSum.xoMUser:`n$(($hSum.xoMUser|out-string).trim())" ;
                                #$Rpt += $hSum.OPRemoteMailbox.primarysmtpaddress ;
                                write-host "$($txR.ExternalEmailAddress): matches a MailUser object with UPN:$($hSum.xoMUser.userPrincipalName)" ;
                                if($outObject){

                                } else {
                                    $Rpt += $hSum.xoMUser.primarysmtpaddress ;
                                } ;
                                break ;
                            } ;
                            "GuestMailUser" {
                                #$hSum.OPRemoteMailbox=get-remotemailbox $txR.identity  ;
                                caad -silent -verbose:$false ;
                                #write-verbose "`$txR | $((get-alias ps1GetxUser).definition)..." ;
                                write-verbose "`$txR | get-xoUser..." ; 
                                $hSum.xoUser = $txR | get-xouser -ResultSize $MaxRecips | select -first $MaxRecips ;
                                write-verbose "`$hSum.xoUser:`n$(($hSum.xoUser|out-string).trim())" ;
                                write-verbose "get-AzureAdUser  -objectid $($hSum.xoUser.userPrincipalName)" ;
                                $hSum.txGuest = get-AzureAdUser  -objectid $hSum.xoUser.userPrincipalName -Top $MaxRecips | select -first $MaxRecips ;
                                write-verbose "`$hSum.txGuest:`n$(($hSum.txGuest|out-string).trim())" ;
                                #$Rpt += $hSum.OPRemoteMailbox.primarysmtpaddress ;
                                write-host "$($txR.ExternalEmailAddress): matches a Guest object with UPN:$($hSum.xoUser.userPrincipalName)" ;
                                if($hSum.txGuest.EmailAddresses -eq $null){
                                    write-warning "Guest appears to have damage from conficting replicated onprem MailContact, as it's EmailAddresses property is *blank*" ;
                                } ;
                                break ;
                            } ;
                            "MailContact" {
                                #$hSum.OPRemoteMailbox=get-remotemailbox $txR.identity  ;
                                #$Rpt += $hSum.OPRemoteMailbox.primarysmtpaddress ;
                                write-host "$($txR.primarysmtpaddress): matches an EXO MailContact with external Email: $($txR.primarysmtpaddress)" ;
                                break ;
                            } ;
                            "MailUniversalSecurityGroup" {
                                #$hSum.OPRemoteMailbox=get-remotemailbox $txR.identity  ;
                                #$Rpt += $hSum.OPRemoteMailbox.primarysmtpaddress ;
                                write-host "$($txR.primarysmtpaddress): matches an EXO MailUniversalSecurityGroup with Dname: $($txR.displayname)" ;
                                break ;
                            } ;
                            default {
                                write-warning "$((get-date).ToString('HH:mm:ss')):Unsupported RecipientType:($hSum.OPRcp.recipienttype). EXITING!" ;
                                Break ;
                            }
                        }
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Continue ;
                    } ;
                }  # loop-E $txR
                # contacts and guests won't drop with $hSum.OPRemoteMailbox or $hSum.OPMailbox populated
                TRY {
                    $pltGadu=[ordered]@{Identity = $null ; Properties='*' ;errorAction='SilentlyContinue'} ;
                    if($hSum.OPRemoteMailbox ){
                        $pltGadu.identity = $hSum.OPRemoteMailbox.samaccountname;
                    }elseif($hSum.OPMailbox){
                        $pltGadu.identity = $hSum.OPMailbox.samaccountname ;
                    } ;
                    if($pltGadu.identity){
                        write-verbose "Get-ADUser w`n$(($pltGadu|out-string).trim())" ;
                        # try a nested local trycatch, against a missing result
                        Try {
                            #Get-ADUser $DN -ErrorAction Stop ;
                            $hSum.ADUser =Get-ADUser @pltGadu | select -first $MaxRecips ;
                        } Catch [Microsoft.ActiveDirectory.Management.ADIdentityNotFoundException] {
                            write-warning "(no matching ADuser found:$($pltGadu.identity))" ;
                        } catch {
                            $ErrTrapd=$Error[0] ;
                            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Continue ;
                        } ;

                        write-verbose "`$hSum.ADUser:`n$(($hSum.ADUser|fl $propsADU | out-string).trim())" ;
                        $smsg = "(TOR USER, fed:$($TORMeta.adforestname))" ;
                        $hSum.Federator = $TORMeta.adforestname ;
                        write-host -Fore yellow $smsg ;
                        if($hSum.OPRemoteMailbox){
                            $smsg = "$(($hSum.OPRemoteMailbox |fl $propsMailx|out-string).trim())"
                            #$smsg += "`n-Title:$($hSum.ADUser.Title)"
                            $smsg += "`n$(($hSum.ADUser |fl 'Enabled','Description','whenCreated','whenChanged','Title' |out-string).trim())"
                        } ;
                        if($hSum.OPMailbox){
                            $smsg =  "$(($hSum.OPMailbox |fl $propsMailx|out-string).trim())" ;
                            $smsg += "`n$(($hSum.ADUser |fl 'Enabled','Description','whenCreated','whenChanged','Title' |out-string).trim())"
                        } ;
                        write-host $smsg ;
                    } ;
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Continue ;
                } ;

                if($outObject){

                } else {
                    $Rpt += $hSum.xoMailbox.primarysmtpaddress ;
                } ;
                $ino = 0 ;
                foreach($xmbx in $hSum.xoMailbox){
                    $ino++;
                    if($hSum.xoMailbox -isnot [system.array]){
                        $smsg = "xmbx$($ino):$($xmbx.userprincipalname)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    if($xmbx.isdirsynced){
                        # can be federated to VEN|CMW|Toro
                        switch -regex ($xmbx.primarysmtpaddress.split('@')[1]){
                            $CMWMeta.rgxOPFederatedDom {
                                $smsg="(CMW USER, fed:$($CMWMeta.adforestname))" ;
                                $hSum.Federator = $CMWMeta.adforestname ;
                            }
                            $TORMeta.rgxOPFederatedDom {
                                $smsg="(TOR USER, fed:$($TORMeta.adforestname))" ;
                                $hSum.Federator = $TORMeta.adforestname ;
                            }
                            $VENMeta.rgxOPFederatedDom {
                                $smsg="(VEN USER, fed:$($venmeta.o365_TenantLabel))" ;
                                $hSum.Federator = $VENMETA.o365_TenantLabel ;
                            }
                            $INTMeta.rgxOPFederatedDom {
                                $smsg="(INT USER, fed:$($INTmeta.o365_TenantLabel))" ;
                                $hSum.Federator = $INTMETA.o365_TenantLabel ;
                            }

                        } ;
                    } elseif($hSum.xoMuser.IsDirSynced){
                        switch -regex ($xmbx.primarysmtpaddress.split('@')[1]){
                            $CMWMeta.rgxOPFederatedDom {
                                $smsg="(CMW USER, fed:$($CMWMeta.adforestname))" ;
                                $hSum.Federator = $CMWMeta.adforestname ;
                            }
                            $TORMeta.rgxOPFederatedDom {
                                $smsg="(TOR USER, fed:$($TORMeta.adforestname))" ;
                                $hSum.Federator = $TORMeta.adforestname ;
                            }
                            $VENMeta.rgxOPFederatedDom {
                                $smsg="(VEN USER, fed:$($venmeta.o365_TenantLabel))" ;
                                $hSum.Federator = $VENMETA.o365_TenantLabel ;
                            }
                            $INTMeta.rgxOPFederatedDom {
                                $smsg="(INT USER, fed:$($INTmeta.o365_TenantLabel))" ;
                                $hSum.Federator = $INTMETA.o365_TenantLabel ;
                            }
                        } ;
                    }else{
                        [regex]$rgxTenDom = [regex]::escape("@$($tormeta.o365_TenantDomain)")
                        if($hsum.xoRcp.primarysmtpaddress -match $rgxTenDom){
                                $smsg="(CLOUD-1ST ACCT, unfederated)" ;
                                $hSum.Federator = $TORMeta.o365_TenantDom ;

                        } else {
                            $smsg="(CLOUD-1ST ACCT, unfederated)" ;
                            $hSum.Federator = $TORMeta.o365_TenantDom ;
                        } ;
                    } ;
                } ;  # loop-E
                write-host -Fore yellow $smsg ;
                # skip user lookup if guest already pulled it
                if(!$hSum.xoUser){
                    $ino = 0 ;
                    foreach($xmbx in $hSum.xoMailbox){
                        #write-verbose "$((get-alias ps1GetxUser).definition) -id $($xmbx.UserPrincipalName)"
                        write-verbose "get-xoUser -id $($xmbx.UserPrincipalName)"
                        $hSum.xoUser += get-xouser -id $xmbx.UserPrincipalName -ResultSize $MaxRecips ;
                        write-verbose "`$hSum.xoUser:`n$(($hSum.xoUser|out-string).trim())" ;
                    } ;
                }
                if($hSum.xoMailbox){
                    $ino = 0 ;
                    foreach($xmbx in $hSum.xoMailbox){
                        $ino++ ;
                        if($hSum.xoMailbox -isnot [system.array]){
                            $smsg = "xmbx$($ino):$($xmbx.userprincipalname)" ;
                            write-host $smsg ;
                        } ;
                        write-host -foreground yellow "=get-xMbx:> " -nonewline;
                        write-host "$(($hSum.xoMailbox |fl ($propsMailx |?{$_ -notmatch '(sam.*|dist.*)'})|out-string).trim())`n-Title:$($hSum.xoUser.Title)";
                    } ;

                    if($getMobile){
                        write-host -foreground yellow "===`$hsum.xoMobileDeviceStats: " #-nonewline;
                        $ino = 0 ;
                        foreach($xmob in $hsum.xoMobileDeviceStats){
                            $ino++ ;
                            <#if($hsum.xoMobileDeviceStats -isnot [system.array]){
                                $smsg = "xmob$($ino):$($xmob.userprincipalname)" ;
                                write-host $smsg ;
                            } ;
                            write-host -foreground yellow "=get-xMob:> " -nonewline;
                            write-host "$(($xmob.userprincipalname |fl ($propsMailx |?{$_ -notmatch '(sam.*|dist.*)'})|out-string).trim())`n-Title:$($hSum.xoUser.Title)";
                            #>
                            if($hsum.xoMobileDeviceStats -is [system.array]){
                                 write-host -foreground yellow "=get-xMob$($ino):> " #-nonewline;
                            } else { 
                                write-host -foreground yellow "=get-xMobileDev:> " #-nonewline;
                            } ; 
                            $smsg = "$(($xmob | select $propsMobL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                            $smsg += "`n$(($xmob | select $propsMobL2 |out-markdowntable @MDtbl |out-string).trim())" ;
                            write-host $smsg ;
                        } ;

                    } ; 

                }elseif($hSum.xoMUser){
                    write-host "=get-xMUSR:>`n$(($hSum.xoMUser |fl ($propsMailx |?{$_ -notmatch '(sam.*|dist.*)'})|out-string).trim())`n-Title:$($hSum.xoUser.Title)";
                }elseif($hSum.txGuest){
                    write-host "=get-AADU:>`n$(($hSum.txGuest |fl userp*,PhysicalDeliveryOfficeName,JobTitle|out-string).trim())"
                } ;
                TRY {
                    #write-verbose "$((get-alias ps1GetxRcp).definition) -Filter {Members -eq '$($hSum.xoUser.DistinguishedName)'}`n -RecipientTypeDetails GroupMailbox,MailUniversalDistributionGroup,MailUniversalSecurityGroup"
                    write-verbose "get-xorecipient -Filter {Members -eq '$($hSum.xoUser.DistinguishedName)'}`n -RecipientTypeDetails GroupMailbox,MailUniversalDistributionGroup,MailUniversalSecurityGroup"
                    $hSum.xoMemberOf = get-xorecipient -Filter "Members -eq '$($hSum.xoUser.DistinguishedName)'" -RecipientTypeDetails GroupMailbox,MailUniversalDistributionGroup,MailUniversalSecurityGroup ;
                    write-verbose "`$hSum.xoMemberOf:`n$(($hSum.xoMemberOf|out-string).trim())" ;
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Continue ;
                } ;
            } else {
                write-warning "(no matching EXOP or EXO recipient object:$($usr))"
                # do near Lname[0-3]* searches for comparison
                if($hSum.lname){
                    write-warning "Lname ($($hSum.lname) parsed from input),`nattempting similar LName g-rcp:...`n(up to `$MaxRecips:$($MaxRecips))" ;
                    $lname = $hsum.lname ;
                    #$fltrB = "displayname -like '*$lname*'" ;
                    #write-verbose "RETRY:get-recipient -filter {$($fltr)}" ;
                    #get-recipient "$($txusr.lastname.substring(0,3))*"| sort name
                    $substring = "$($hSum.lname.substring(0,3))*"

                    write-host "get-recipient -id $($substring) -ea 0 |?{$_.recipienttypedetails -ne 'MailContact'} :"
                    if($hSum.Rcp=get-recipient -id $substring -ea 0 -ResultSize $MaxRecips | select -first $MaxRecips |?{$_.recipienttypedetails -ne 'MailContact'}){
                        #$hSum.Rcp | write-output ;
                        # $propsRcpTbl
                        write-host -foregroundcolor yellow "`n$(($hSum.Rcp | ft -a $propsRcpTbl |out-string).trim())" ;
                    } ;
                    #write-host "$((get-alias ps1GetxRcp).definition) -id $($substring) -ea 0 |?{$_.recipienttypedetails -ne 'MailContact'} : "
                    write-host "get-xorecipient -id $($substring) -ea 0 |?{$_.recipienttypedetails -ne 'MailContact'} : "
                    if($hSum.xoRcp=get-xorecipient -id $substring -ea 0 -ResultSize $MaxRecips | select -first $MaxRecips |?{$_.recipienttypedetails -ne 'MailContact'}){
                        #$hSum.xoRcp | write-output ;
                        write-host -foregroundcolor yellow "`n$(($hSum.xoRcp | ft -a $propsRcpTbl |out-string).trim())" ;
                    } ;


                } ;


            } ; # don't break, doesn't continue loop

            # 10:42 AM 9/9/2021 force populate the xoMailbox, ALWAYS - need for xbrain ids
            #if($hSum.xoRcp.recipienttypedetails -eq 'UserMailbox' -AND -not($hSum.xoMailbox)){
            # accomodate array xorcp
            if(($hSum.xoRcp|?{$_.recipienttypedetails -eq 'UserMailbox'}) -AND -not($hSum.xoMailbox)){
                #write-verbose "$((get-alias ps1GetxMbx).definition) w`n$(($pltGMailObj|out-string).trim())" ;
                write-verbose "get-xomailbox w`n$(($pltGMailObj|out-string).trim())" ;
                if($hSum.xoMailbox=get-xomailbox @pltGMailObj -ea 0| select -first $MaxRecips ){
                    $ino = 0 ;
                    $mapiResults = @() ;
                    foreach($xmbx in $hSum.xoMailbox){
                        $ino++ ;
                        if($hSum.xoMailbox -is [system.array]){
                            $msgprefix = "xmbx$($ino):" ;
                        } else { $msgprefix = $null } ;
                        $smsg = $msgprefix, "`$hSum.xoMailbox:`n$(($xmbx|out-string).trim())" -join ' ' ;
                        write-verbose $smsg ;
                        $smsg = $msgprefix,"'xoUserMailbox':Test-exoMAPIConnectivity $($xmbx.userprincipalname)"  -join ' ' ;
                        write-verbose $smsg ;
                       $mapiResults += Test-xoMAPIConnectivity -identity $xmbx.userprincipalname ;
                        $smsg = "Outlook (xoMAPI) Access Test Result:$($mapiResults[$ino - 1].result)" ;
                        if($mapiResults[$ino - 1].result -eq 'Success'){
                            write-host -foregroundcolor green $smsg ;
                        } else {
                            write-WARNING $smsg ;
                        } ;
                    } ;
                    $hSum.xoMapiTest = $mapiResults ;
                } ;
            } ;
            # 3:42 PM 9/25/2023 bring in new quota support as well - it's not populated in the oprcp first test
            if($getQuotaUsage){
                if(($hSum.xoRcp|?{$_.recipienttypedetails -match 'UserMailbox|SharedMailbox|RoomMailbox|EquipmentMailbox'}) -AND -not($hSum.xoMailboxStats)){
                    $pltGMbxStatX=[ordered]@{
                        identity = $hSum.xoMailbox.exchangeguid ;
                        ErrorAction = 'STOP' ; 
                    } ;
                    $smsg = "Get-xoMailboxStatistics  w`n$(($pltGMbxStatX|out-string).trim())"
                    if($verbose){
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-verbose $smsg } ; 
                    } ; 
                    $hSum.xoMailboxStats = Get-xoMailboxStatistics @pltGMbxStatX | select $prpStat;
                    $smsg = "xoMailboxStats Count:$(($hsum.xoMapiTest|measure).count)" ;
                    write-host -foregroundcolor green $smsg ;

                    If($hSum.xoMailbox.UseDatabaseQuotaDefaults){
                        $hSum.xoEffectiveQuotas = $hSum.xoMailboxStats | select @{N ='IssueWarningQuotaMB'; e={$_.DBIssueWarningQuotaMB}},
                        @{n='ProhibitSendQuotaMB'; e={$_.DBProhibitSendQuotaMB}},
                        @{n='ProhibitSendReceiveQuotaMB';e={$_.DBProhibitSendReceiveQuotaMB}}; 
                    } else {
                        $hSum.xoEffectiveQuotas = $hSum.xoMailbox | select @{n="IssueWarningQuotaMB";e={[math]::round($_.IssueWarningQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                        @{n="ProhibitSendQuotaMB";e={[math]::round($_.ProhibitSendQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                        @{n="ProhibitSendReceiveQuotaMB";e={[math]::round($_.ProhibitSendReceiveQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}} ;
                    } ;  
                    $hSum.xoNetOfSendReceiveQuotaMB = $hSum.xoEffectiveQuotas.ProhibitSendQuotaMB - $hSum.xoMailboxStats.TotalMailboxSizeMB ; 

                    $pltGMbxStatX.add('IncludeOldestAndNewestItems',$true) ; 
                    $smsg = "Get-xoMailboxFolderStatistics  w`n$(($pltGMbxStatX|out-string).trim())" ;
                    if($verbose){
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-verbose $smsg } ; 
                    } ; 
                    $smsg = "(-getQuotaUsage:running lengthy Get-xoMailboxFolderStatistics...)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    TRY{
                        $hsum.xoMailboxFolderStats = Get-xoMailboxFolderStatistics @pltGMbxStatX  ;

                        $smsg = "Export FolderStats to`n$(($ofMbxFolderStats|out-string).trim())" ;
                        if($verbose){
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-verbose $smsg } ; 
                        } ; 
                        $hsum.xoMailboxFolderStats | ?{$_.ItemsInFolder -gt 0 -AND $_.identity -notmatch $rgxHiddn } | 
                            select $prpFldr | sort SizeMB -desc | export-csv  -path $ofMbxFolderStats -notype ;

                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                        write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                    } ; 
                    
                }
            } ; 

            #$pltgMsoUsr=@{UserPrincipalName=$null ; MaxResults= $MaxRecips; ErrorAction= 'STOP' } ;
            # maxresults is documented:
            # but causes a fault with no $error[0], doesn't seem to be functional param, post-filter
            # ren refs of $pltgMsoUsr -> $pltgAADUsr
            $pltgAADUsr=@{UserPrincipalName=$null ; ErrorAction= 'STOP' } ;
            if($hSum.ADUser){$pltgAADUsr.UserPrincipalName = $hSum.ADUser.UserPrincipalName }
            elseif($hSum.xoMailbox){$pltgAADUsr.UserPrincipalName += $hsum.xoMailbox.UserPrincipalName }
            elseif($hSum.xoMUser){$pltgAADUsr.UserPrincipalName = $hSum.xoMUser.UserPrincipalName }
            elseif($hSum.txGuest){$pltgAADUsr.UserPrincipalName = $hSum.txGuest.userprincipalname }
            else{} ;

            if($pltgAADUsr.UserPrincipalName){

                if(-not($hSum.AADUser)){
                    write-host -foregroundcolor yellow "=get-AADuser $($pltgAADUsr.UserPrincipalName)>:" ;
                    TRY{
                        caad  -Verbose:$false -silent ;
                        write-verbose "get-AzureAdUser  -objectid $($pltgAADUsr.UserPrincipalName)" ;
                        # have to postfilter, if want specific count -maxresults catch's with no $error[0]
                        $hSum.AADUser  = get-AzureAdUser  -objectid $pltgAADUsr.UserPrincipalName  | select -first $MaxRecips;  ;
                        <# for remote federated, AADU brings in summary of remote ADUser:
                            $hsum.aaduser.ExtensionProperty
                            Key                                                       Value
                            ---                                                       -----
                            odata.metadata                                            https://graph.windows.net/.../$metadata#directoryObjects/@Element
                            odata.type                                                Microsoft.DirectoryServices.User
                            createdDateTime                                           1/13/2021 4:14:48 PM
                            employeeId
                            onPremisesDistinguishedName                               CN=XXX,OU=XXX,...
                            thumbnailPhoto@odata.mediaEditLink                        directoryObjects/.../Microsoft.DirectoryServices.User/thumbnailPhoto
                            thumbnailPhoto@odata.mediaContentType                     image/Jpeg
                            userIdentities                                            []
                            extension_9d88b2c96135413e88afff067058e860_employeeNumber 8621
                             $hsum.aaduser.ExtensionProperty.onPremisesDistinguishedName
                            CN=XXX,OU=XXX,...
                        #>
                        #write-verbose "`$hSum.AADUser:`n$(($hSum.AADUser|out-string).trim())" ;
                        # ObjectId                             DisplayName   UserPrincipalName      UserType

                        #lic pull: $hSum.AADUser | Get-AzureADUserLicenseDetail -ea STOP | select -exp SkuPartNumber
                        write-verbose "`$hsum.AADUserLics = AADU | Get-AzureADUserLicenseDetail -ea STOP | select -exp SkuPartNumber" ;
                        $hsum.AADUserLics =  $hSum.AADUser | Get-AzureADUserLicenseDetail -ea STOP | select -exp SkuPartNumber ; 

                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Continue ;
                    } ;

                } ;

                if(-not($hSum.AADUserMgr) -AND $hSum.AADUser ){
                    write-host -foregroundcolor yellow "=get-AADuserManager $($hSum.AADUser.UserPrincipalName)>:" ;
                    TRY{
                        caad  -Verbose:$false -silent ;
                        write-verbose "get-AzureAdUserManager  -objectid $($hSum.AADUser.UserPrincipalName)" ;
                        # have to postfilter, if want specific count -maxresults catch's with no $error[0]
                        $hSum.AADUserMgr  = get-AzureAdUserManager  -objectid $hSum.AADUser.UserPrincipalName  | select -first $MaxRecips;  ;
                        #write-verbose "`$hSum.AADUserMgr:`n$(($hSum.AADUserMgr|out-string).trim())" ;
                        # (returns a full AADUser obj for the mgr)
                        # we can output the DN: $hSum.AADUserMgr.ExtensionProperty.onPremisesDistinguishedName
                        # useful for determining what 'org' user should be for email address assigns - they get same addr dom as their mgr
                        # |ft -a  $propsaadmgr
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Continue ;
                    } ;

                } ;

                # display user info:
                if(-not($hSum.ADUser)){
                    # remote fed, use AADU to proxy remote AD hybrid info:
                    write-host -foreground yellow "===`$hSum.AADUser: " #-nonewline;
                    $smsg = "$(($hSum.AADUser| select $propsAADL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                    $smsg += "`n$(($hSum.AADUser|select $propsAADL2 |out-markdowntable @MDtbl|out-string).trim())" ;
                    $smsg += "`n$(($hSum.AADUser|select $propsAADL3 |out-markdowntable @MDtbl|out-string).trim())" ;
                    $smsg += "`n$(($hSum.AADUser|select $propsAADL4 |out-markdowntable @MDtbl|out-string).trim())" ;
                    $smsg += "`n$(($hSum.AADUser|select $propsAADL5 |out-markdowntable @MDtbl|out-string).trim())" ;
                    #$hsum.aaduser.ExtensionProperty.onPremisesDistinguishedName
                    if($hSum.Federator -ne $TORMeta.adforestname){
                        $smsg += "`n$($hSum.Federator):Remote ADUser.DN:`n$(($hsum.aaduser.ExtensionProperty.onPremisesDistinguishedName|out-string).trim())" ;
                    }  ;

                    write-host $smsg

                    # assert the real names from the user obj
                    $hSum.dname = $hSum.AADUser.DisplayName ;
                    $hSum.fname = $hSum.AADUser.GivenName ;
                    $hSum.lname = $hSum.AADUser.Surname ;

                } else {
                    #write-verbose "`$hSum.AADUser:`n$(($hSum.AADUser| ft -auto ObjectId,DisplayName,UserPrincipalName,UserType |out-string).trim())" ;
                    # defer to ADUser details
                    #"$(($hSum.ADUser |fl $propsMailx |out-markdowntable @MDtbl|out-string).trim())"
                    <#$propsADL1 = 'UserPrincipalName','DisplayName','GivenName','Surname','Title' ;
                    $propsADL2 = 'Company','Department','PhysicalDeliveryOfficeName' ;
                    $propsADL3 = 'StreetAddress','City','State','PostalCode','TelephoneNumber','MobilePhone' ;
                    #>
                    write-host -foreground yellow "===`$hSum.ADUser: " #-nonewline;
                    $smsg = "$(($hSum.ADUser| select $propsADL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                    $smsg += "`n$(($hSum.ADUser|select $propsADL2 |out-markdowntable @MDtbl|out-string).trim())" ;
                    $smsg += "`n$(($hSum.ADUser|select $propsADL3 |out-markdowntable @MDtbl|out-string).trim())" ;
                    $smsg += "`n$(($hSum.ADUser|select $propsADL4 |out-markdowntable @MDtbl|out-string).trim())" ;
                    <# $propsADL5 = 'whenCreated','whenChanged' ; 
                    $propsADL6 = @{Name='Desc';Expression={$_.Description }} ;
                    #>
                    $smsg += "`n$(($hSum.ADUser|select $propsADL5 |out-markdowntable @MDtbl|out-string).trim())" ;
                    # stick desc on trailing line $propsADL5
                    #$smsg += "`n$(($hSum.ADUser|select $propsADL5 |out-markdowntable @MDtbl|out-string).trim())" ;
                    # flip L5 to fl (suppress crlf wrap)
                    $smsg += "`n$(($hSum.ADUser|select $propsADL6 |Format-List|out-string).trim())" ;

                    # moved DN into adl4, w enabled
                    #$smsg += "`n`$ADUser.DN:`n$(($hsum.aduser.DistinguishedName|out-string).trim())" ;
                    #$smsg += "`n$($hSum.ADUser|select Enabled,distinguishedname| convertTo-MarkdownTable -NoDashRow -Border) `$ADUser.DN:`n$(($hsum.aduser.DistinguishedName|out-string).trim())" ;
                    write-host $smsg ;

                    # assert the real names from the user obj
                    $hSum.dname = $hSum.ADUser.DisplayName ;
                    $hSum.fname = $hSum.ADUser.GivenName ;
                    $hSum.lname = $hSum.ADUser.Surname ;
                } ;

                # acct enabled/disabled: .aduser.Enbabled & .aaduser.AccountEnabled
                if($hSum.aduser){
                    if($hSum.aduser.Enabled){} else {
                        $smsg = "ADUser:$($hSum.ADUser.userprincipalname) AD Account is *DISABLED!*"
                        write-warning $smsg ;
                    } ;
                } ;
                # acct enabled/disabled: .aduser.Enbabled & .aaduser.AccountEnabled
                if($hSum.AADUser){
                    if($hSum.aaduser.AccountEnabled){} else {
                        $smsg = "AADUser:$($hSum.AADUser.userprincipalname) AAD Account is *DISABLED!*"
                        write-warning $smsg ;
                    } ;
                } ;
                if($hSum.ADUser){$hSum.LicenseGroup = $hSum.ADUser.memberof |?{$_ -match $rgxOPLic }}

                if($hSum.ADUser){$hSum.LicenseGroup = $hSum.ADUser.memberof |?{$_ -match $rgxOPLic }}
                elseif($hSum.xoMemberOf){$hSum.LicenseGroup = $hSum.xoMemberOf.Name |?{$_ -match $rgxXLic}}
                #if(!($hSum.LicenseGroup) -AND ($hSum.MsolUser.licenses.AccountSkuId -contains "$($TORMeta.o365_TenantDom.tolower()):ENTERPRISEPACK")){$hSum.LicenseGroup = '(direct-assigned E3)'} ;
                # $hSum.AADUser ; $aadu | Get-AzureADUserLicenseDetail  | select -exp SkuPartNumber
                #if(!($hSum.LicenseGroup) -AND ( $hsum.AADUserLics  -contains "$($TORMeta.o365_TenantDom.tolower()):ENTERPRISEPACK")){$hSum.LicenseGroup = '(direct-assigned E3)'} ;
                # no dom, with aadu licenses
                if(!($hSum.LicenseGroup) -AND ( $hsum.AADUserLics  -contains "ENTERPRISEPACK")){$hSum.LicenseGroup = '(direct-assigned E3)'} ;
                if($hSum.LicenseGroup){$smsg = "LicenseGroup:$($hSum.LicenseGroup)"}
                else{$smsg = "LicenseGroup:(unresolved, direct-assigned other?)" } ;
                write-host $smsg ;

                if($hSum.AADUserMgr){
                    #($hSum.AADUserMgr) |ft -a  $propsaadmgr
                    #$smsg += "`nAADUserMgr:`n$(($hSum.AADUserMgr|select $propsAadMgr |out-markdowntable @MDtbl|out-string).trim())" ;
                    # $propsAADMgrL1, $propsAADMgrL2
                    write-host -foreground yellow "===`$hSum.AADUserMgr: " #-nonewline;
                    $smsg = "$(($hSum.AADUserMgr| select $propsAADMgrL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                    #$smsg += "`n$(($hSum.AADUserMgr|select $propsAADMgrL2 |out-markdowntable @MDtbl|out-string).trim())" ;
                    $smsg += "`n$(($hSum.AADUserMgr|Format-List $propsAADMgrL2|out-string).trim())" ;
                    #$smsg += "`n$(($hSum.AADUserMgr|select $propsADL3 |out-markdowntable @MDtbl|out-string).trim())" ;
                } else {
                    $smsg += "(AADUserMgr was blank, or unresolved)" ;
                } ;
                write-host $smsg ;

                if($getQuotaUsage -AND $hSum.xoMailbox){

                    $smsg += "`n`nLicenses::`n$(($hsum.AADUserLics -join ', ' |out-string).trim())`n`n" ; 
                    $smsg += "`nwhich specify the following size limits:`n$(($hSum.xoEffectiveQuotas| fl |out-string).trim())`n(UseDatabaseQuotaDefaults:$($hSum.xoMailbox.UseDatabaseQuotaDefaults))" ; 
                    $smsg += "`n`nCurrent TotalMailboxSizeMB: $($hSum.xoMailboxStats.TotalMailboxSizeMB)`n`n" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success

                    if($hSum.xoNetOfSendReceiveQuotaMB -lt 0){
                        $smsg = "`n`n*** QuotaStatus: Mailbox is *OVER* mandated SendReceiveQuotaMB by $(($hSum.xoNetOfSendReceiveQuotaMB * -1).tostring("N")) megabytes ***`n`n" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                    } else { 
                        $smsg = "QuotaStatus: Mailbox is below mandated SendReceiveQuotaMB by $(($hSum.xoNetOfSendReceiveQuotaMB).tostring("N")) megabytes" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    } ;

                    $smsg = "`nWith the following non-zero folder metrics`n`n$((import-csv $ofMbxFolderStats | ft -auto |out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success

                    $smsg = "`n===`output to::`n$($ofMbxFolderStats)`n" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    
                    # 10:08 AM 2/27/2024: Add: .xoMailboxFolderStats DiscoveryHolds folder only has ItemsInFolder -gt 0 if there's a hold
                    if($hSum.xoMailbox.LitigationHoldEnabled -OR $hSum.xoMailbox.InPlaceHolds -OR $hSum.xoMailbox.ComplianceTagHoldApplied -OR $hSum.xoMailbox.DelayHoldApplied -OR $hSum.xoMailbox.DelayReleaseHoldApplied -OR ($hSum.xoMailboxFolderStats | ?{$_.name -match 'DiscoveryHolds' -AND $_.ItemsInFolder -gt 0})  ){
                        $smsg = "`n`nEVIDENCE OF LEGAL HOLD DETECTED!:`n$(($hSum.xoMailbox | fl $prpMbxHold|out-string).trim())`n`n" ; 
                        if($hSum.xoMailboxFolderStats | ?{$_.name -match 'DiscoveryHolds' -AND $_.ItemsInFolder -gt 0}){
                            $smsg += "`n$(($hSum.xoMailboxFolderStats | ?{$_.name -match '^DiscoveryHolds$'} | ft -a $prpFldrLH|out-string).trim())`n`n" ; 
                            $smsg += "`n- DiscoveryHolds folder: If In-Place Hold is enabled or if a Microsoft 365 or Office 365 retention policy is assigned to the mailbox, this subfolder contains all items that meet the hold query parameters and are hard deleted." ; 
                            $smsg += "`n- DiscoveryHolds folder.NewestItem: Will reflect *last time LegalHold captured an item* (e.g. if/when LH was disabled and stopped holding traffic, if in the past)`n"; 
                        } 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                    } else {
                        $smsg = "`n`n*No* evidence Of Legal Hold detected:`n$(($hSum.xoMailbox | fl $prpMbxHold|out-string).trim())`n`n" ; 
                        $smsg = "`n$(($hSum.xoMailboxFolderStats | ?{$_.name -match 'DiscoveryHolds'} | ft -a $prpFldrLH|out-string).trim())`n`n" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success

                    } ;  

                    $hsInfo = @"

## System Folder Types and purposes:

- Recoverable Items: Items in the Recoverable Items folder aren't calculated toward the user's mailbox quota. In Exchange Online, the Recoverable Items folder has its own quota. In Exchange Online, the quota for the Recoverable Items folder (in the user's primary mailbox) is automatically increased to 100 GB when a mailbox is placed on Litigation Hold or In-Place Hold. 

    ### Subfolders of Recoverable Items:
    
    *  Deletions: This subfolder contains all items deleted from the Deleted Items folder. (In Outlook, a user can soft delete an item by pressing Shift+Delete.) This subfolder is available to users through the Recover Deleted Items feature in Outlook and Outlook on the web.
    
    *  Versions: If In-Place Hold, Litigation Hold, or a Microsoft 365 or Office 365 retention policy is enabled, this subfolder contains the original copy of the item and also if the item is modified multiple times, a copy of the item before modification is saved.
    
    *  Purges: If either Litigation Hold or single item recovery is enabled, this subfolder contains all items that are hard deleted. 
    
    *  Audits: If mailbox audit logging is enabled for a mailbox, this subfolder contains the audit log entries. 
    
    *  DiscoveryHolds: If In-Place Hold is enabled or if a Microsoft 365 or Office 365 retention policy is assigned to the mailbox, this subfolder contains all items that meet the hold query parameters and are hard deleted.

## Deleted item retention
  An item is considered to be soft deleted in the following cases:
    • A user deletes an item or empties all items from the Deleted Items folder.
    • A user presses Shift+Delete to delete an item from any other mailbox folder.
    
  Soft-deleted items are moved to the Deletions subfolder of the Recoverable Items folder. This provides an additional layer of protection so users can recover deleted items without requiring Help desk intervention. Users can use the Recover Deleted Items feature in Outlook or Outlook on the web to recover a deleted item. Users can also use this feature to permanently delete an item. 
  
  Items remain in the Deletions subfolder until the deleted item retention period is reached. The deleted item retention period for Exchange Online is 30 days (Toroco). In addition to a deleted item retention period, the Recoverable Items folder is also subject to quotas. 
  
  When the deleted item retention period expires, the item is completely removed from Exchange Online.

"@ ; 
                    write-host $hsInfo ;   

                } ; 
            } ;

            # do a split-brain/nobrain check
            # switch ($hSum.OPRcp.recipienttypedetails){
            <#
            AD - Users (more effective)
            (sAMAccountType=805306368)
            AD - Users - disabled
            (&(sAMAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=2))
            AD - Users - dont require password
            (&(sAMAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=32))
            AD - Users - mail enabled
            (&(sAMAccountType=805306368)(mailNickname=*))
            AD - Users - password never expires
            (&(sAMAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=65536))

            Select ($hSum.ADUser.sAMAccountType){
                '0'  { $SAType = "SAM_DOMAIN_OBJECT"}
                '268435456' { $SAType = "SAM_GROUP_OBJECT"}
                '268435457' { $SAType = "SAM_NON_SECURITY_GROUP_OBJECT"}
                '536870912' { $SAType = "SAM_ALIAS_OBJECT"}
                '536870913' { $SAType = "SAM_NON_SECURITY_ALIAS_OBJECT"}
                '805306368' { $SAType = "SAM_NORMAL_USER_ACCOUNT"}
                '805306369' { $SAType = "SAM_MACHINE_ACCOUNT"}
                '805306370' { $SAType = "SAM_TRUST_ACCOUNT"}
                '1073741824' { $SAType = "SAM_APP_BASIC_GROUP"}
                '1073741825' { $SAType = "SAM_APP_QUERY_GROUP"}
                '2147483647' { $SAType = "SAM_ACCOUNT_TYPE_MAX"}
                default { $SAType = "UNKNOWN" }
            } ;
            #>
            # ($hSum.ADUser.sAMAccountType -eq '805306368')

            if($hsum.ADUser){
                $hsum.IsADDisabled = [boolean]($hsum.ADUser.Enabled -eq $true) ; 
             } else {
                write-verbose "(no ADUser found)" ;
            } ;
            if($hsum.AADUser){
                $hsum.IsAADDisabled = [boolean]($hsum.AADUser.AccountEnabled -eq $true) ; 
                $hsum.isDirSynced = [boolean]($hsum.AADUser.DirSyncEnabled  -eq $True)
            } else {
                write-verbose "(no AADUser found)" ;
            } ;
            # shift test to aadu
            if($hSum.AADUser){
                $hsum.IsLicensed = [boolean]($hSum.AADUser.assignedlicenses.count -gt 0)
            } else {
                write-verbose "(no AADUser found)" ;
            } ;

            $smsg = "`n"
            if(($hsum.xoRcp.RecipientTypeDetails -match '(UserMailbox|MailUser)') -AND $hsum.IsLicensed -AND $hSum.xomailbox -AND $hSum.OPMailbox){
                <#OPRcp, xorcp, OPMailbox, OPRemoteMailbox, xoMailbox#>
                $smsg += "SPLITBRAIN!:$($hSum.ADUser.userprincipalname).IsLic'd & has *BOTH* xoMbx & opMbx!" ;
                $hsum.IsSplitBrain = $true ;
            }elseif(($hsum.xoRcp.RecipientTypeDetails -match '(UserMailbox|MailUser)') -AND -not($hsum.IsLicensed) -AND $hSum.xomailbox -AND $hSum.OPMailbox){
                <#OPRcp, xorcp, OPMailbox, OPRemoteMailbox, xoMailbox#>
                $smsg += "SPLITBRAIN!:$($hSum.ADUser.userprincipalname).IsLic'd & has *BOTH* xoMbx & opMbx!`nAND is *UNLICENSED!*" ;
                $hsum.IsSplitBrain = $true ;
            } elseif(($hsum.xoRcp.RecipientTypeDetails -match '(UserMailbox|MailUser)') -AND $hsum.IsLicensed -AND -not($hSum.xomailbox) -AND -not($hSum.OPMailbox)){
                $smsg += "NOBRAIN! W LICENSE!:$($hSum.ADUser.userprincipalname).IsLic'd &  has *NEITHER* xoMbx OR opMbx!" ;
                $hsum.IsNoBrain = $true ;
            } elseif (($hsum.xoRcp.RecipientTypeDetails -match '(UserMailbox|MailUser)') -AND -not($hsum.IsLicensed) -AND -not($hSum.xomailbox) -AND -not($hSum.OPMailbox)){
                $smsg += "NOBRAIN! *WO* LICENSE! (TERM?):$($hSum.ADUser.userprincipalname) NOT licensed'd &  has *NEITHER* xoMbx OR opMbx!" ;
                $hsum.IsNoBrain = $true ;
            } elseif($hsum.IsLicensed -eq $false){
                $smsg += "$($hSum.ADUser.userprincipalname) Is *UNLICENSED*!" ;
                
                $hsum.IsLicensed = $false ;
            } ELSE { } ;

            if($hsum.IsSplitBrain -OR $hsum.IsNoBrain -OR -not $hsum.IsLicensed){
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            } else { 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            } ; 

            if($hsum.IsNoBrain){
                switch ($hSum.Federator) {
                    $TORMeta.adforestname {$rgxTermOU = $TORMeta.rgxTermUserOUs }
                    $CMWMeta.adforestname  {$rgxTermOU = $CMWMeta.rgxTermUserOUs }
                    $VENMETA.o365_TenantLabel  {$rgxTermOU = $NULL }
                    $TORMeta.o365_TenantDom   {$rgxTermOU = $NULL }
                    default {
                        write-warning "UNRECOGNIZED `$hsum.FEDERATOR!:$($hSum.Federator)" ;
                    }
                }

                if($rgxTermOU -AND $hsum.ADUser){
                    if($hsum.ADUser.distinguishedname -match $rgxTermOU){
                        $hsum.IsDisabledOU = $true ;
                        $smsg += "`n--ADUser:$($hsum.ADUser.samaccountname) is within a *DISABLED* OU (likely TERM)" ;
                    } else {
                        $hsum.IsDisabledOU = $false ;
                        $smsg += "`n--ADUser:$($hsum.ADUser.samaccountname) is *NOT* in a DISABLED OU (improperly offboarded TERM?)" ;
                    } ;
                } else {
                    $smsg +=  "`n--Cloud-only or other non-AD-resolvable host" ;
                }
                if($hsum.ADUser){
                    $smsg += "`n----$($hsum.ADUser.distinguishedname)" ;
                    $smsg += "`n--ADUser.Description:$($hsum.ADUser.Description)" ;
                    if($hsum.IsADDisabled){
                        $smsg += "`n--ADUser:$($hsum.ADUser.samaccountname) is *DISABLED* for logon (likely TERM)" ;
                    } else {
                        $smsg += "`n--ADUser:$($hsum.ADUser.samaccountname) is *UN-DISABLED* for logon (improperly offboarded TERM?)" ;
                    } ;
                } else {
                    write-verbose "(no ADUser found)" ;
                } ;
                if($hsum.IsAADDisabled){
                    $smsg += "`n--AADUser:$($hsum.AADUser.UserPrincipalName) is *DISABLED* for logon (likely TERM)" ;
                } else {
                    $smsg += "`n--AADUser:$($hsum.AADUser.UserPrincipalName) is *UN-DISABLED* for logon (improperly offboarded TERM?)" ;
                } ;
                $smsg += "`n"
                write-warning $smsg ;
            } ;



            if($outObject){
                if($PSCmdlet.MyInvocation.ExpectingInput){
                    write-verbose "(pipeline input, skipping aggregator, dropping into pipeline)" ;
                    New-Object PSObject -Property $hSum | write-output  ;
                } else {
                    $Rpt += New-Object PSObject -Property $hSum ;
                } ;
            } ELSE {
                # 3:59 PM 9/18/2023 else export to report file 
                $Rpt += New-Object PSObject -Property $hSum ;
                $Rpt | export-clixml -Path $ofile -Depth 100 ;
            } ;
            write-host -foregroundcolor green $sBnr.replace('=v','=^').replace('v=','^=') ;
        } ;

    } # PROC-E
    END{
        <## cleanup XO aliases
        get-alias -scope Script |?{$_.name -match '^ps1.*'} | %{Remove-Alias -alias $_.name} ; 
        #>

        if($outObject -AND -not ($PSCmdlet.MyInvocation.ExpectingInput)){
            $Rpt | write-output ;
            write-host "(-outObject: Output summary object to pipeline)"
        }elseif($outObject -AND ($PSCmdlet.MyInvocation.ExpectingInput)){
            write-verbose "(pipeline input, individual objects dropped into pipeline)" ;
        } else {
            $oput = ($Rpt | select-object -unique) -join ',' ;
            $oput | out-clipboard ;
            write-host "(output copied to clipboard)"
            $oput |  write-output ;
        } ;

     } ;
 }

#*------^ resolve-user.ps1 ^------


#*------v test-IsGuid.ps1 v------
function Test-IsGuid{
    <#
    .SYNOPSIS
    Test-IsGuid.ps1 - Validates a given guid using the TryParse method from the .NET Class “System.Guid”
    .NOTES
    Version     : 1.0.0
    Author      : Morgan
    Website     :	https://morgantechspace.com/
    Twitter     :	
    CreatedDate : 2022-06-23
    FileName    : Test-IsGuid.ps1
    License     : [none specified]
    Copyright   : © 2022 MorganTechSpace
    Github      : https://github.com/tostka/verb-text
    Tags        : Powershell,GUID
    AddedCredit : 
    AddedWebsite:	https://morgantechspace.com/2021/01/powershell-check-if-string-is-valid-guid-or-not.html
    REVISIONS
    10:13 AM 6/23/2022 add to verb-text
    1/12/21 posted version morgantechspace.com
    .DESCRIPTION
    Test-IsGuid.ps1 - Validates a given guid using the TryParse method from the .NET Class “System.Guid”
    .PARAMETER String
    String to be validated
    .INPUTS
    Accepts pipeline input
    .OUTPUTS
    System.Boolean
    .EXAMPLE
    Test-IsGuid -string '17863633-98b5-4898-9633-e92ccccd634c'
    Stock call
    .LINK
    https://github.com/tostka/verb-text
    .LINK
    https://morgantechspace.com/2021/01/powershell-check-if-string-is-valid-guid-or-not.html
    #>
    [CmdletBinding()]
    [OutputType([bool])]
    Param(
        # Uri to be validated
        [Parameter(Mandatory=$true, ValueFromPipelineByPropertyName=$true, Position=0)]
        #[Alias('')]
        [string]$String
    ) ;
    $ObjectGuid = [System.Guid]::empty
    # Returns True if successfully parsed
    return [System.Guid]::TryParse($String,[System.Management.Automation.PSReference]$ObjectGuid) ;
}

#*------^ test-IsGuid.ps1 ^------


#*------v test-IsNumeric.ps1 v------
Function test-IsNumeric {
    <#
    .SYNOPSIS
    test-IsNumeric.ps1 - Test a given value is numeric
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-04-17
    FileName    : test-IsNumeric.ps1
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-text
    Tags        : Powershell,Text
    REVISIONS
    * 10:59 AM 9/20/2021 ren'd IsNumeric -> test-isNumeric and added orig name as alias 
    * 8:27 PM 5/23/2014
    .DESCRIPTION
    test-IsNumeric.ps1 - Test a given value is numeric
    .PARAMETER Value
    Value to be evaluated
    .EXAMPLE
    $value="Win";test-IsNumeric($value);
    Test whether the string 'Win' is numeric (returns False)
    .EXAMPLE
    $value="80";test-IsNumeric($value);
    Test whether the string '80' is numeric (returns True)
    .LINK
    https://github.com/tostka/verb-text
    #>
    [CmdletBinding()]
    [Alias('IsNumeric')]
    param($value)
    ($($value.Trim()) -match "^[-+]?([0-9]*\.[0-9]+|[0-9]+\.?)$") | write-output ; 
}

#*------^ test-IsNumeric.ps1 ^------


#*------v test-IsRegexPattern.ps1 v------
Function test-IsRegexPattern {
    <#
    .SYNOPSIS
    test-IsRegexPattern.ps1 - 1) does simple [regex]$pattern validation -AND checks for common rgx operators (And that it contains 1+ of ^[]\{}+*?): That a given string will *pass* for a regular-expresison - doesn't mean it's going to work, just that it doesn't fail initial parsing. Only way to know for sure is to try both -like & -match with the pattern and take the one that returns results. 
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-04-17
    FileName    : test-IsRegexPattern.ps1
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka
    Tags        : Powershell,Text
    REVISIONS
    * 12:28 PM 5/2/2022 updated examples, to better discern match vs like filter
    * 2:22 PM 11/12/2021 added [regex]$string initial test; fixed some typos; added example to run stack of rgx strings and output scores. 
    Expanded Description; Switched Threshold to 1; Added a verbose grouping output on $rgxOpsSingle; removed () from duplication in $rgxOpsPairedUnCommon; Seems functional. 
    * 11:10 AM 9/20/2021 init
    .DESCRIPTION
    test-IsRegexPattern.ps1 - does simple argument validation that a given string will pass for a regular-expresison, then scores for matches of three classes of Regex Operators in a given string:
    - does it match any single-character operators: \.*+?|^$ (score 1 per match)
    - does it match any common paired operators : (..) (score 5 for any match)
    - does it match any uncommon paired operators : [..]|{..} (score 10 for any match)
    - does it match a BackReference operator: \1 to \9 (score 20 for any match)
    If the net score on a string exceeds the specified Threshold (defaults to 1), [boolean]$true is returned. 

    Of course 'Threshold' is entirely arbitrary. But I did run some tests at it, to profile a range of regex/non-regex scores:
    (code used is in example 3)
    score name                                                                                                                                    
    ----- ----                                                                                                                                    
       27 (one()|two())-and-(three\2|four\3)                                                                                                      
       26 <img\s+src\s*=\s*["']([^"']+)["']\s*/*>                                                                                                 
       27 \b(?<username>[A-Z0-9._%+-]+)@(?<domain>[A-Z0-9.-]+\.[A-Z]+)\b                                                                          
       15 \.\d{2}\.                                                                                                                               
       55 ^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*...
       21 ^([0]?[1-9]|[1][0-2])[./-]([0]?[1-9]|[1|2][0-9]|[3][0|1])[./-]([0-9]{4}|[0-9]{2})$                                                      
       12 ^[0-2][0-3]:[0-5][0-9]$                                                                                                                 
       13 ^E[0-9a-fA-F]{10}.log$                                                                                                                  
        3 This\sis\sthe\send                                                                                                                      
        0 These are the times to test men's minds                                                                                                 
       13 ^\w{2,20}$                                                                                                                              
       19 (?i)DC=\w{1,}?\b                                                                                                                        
       15 ((s-)*)\w*\.\w*@(toro((lab)*)|)\.com                                                                                                    
       22 (?i:^(ADL|BCC|LYN|SPB)(MS(5|6)(2|4|5)((0)*)(0|1)((D)*)|\-\w{7})$)                                                                       
       25 ^sip:([0-9a-zA-Z]+[-._+&])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,6}$                                                               
        0 any character or a newline repeated zero or more times                                                                                  
       13 ^(.*?)\.(?i:RDP)$                                                                                                                       
       21 #\sSIG\s#\sBegin\ssignature\sblock(.|\n)*(.|\n)*#\sSIG\s#\sEnd\ssignature\sblock                                                        
       18 \w+((\s)*)\.\n((\r)*)((\s)*)\w+  


    Regex operators factored into the above: 
    - . matchany
    - * match zero or more: 
    - + match one or more
    - ? match zero or one
    - {} interval ops
    - | alternation op
    - [] list ops (char class)
    - - , [x-y] range op 
    - () grouping ops
    - \digit back-ref op
    - ^ match beginning-of-line 
    - $ match end-of-line
    
    .PARAMETER String
    String to be evaluated
    .PARAMETER Threshold
    Threshold score to classifiy a string as a regex pattern (1+, defaults to 1, the higher the stronger the confidence)[-Threshold 7]
    .PARAMETER ReturnScore
    Switch to return the score, rather than $true/$false[-returnscore]
    .EXAMPLE
    $pattern="I'm\sa\sREGEX";test-IsRegexPattern($PATTERN);
    Test whether the string evaluates as likely regex
    .EXAMPLE
    PS> if(test-IsRegexPattern -pattern $pattern){
    PS>     if(([regex]::matches($pattern,'\*').count) -AND ([regex]::matches($pattern,'\.').count -eq 0)){
    PS>         write-verbose "(-pattern specified - $($pattern): has wildcard *, but no period => 'like filter')" ; 
    PS>         $haystack = $haystack |Where-Object{$_.name -like $pattern}
    PS>         write-verbose "(-pattern specified - $($pattern) - *failed* as a regex, but worked, using -like postfilter)" ; 
    PS>         write-verbose "(use non-regex replace syntax)" ;
    PS>         $target.replace($pattern,$newString);
    PS>     } elseIf($haystack = $haystack |Where-Object{$_.name -match $pattern}){
    PS>         write-verbose "(-pattern specified - $($pattern) - worked as a regex, using -match postfilter)" ; 
    PS>         write-verbose "(use regex replace syntax)" ;
    PS>         $haystack -replace $pattern,$newString;
    PS>         #$likeResults | write-output ;
    PS>     } elseif ($haystack = $haystack |Where-Object{$_.name -like $pattern}){
    PS>         write-verbose "(-pattern specified - $($pattern) - *failed* as a regex, but worked, using -like postfilter)" ; 
    PS>         write-verbose "(use non-regex replace syntax)" ;
    PS>         $target.replace($pattern,$newString);
    PS>     } ;
    PS> } elseif ($haystack = $haystack |Where-Object{$_.name -like $pattern}){
    PS>     write-verbose "(-pattern specified - $($pattern) - would jnot pass test-IsRegexPattern: used a -like postfilter)" ; 
    PS>     write-verbose "(use non-regex replace syntax)" ;
    PS>     $target.replace($pattern,$newString);
    PS> } ;    
    Fancy conditional to evaluate -like from -regex filter string.
    .EXAMPLE
    PS> $rgxs ='(one()|two())-and-(three\2|four\3)' , '<img\s+src\s*=\s*["'']([^"'']+)["'']\s*/*>',
    PS>  "\b(?<username>[A-Z0-9._%+-]+)@(?<domain>[A-Z0-9.-]+\.[A-Z]+)\b", "\.\d{2}\.",
    PS>   "^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$", 
    PS>   "^([0]?[1-9]|[1][0-2])[./-]([0]?[1-9]|[1|2][0-9]|[3][0|1])[./-]([0-9]{4}|[0-9]{2})$", "^[0-2][0-3]:[0-5][0-9]$",
    PS>    "^E[0-9a-fA-F]{10}.log$", "This\sis\sthe\send", "These are the times to test men's minds", 
    PS>    "^\w{2,20}$", '(?i)DC=\w{1,}?\b', '((s-)*)\w*\.\w*@(brand((lab)*)|)\.com', 
    PS>    "(?i:^(ABC|DEF|GHI|JKL)(MS(5|6)(2|4|5)((0)*)(0|1)((D)*)|\-\w{7})$)", 
    PS>    "^sip:([0-9a-zA-Z]+[-._+&])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,6}$", 
    PS>    "any character or a newline repeated zero or more times", "^(.*?)\.(?i:RDP)$", 
    PS>    "#\sSIG\s#\sBegin\ssignature\sblock(.|\n)*(.|\n)*#\sSIG\s#\sEnd\ssignature\sblock", 
    PS>    "\w+((\s)*)\.\n((\r)*)((\s)*)\w+" ; 
    PS> $Summary = @() ; 
    PS> foreach($rgx in $rgxs){
    PS>   $rpt = @{name= $rgx; score=$null} ; 
    PS>   $rpt.score = TEST-isregexpattern $rgx -ReturnScore -verbose ; 
    PS>   $Summary+= [pscustomobject]$rpt ; 
    PS> } ; 
    PS> $Summary  ; 
    Quick test suite to calibarate appropriate 'Threshold' for this function: Runs an array of variant regex strings through, 
    and reports on range of scores for comparison. 
    .LINK
    #>
    [CmdletBinding()]
    #[Alias('IsRegexValid')]
    param(   
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Pattern to be evaluated[-string '^My\sRegex$']")]
        [Alias('Pattern','Text')]
        [string]$string,
        [Parameter(HelpMessage="Threshold score to classifiy a string as a regex pattern (1+, defaults to 1, the higher the stronger the confidence)[-Threshold 7]")]
        [int]$Threshold=1,
        [Parameter(HelpMessage="Switch to return the score, rather than `$true/`$false[-returnscore]")]
        [switch]$ReturnScore
    )
    $rgxOpsSingle = [regex]'[\.\*\+\?\\^\$]' ; # single-char ops as literals: \.*+?|^$ (score 1 per match)
    $rgxOpsPairedCommon = [regex]'(\(.*\))' # (...)  (score 5 for any match)
    $rgxOpsPairedUnCommon = [regex]'(\[.*\]|\{.*\})' # paired ops - require the pair as a bracketing set, to function. ({[..]}) (score 10 for any match)
    $rgxBackRef = [regex]'\\[1-9]' ; # match \1 to \9 backrefs: (a(b))\2* (score 10 for any match)
    # below was a coarse attempt at any single instance of any op, no score, aimed at boolean eval.
    #$rgxRgxOps = [regex]'[\^\[\]\\\{\}\+\*\?\.]+' ; # check for ops:  ^[]\{}+*?() \^\[]\\\{}+\*?()
    try{
        # do the coarsest 'will it type as regex'? Proves litte, regular english will pass, but it's a starting point. 
      if([regex]$string){
            write-verbose "(passes initial test:`n[regex]$($string)" ; 
      } ; 

      #$bCouldBeRegex = ([boolean]([regex]$string) -AND [boolean]($string -match $rgxRgxOps) ); 
      $Score = 0 ; 
      if($ops = $string -split '' -match $rgxOpsSingle){
          #$Score += ($string -split '' -match $rgxOpsSingle | measure).count ;
          $Score += $ops.count ; 
          write-verbose "`$rgxOpsSingle matches:`n$(($ops | group | ft -auto count,name|out-string).trim())`nScore:$($score)" ;
      } ;
      if($string -match $rgxOpsPairedCommon){
          $vMatch = [regex]::match($string,$rgxOpsPairedCommon).captures[0].value ; 
          $Score += 5 ; 
          write-verbose "`$rgxOpsPairedCommon at least one match:`n$(($vMatch|out-string).trim())`nScore:$($score)" ; 
      } ;
      if($string -match $rgxOpsPairedUnCommon){
          $vMatch = [regex]::match($string,$rgxOpsPairedUnCommon).captures[0].value ; 
          $Score += 10 ;
          write-verbose "`$rgxOpsPairedUnCommon at least one match:`n$(($vMatch|out-string).trim())`nScore:$($score)" ;
      } ;
      if ($string -match $rgxBackRef) {
          $Score += 20 ;
          $vMatch = [regex]::match($string,$rgxBackRef).captures[0].value ; 
          write-verbose "`$rgxBackRef at least one match:`n$(($vMatch|out-string).trim())`nScore:$($score)" ;
      } ;
      write-verbose "(Aggregate Score:$($score))" ; 
      if($ReturnScore){
          $score | write-output ; 
      } else { 
          [boolean]($Score -ge $Threshold) | write-output ;
      } ; 
    } catch {
        $false | write-output ;
    }     
}

#*------^ test-IsRegexPattern.ps1 ^------


#*------v test-IsRegexValid.ps1 v------
Function test-IsRegexValid {
    <#
    .SYNOPSIS
    test-IsRegexValid.ps1 - does simple argument validation that a given string will pass for a regular-expresison - doesn't mean it's going to work, just that it doesn't fail initial parsing. 
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-04-17
    FileName    : test-IsRegexValid.ps1
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka
    Tags        : Powershell,Text
    REVISIONS
    * 11:10 AM 9/20/2021 init
    .DESCRIPTION
    test-IsRegexValid.ps1 - does simple argument validation that a given string will pass for a regular-expresison - doesn't mean it's going to work, just that it doesn't fail initial parsing. 
    .PARAMETER pattern
    Value to be evaluated
    .EXAMPLE
    $pattern="I'm\sa\sREGEX";test-IsRegexValid($PATTERN);
    Test whether the string pattern' will parse as a regex
    .LINK
    #>
    [CmdletBinding()]
    #[Alias('IsRegexValid')]
    param([string]$pattern)
    try{
        if([regex]$pattern){$true| write-output}
    } catch {
        $false | write-output ;
    }     
}

#*------^ test-IsRegexValid.ps1 ^------


#*------v test-IsUri.ps1 v------
function test-IsUri{
    <#
    .SYNOPSIS
    test-IsUri.ps1 - Validates a given Uri ; localized verb-EXO vers of non-'$global:' helper funct from ExchangeOnlineManagement. The globals export fine, these don't and appear to need to be loaded manually
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 20201109-0833AM
    FileName    : test-IsUri.ps1
    License     : [none specified]
    Copyright   : [none specified]
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell
    AddedCredit : Microsoft (edited version of published commands in the module)
    AddedWebsite:	https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2
    REVISIONS
    * 1:11 PM 6/29/2022 renamed test-uri-> test-IsUri, aliased orig name
    * 2:08 PM 12/6/2021 ren'd UriString param to String, and added orig name as alias. Set CBH Output, and broader example; moving into verb-text, where it better fits.
    * 8:34 AM 11/9/2020 init
    .DESCRIPTION
    test-IsUri.ps1 - localized verb-EXO vers of non-'$global:' helper funct from ExchangeOnlineManagement. The globals export fine, these don't and appear to need to be loaded manually. Note this only validates https, not http (which will fail). 
    .PARAMETER String
    String to be validated
    .PARAMETER PermitHttp
    Switch to permit validation of either https or http uri.schemes
    .INPUTS
    Accepts pipeline input
    .OUTPUTS
    System.Boolean
    .EXAMPLE
    test-IsUri -string https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2 
    Stock call
    .EXAMPLE
    test-IsUri -string https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2 
    Call that accepts either https or http scheme (default fails http://)
    .LINK
    https://github.com/tostka/verb-text
    .LINK
    https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2
    #>
    [CmdletBinding()]
    [Alias('test-URI')]
    [OutputType([bool])]
    Param(
        # Uri to be validated
        [Parameter(Mandatory=$true, ValueFromPipelineByPropertyName=$true, Position=0)]
        [Alias('UriString')]
        [string]$String,
        [Parameter()][switch]$PermitHttp
    ) ;
    [Uri]$uri = $String -as [Uri]
    if($PermitHttp){
      ($uri.AbsoluteUri -ne $null) -and ($uri.Scheme -eq 'https' -OR $uri.Scheme -eq 'http')
    } else { 
      $uri.AbsoluteUri -ne $null -and $uri.Scheme -eq 'https' ;
    } ; 
}

#*------^ test-IsUri.ps1 ^------


#*======^ END FUNCTIONS ^======

Export-ModuleMember -Function compare-CodeRevision,convert-CaesarCipher,_encode,_decode,Convert-CodePointToPSSyntaxTDO,convertFrom-Base64String,convert-HtmlCodeToTextTDO,Convert-invertCase,convert-Rot13,convert-Rot47,convertto-AcronymFromCaps,convertTo-Base64String,convertto-Base64StringCommaQuoted,ConvertTo-CamelCase,ConvertTo-CleanString,ConvertTo-L33t,ConvertTo-lowerCamelCase,convertTo-PSHelpExample,convertTo-QuotedList,ConvertTo-SCase,ConvertTo-SNAKE_CASE,convertto-StringCommaQuote,ConvertTo-StringQuoted,convertTo-StringReverse,convertTo-StUdlycaPs,convertTo-TitleCase,convertTo-UnWrappedText,convertTo-WordsReverse,convertTo-WrappedText,convert-UnicodeUPlusToCharCode,Get-CharInfo,ReadUnicodeRanges,ReadUnicodeData,out,get-StringHash,new-LoremString,Remove-StringDiacritic,Remove-StringLatinCharacters,resolve-user,Test-IsGuid,test-IsNumeric,test-IsRegexPattern,test-IsRegexValid,test-IsUri -Alias *




# SIG # Begin signature block
# MIIELgYJKoZIhvcNAQcCoIIEHzCCBBsCAQExCzAJBgUrDgMCGgUAMGkGCisGAQQB
# gjcCAQSgWzBZMDQGCisGAQQBgjcCAR4wJgIDAQAABBAfzDtgWUsITrck0sYpfvNR
# AgEAAgEAAgEAAgEAAgEAMCEwCQYFKw4DAhoFAAQUh15uDduNtWwqnBNetQs/QJEk
# LqigggI4MIICNDCCAaGgAwIBAgIQWsnStFUuSIVNR8uhNSlE6TAJBgUrDgMCHQUA
# MCwxKjAoBgNVBAMTIVBvd2VyU2hlbGwgTG9jYWwgQ2VydGlmaWNhdGUgUm9vdDAe
# Fw0xNDEyMjkxNzA3MzNaFw0zOTEyMzEyMzU5NTlaMBUxEzARBgNVBAMTClRvZGRT
# ZWxmSUkwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBALqRVt7uNweTkZZ+16QG
# a+NnFYNRPPa8Bnm071ohGe27jNWKPVUbDfd0OY2sqCBQCEFVb5pqcIECRRnlhN5H
# +EEJmm2x9AU0uS7IHxHeUo8fkW4vm49adkat5gAoOZOwbuNntBOAJy9LCyNs4F1I
# KKphP3TyDwe8XqsEVwB2m9FPAgMBAAGjdjB0MBMGA1UdJQQMMAoGCCsGAQUFBwMD
# MF0GA1UdAQRWMFSAEL95r+Rh65kgqZl+tgchMuKhLjAsMSowKAYDVQQDEyFQb3dl
# clNoZWxsIExvY2FsIENlcnRpZmljYXRlIFJvb3SCEGwiXbeZNci7Rxiz/r43gVsw
# CQYFKw4DAh0FAAOBgQB6ECSnXHUs7/bCr6Z556K6IDJNWsccjcV89fHA/zKMX0w0
# 6NefCtxas/QHUA9mS87HRHLzKjFqweA3BnQ5lr5mPDlho8U90Nvtpj58G9I5SPUg
# CspNr5jEHOL5EdJFBIv3zI2jQ8TPbFGC0Cz72+4oYzSxWpftNX41MmEsZkMaADGC
# AWAwggFcAgEBMEAwLDEqMCgGA1UEAxMhUG93ZXJTaGVsbCBMb2NhbCBDZXJ0aWZp
# Y2F0ZSBSb290AhBaydK0VS5IhU1Hy6E1KUTpMAkGBSsOAwIaBQCgeDAYBgorBgEE
# AYI3AgEMMQowCKACgAChAoAAMBkGCSqGSIb3DQEJAzEMBgorBgEEAYI3AgEEMBwG
# CisGAQQBgjcCAQsxDjAMBgorBgEEAYI3AgEVMCMGCSqGSIb3DQEJBDEWBBSgWGDl
# zlFsTJWXYrKr7Z+2BXXfaTANBgkqhkiG9w0BAQEFAASBgF7IMYG46MSh9uUi8pS4
# ZZb5qSvUOrsNZabuoR2ErS2abxY20kQw0O19p4Sa7I34bzSwA1eK8typqw7I2PYk
# aL6UTMzF1Gb6m3g7jqWWFrQAFFBt+zY8m4zW0nuvieyevVVt38FvlJlHoy1ur3MO
# 21LoGLeuk8OjNHhgd5kd8UCq
# SIG # End signature block
